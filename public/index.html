<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Ayman's PlayTorrio</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<!-- Video.js CSS -->
<link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
<style>
        /* Performance mode overrides: remove expensive visual effects when enabled */
        body.perf-mode * { backdrop-filter: none !important; }
        body.perf-mode .shadow-heavy { box-shadow: none !important; }
        /* Prefer letting Chrome skip offscreen rendering */
        body.perf-mode img { content-visibility: auto; }
        :root {
            --primary: #2a1847;    /* header/cards */
            --secondary: #8b5cf6;  /* subtle accents */
            --tertiary: #c084fc;   /* highlights/pills */
            --dark: #120a1f;       /* page background */
            --light: #f8f9fa;      /* text */
            --gray: #6c757d;       /* muted text */
            --danger: #dc3545;
            --success: #28a745;
            /* Accent (kept var name for minimal changes) */
            --vlc-orange: #a855f7; /* accent purple */
            --vlc-dark: #2d2d2d;
            /* Restored previously implicit theme variables used throughout layout */
            --header-bg: var(--primary);
            --card-bg: #1d1233;
            --input-bg: rgba(255,255,255,0.06);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--dark);
            color: var(--light);
            overflow-x: hidden;
        }

        /* Custom Title Bar - hidden on macOS to use native */
        .custom-title-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: linear-gradient(135deg, rgba(42, 24, 71, 0.95) 0%, rgba(18, 10, 31, 0.95) 100%);
            border-bottom: 1px solid rgba(168, 85, 247, 0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            z-index: 999999;
            -webkit-app-region: drag;
            user-select: none;
        }
        
        /* Hide custom title bar on macOS */
        body.platform-darwin .custom-title-bar {
            display: none;
        }
        
        /* Adjust body padding only for non-mac platforms */
        body.ui-new:not(.platform-darwin) {
            padding-top: 32px;
        }
        
        body.ui-new:not(.platform-darwin) header {
            top: 32px;
        }

        /* Keep full-screen overlays below the title bar in the new UI */
        body.ui-new:not(.platform-darwin) .wcjs-player-container,
        body.ui-new:not(.platform-darwin) .vlc-player-container,
        body.ui-new:not(.platform-darwin) .custom-player-container,
        body.ui-new:not(.platform-darwin) #livetv-stream-viewer,
        body.ui-new:not(.platform-darwin) #video-player-modal,
        body.ui-new:not(.platform-darwin) #books-reader-modal,
        body.ui-new:not(.platform-darwin) #epubReaderOverlay,
        body.ui-new:not(.platform-darwin) #server-selection-modal {
            top: 32px !important;
            height: calc(100vh - 32px) !important;
        }
        
        .title-bar-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--light);
        }
        
        .title-bar-title {
            opacity: 0.9;
        }
        
        .title-bar-controls {
            display: flex;
            gap: 4px;
            -webkit-app-region: no-drag;
        }
        
        .title-bar-btn {
            width: 46px;
            height: 32px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 10px;
            position: relative;
        }
        
        .title-bar-btn svg {
            width: 10px;
            height: 10px;
        }
        
        .title-bar-btn:hover {
            background: rgba(168, 85, 247, 0.2);
        }
        
        .title-bar-btn.title-bar-close:hover {
            background: #dc3545;
            color: white;
        }
        
        /* Adjust body padding for title bar */
        body.ui-new:not(.platform-darwin) {
            padding-top: 32px;
        }
        
        body.ui-new:not(.platform-darwin) header {
            top: 32px;
        }

        /* Global performance profile (safe visual downgrades only) */
        body.perf-mode * { backdrop-filter: none !important; }
        body.perf-mode .shadow-heavy { box-shadow: none !important; }
        body.perf-mode img { content-visibility: auto; }
        body.perf-mode #updateOverlay { backdrop-filter: none !important; }

        header {
            background-color: var(--header-bg);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 900;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--light);
            text-decoration: none;
        }
        
        /* Search Container */
        .search-container {
            position: relative;
            flex: 1;
            max-width: 600px;
        }
        
        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--gray);
            pointer-events: none;
        }
        
        .search-container input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            border: 2px solid rgba(168, 85, 247, 0.3);
            border-radius: 25px;
            background-color: var(--input-bg);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .search-container input:focus {
            outline: none;
            border-color: var(--vlc-orange);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.1);
        }
        
        .search-container input::placeholder {
            color: var(--gray);
        }
        
        .user-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: nowrap; /* Keep buttons on same line */
        }
        
        /* Consistent button sizing for navbar */
        .user-actions .btn {
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
            white-space: nowrap;
            min-height: 38px;
            border-radius: 8px;
            flex-shrink: 1; /* Allow buttons to shrink */
        }
        
        .user-actions .btn i {
            font-size: 0.95rem;
        }
        
        /* Update & version modals removed (v1.5.3 / v1.6.3). Old modal styles cleaned up. */
        
        /* Base button style (restored) */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .btn-primary {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 2px solid var(--vlc-orange);
            color: var(--vlc-orange);
        }
        
        .btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn-primary:hover {
            background-color: #9333ea;
        }
        
        .btn-outline:hover {
            background-color: rgba(168, 85, 247, 0.1);
        }
        
        .btn-outline.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        main {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        .section-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-left: 1rem;
            border-left: 4px solid var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .section-title i {
            color: var(--tertiary);
        }
        
        .categories {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            overflow-x: auto;
            padding: 0.5rem 0;
        }
        
        .category {
            padding: 0.8rem 1.5rem;
            background-color: var(--input-bg);
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), background-color 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            white-space: nowrap;
            font-weight: 600;
        }
        
        .category:hover, .category.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .movies-grid, .genre-grid, .genre-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }
        
        .movie-card, .genre-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            cursor: pointer;
        }

        /* Performance mode: reduce heavy shadows on cards */
        body.perf-mode .movie-card, body.perf-mode .genre-card {
            box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        }
        
        .movie-card:hover, .genre-card:hover {
            transform: translateY(-12px) scale(1.03);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 20px rgba(168, 85, 247, 0.3);
        }

        body.perf-mode .movie-card:hover, body.perf-mode .genre-card:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3) !important;
        }
        
        .movie-poster {
            width: 100%;
            height: 300px;
            object-fit: cover;
            display: block;
        }
        
        .movie-info, .genre-info {
            padding: 1rem;
        }
        
        .movie-title, .genre-title {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .movie-year {
            color: var(--tertiary);
            font-size: 0.9rem;
        }

        /* ===== DOWNLOADER STYLES ===== */
        .downloader-search { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .downloader-search input { flex: 1; padding: 0.8rem 1rem; border-radius: 10px; border: none; background-color: rgba(255, 255, 255, 0.08); color: var(--light); }
        .downloader-search button { padding: 0.7rem 1rem; border-radius: 10px; border: none; background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: #fff; cursor: pointer; }
    .downloader-results { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; }
    .downloader-results.single {
        display: flex;
        justify-content: center;
        align-items: flex-start; /* don't stretch heights */
        gap: 1rem;
    }
    .downloader-results.single .downloader-item {
        flex: 0 0 260px; /* fixed column width for poster card */
        max-width: 260px;
        align-self: flex-start;
        position: sticky; /* keep the highlighted card visible */
        top: 12px;
    }
    .downloader-results.single .downloader-files-card {
        flex: 1 1 auto; /* fill remaining space */
        min-width: 360px;
    }
        .downloader-item { display: flex; flex-direction: column; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; overflow: hidden; transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); cursor: pointer; outline: none; }
        .downloader-item:hover { transform: translateY(-4px) scale(1.02); border-color: rgba(168,85,247,0.5); box-shadow: 0 12px 32px rgba(168,85,247,0.25); }
        .downloader-item.selected { border-color: #a855f7; box-shadow: 0 0 0 2px rgba(168,85,247,0.35) inset, 0 10px 24px rgba(168,85,247,0.25); }
        .downloader-thumb { width: 100%; height: 240px; object-fit: cover; background: #1f2937; }
        .downloader-meta { padding: 0.75rem; display: flex; flex-direction: column; gap: 0.3rem; }
        .downloader-title { color: #fff; font-weight: 600; }
        .downloader-year { color: #9ca3af; font-size: 0.9rem; }
        .downloader-empty { color: #9ca3af; text-align: center; padding: 2rem 1rem; }
        .downloader-type-toggle { display:flex; align-items:center; gap:0.5rem; margin-left:auto; }
        .downloader-type-toggle .filter-btn { padding: 0.55rem 0.9rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); color:#fff; font-weight:600; cursor:pointer; }

        /* Ace Bet Nav Button Styles */
        .acebet-nav-item { animation: acebet-glow 2s ease-in-out infinite; }
        .acebet-nav-item:hover { background: linear-gradient(135deg, rgba(16, 185, 129, 0.25), rgba(5, 150, 105, 0.2)) !important; border-color: rgba(16, 185, 129, 0.5) !important; }
        @keyframes acebet-glow { 0%, 100% { box-shadow: 0 0 8px rgba(16, 185, 129, 0.3); } 50% { box-shadow: 0 0 16px rgba(16, 185, 129, 0.5); } }
        .acebet-nav-particles { position: absolute; inset: 0; pointer-events: none; overflow: hidden; }
        .acebet-particle-nav { position: absolute; width: 3px; height: 3px; background: #10b981; border-radius: 50%; animation: acebet-float-nav 2s ease-in-out infinite; box-shadow: 0 0 4px #10b981; }
        .acebet-particle-nav:nth-child(1) { top: 20%; left: 10%; animation-delay: 0s; }
        .acebet-particle-nav:nth-child(2) { top: 60%; right: 15%; animation-delay: 0.7s; }
        .acebet-particle-nav:nth-child(3) { bottom: 20%; left: 50%; animation-delay: 1.4s; }
        @keyframes acebet-float-nav { 0%, 100% { transform: translateY(0) scale(1); opacity: 0.6; } 50% { transform: translateY(-6px) scale(1.3); opacity: 1; } }

        /* Live TV Styles */
        .livetv-category-section {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 0;
        }
        .livetv-category-label {
            font-weight: 600;
            color: #10b981;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .livetv-category-dropdown {
            padding: 0.75rem 1.25rem;
            border-radius: 12px;
            border: 2px solid rgba(16, 185, 129, 0.3);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.12), rgba(5, 150, 105, 0.08));
            color: #fff;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), border-color 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            outline: none;
            min-width: 200px;
        }
        .livetv-category-dropdown:hover {
            border-color: rgba(16, 185, 129, 0.5);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.18), rgba(5, 150, 105, 0.12));
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }
        .livetv-category-dropdown:focus {
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
        }
        .livetv-category-dropdown option {
            background: #1a1a2e;
            color: #fff;
            padding: 0.75rem;
            font-weight: 600;
        }
        .livetv-matches-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 1.25rem;
            padding: 0.5rem 0;
        }
        .livetv-match-card {
            background: linear-gradient(135deg, rgba(17, 24, 39, 0.8), rgba(31, 41, 55, 0.6));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
            position: relative;
        }
        .livetv-match-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            opacity: 0;
            transition: opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .livetv-match-card:hover {
            transform: translateY(-6px) scale(1.02);
            border-color: rgba(16, 185, 129, 0.4);
            box-shadow: 0 12px 32px rgba(16, 185, 129, 0.2), 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .livetv-match-card:hover::before {
            opacity: 1;
        }
        .livetv-poster {
            width: 100%;
            height: 150px;
            object-fit: cover;
            background: linear-gradient(135deg, #1f2937, #111827);
        }
        .livetv-poster-placeholder {
            width: 100%;
            height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1f2937, #111827);
            color: rgba(255, 255, 255, 0.2);
            font-size: 2.5em;
        }
        .livetv-match-info {
            padding: 1.25rem;
        }
        .livetv-match-title {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 0.625rem;
            color: #f9fafb;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.4;
            letter-spacing: 0.01em;
        }
        .livetv-match-category {
            display: inline-block;
            padding: 0.3rem 0.7rem;
            background: rgba(16, 185, 129, 0.12);
            border: 1px solid rgba(16, 185, 129, 0.25);
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            color: #34d399;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }
        .livetv-watch-btn {
            width: 100%;
            margin-top: 0.875rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, #10b981, #059669);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }
        .livetv-watch-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5);
            transform: translateY(-4px) scale(1.02);
        }
        .livetv-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: rgba(255, 255, 255, 0.4);
        }
        .livetv-empty p {
            margin-top: 1rem;
            font-size: 1.1rem;
        }
        
        /* Streams List Modal */
        .livetv-streams-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        .livetv-streams-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid rgba(16, 185, 129, 0.3);
            border-radius: 20px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(16, 185, 129, 0.3);
        }
        .livetv-streams-header {
            padding: 1.5rem;
            background: rgba(16, 185, 129, 0.1);
            border-bottom: 2px solid rgba(16, 185, 129, 0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .livetv-streams-header h3 {
            font-size: 1.3rem;
            color: #10b981;
            font-weight: 700;
        }
        .livetv-close-btn {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.4);
            border-radius: 8px;
            color: #ff4757;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .livetv-close-btn:hover {
            background: rgba(220, 53, 69, 0.3);
            transform: scale(1.12);
        }
        .livetv-streams-list {
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .livetv-stream-item {
            padding: 1rem 1.25rem;
            background: rgba(16, 185, 129, 0.08);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 12px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        .livetv-stream-item:hover {
            background: rgba(16, 185, 129, 0.15);
            border-color: #10b981;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }
        .livetv-stream-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Disable hover animation on Live TV page trakt-card container */
        #livetv-page .trakt-card {
            transition: none !important;
        }
        #livetv-page .trakt-card:hover {
            transform: none !important;
            box-shadow: none !important;
            border-color: rgba(255,255,255,0.15) !important;
        }

        .livetv-stream-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        .livetv-play-stream-btn, .livetv-copy-link-btn, .livetv-open-browser-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 10px;
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            white-space: nowrap;
        }
        .livetv-play-stream-btn {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        .livetv-play-stream-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            transform: scale(1.08);
        }
        .livetv-copy-link-btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }
        .livetv-copy-link-btn:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transform: scale(1.08);
        }
        .livetv-open-browser-btn {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
        }
        .livetv-open-browser-btn:hover {
            background: linear-gradient(135deg, #4f46e5, #4338ca);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
            transform: scale(1.08);
        }
        .livetv-play-stream-btn:active, .livetv-copy-link-btn:active, .livetv-open-browser-btn:active {
            transform: scale(0.98);
        }
        .livetv-stream-source {
            font-weight: 700;
            color: #10b981;
            font-size: 1.1rem;
        }
        .livetv-stream-details {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            font-size: 0.9rem;
        }
        .livetv-stream-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .livetv-stream-badge.hd {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #fff;
        }
        .livetv-stream-badge.quality {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.4);
            color: #10b981;
        }
        .livetv-stream-badge.language {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            color: #3b82f6;
        }
        .livetv-stream-badge.viewers {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.4);
            color: #a855f7;
        }
        .livetv-stream-badge.ads {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #ef4444;
        }
        .livetv-stream-badge.nsfw {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.4);
            color: #a855f7;
        }
        .livetv-loading {
            text-align: center;
            padding: 2rem;
            color: rgba(255, 255, 255, 0.6);
        }
        .livetv-loading i {
            font-size: 2em;
            animation: spin 1.2s cubic-bezier(0.65, 0, 0.35, 1) infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.98); }
        }
        @keyframes blink {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(0.96); }
        }
        .downloader-type-toggle .filter-btn.active { background: linear-gradient(135deg, #8b5cf6, #6d28d9); border-color: transparent; }
        
        .movie-rating {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--tertiary);
            color: #1f1140;
            padding: 0.3rem 0.6rem;
            border-radius: 30px;
            font-weight: 700;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .add-to-list-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--light);
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            opacity: 0;
            transform: scale(0.8);
        }
        
        .movie-card:hover .add-to-list-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .add-to-list-btn:hover {
            background-color: var(--success);
            transform: scale(1.12);
        }
        
        .add-to-list-btn.in-list {
            background-color: var(--success);
            opacity: 1;
            transform: scale(1);
        }
        
        .add-to-list-btn.in-list i:before {
            content: "\f00c"; /* checkmark */
        }
        
        .movie-card .done-watching-btn {
            position: absolute;
            top: 10px;
            left: 55px; /* Position next to the add-to-list button */
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--light);
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            opacity: 0;
            transform: scale(0.8);
        }
        
        .movie-card:hover .done-watching-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .movie-card .done-watching-btn:hover {
            background-color: #17a2b8; /* info blue color */
            transform: scale(1.12);
        }
        
        .movie-card .done-watching-btn.is-done {
            background-color: #17a2b8;
            opacity: 1;
            transform: scale(1);
        }
        
        .movie-card .done-watching-btn.is-done i:before {
            content: "\f058"; /* check-circle */
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            font-size: 1.2rem;
            color: var(--gray);
        }
        
        .loading i {
            animation: spin 1.4s cubic-bezier(0.65, 0, 0.35, 1) infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes slideInRight {
            0% { 
                transform: translateX(100%) scale(0.9);
                opacity: 0;
            }
            60% {
                transform: translateX(-5%) scale(1.02);
                opacity: 0.9;
            }
            100% { 
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Modal dropdowns (sort/filter) */
        .modal-select {
            background: rgba(255,255,255,0.08);
            color: var(--light);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 0.35rem 0.6rem;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        .modal-select:focus {
            outline: none;
            border-color: rgba(168,85,247,0.45);
            box-shadow: 0 0 0 3px rgba(168,85,247,0.15);
        }
        .modal-select option {
            background: #1f1140;
            color: #fff;
            font-weight: 600;
        }

        /* Episode details overlay used in showEpisodeDetails() */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }

        /* Ensure resume modal is above all other overlays */
        #resumeModal { z-index: 6000; }
        
        .modal-content {
            background-color: var(--card-bg);
            border-radius: 10px;
            overflow: hidden;
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-header {
            position: relative;
            height: 400px;
            overflow: hidden;
        }
        
        .modal-backdrop {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: brightness(0.4);
        }
        
        .modal-header-content {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            display: flex;
            gap: 2rem;
        }
        
        .modal-poster {
            width: 200px;
            height: 300px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }
        
        .modal-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        
        .modal-info {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        
        .modal-rating {
            background-color: var(--tertiary);
            color: #1f1140;
            padding: 0.3rem 0.8rem;
            border-radius: 30px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .modal-year {
            font-size: 1.2rem;
            color: var(--gray);
        }
        
        .modal-tagline {
            font-style: italic;
            margin-bottom: 1rem;
            color: var(--tertiary);
        }
        
        .modal-body {
            padding: 2rem;
            background: var(--card-bg);
        }
        
        .modal-section-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Anime dropdown and button styles */
        #animeSeasonSelector:hover,
        #animeEpisodeSelector:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.25), rgba(37, 99, 235, 0.25));
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        #animeSeasonSelector:focus,
        #animeEpisodeSelector:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        #animeSeasonSelector option,
        #animeEpisodeSelector option {
            background: #1a1a2e;
            color: var(--light);
            padding: 0.5rem;
            font-weight: 500;
        }
        
        #animeCustomSearchBtn:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        #animeCustomSearchBtn:active {
            transform: translateY(0);
        }
        
        #animeCustomSearchInput:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        .modal-overview {
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .cast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .cast-card {
            cursor: pointer;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .cast-card:hover {
            transform: translateY(-5px);
        }
        
        .cast-img {
            width: 100%;
            height: 160px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 0.5rem;
        }
        
        .cast-name {
            font-weight: 600;
            margin-bottom: 0.2rem;
            font-size: 0.9rem;
        }
        
        .cast-character {
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .similar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .seasons-container {
            margin-bottom: 2rem;
        }
        
        .season-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .season-btn {
            padding: 0.5rem 1rem;
            background-color: var(--input-bg);
            border: none;
            border-radius: 30px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .season-btn.active {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .episodes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .episode-card {
            background-color: var(--input-bg);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid transparent;
        }

        .episode-card:hover {
            border-color: var(--secondary);
        }

        .episode-card.selected {
            border-color: var(--vlc-orange);
            background-color: rgba(255, 105, 0, 0.1);
        }

        .episode-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            justify-content: flex-end;
        }

        .episode-done-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .episode-done-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .episode-done-btn.is-done {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-color: #22c55e;
            color: white;
        }

        .episode-done-btn.is-done:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
        }

        .episode-badge {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            z-index: 5;
        }

        .episode-subtitle {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin: 0.25rem 0;
            font-style: italic;
        }

        .episode-details-btn {
            position: absolute;
            bottom: 12px;
            right: 12px;
            transform: none;
            width: auto;
            height: 36px;
            padding: 0 14px;
            border: none;
            border-radius: 18px;
            background: linear-gradient(135deg, var(--secondary) 0%, var(--vlc-orange) 100%);
            color: white;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.2px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            z-index: 4;
            box-shadow: 0 6px 14px rgba(0,0,0,0.35);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255,255,255,0.15);
        }

        .episode-details-btn:hover {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, var(--secondary) 100%);
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.45);
        }

        .episode-modal {
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .episode-modal .modal-header {
            display: flex;
            align-items: center;
            padding: 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
        }

        .episode-modal .show-poster {
            width: 60px;
            height: 90px;
            border-radius: 8px;
            object-fit: cover;
            margin-right: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .episode-modal .header-content {
            flex: 1;
        }

        .episode-modal .modal-header h2 {
            margin: 0 0 8px 0;
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        .episode-modal .modal-subtitle {
            margin: 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
        }

        .episode-modal .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .episode-modal .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.12);
        }

        .episode-modal .modal-body {
            padding: 0;
            max-height: calc(85vh - 140px);
            overflow-y: auto;
        }

        .episode-list {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .episode-item {
            display: flex;
            align-items: center;
            padding: 16px 24px;
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
        }

        .episode-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .episode-item:last-child {
            border-bottom: none;
        }

        /* Highlight selected episode in the modal */
        .episode-item.selected {
            background: rgba(255, 105, 0, 0.10);
            border-left: 3px solid var(--vlc-orange);
        }

        /* Stronger highlight inside episode modal to ensure visibility on gradients */
        .episode-modal .episode-item.selected {
            background: rgba(255, 105, 0, 0.14);
            border-left: 4px solid var(--vlc-orange);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06), 0 4px 14px rgba(255,105,0,0.25);
        }

        .episode-number {
            flex-shrink: 0;
            width: 70px;
            height: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            margin-right: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .episode-info {
            flex: 1;
        }

        .episode-info h4 {
            margin: 0 0 6px 0;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            line-height: 1.3;
        }

        .episode-info p {
            margin: 0;
            color: #8a92b2;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .episode-info p i {
            color: #667eea;
        }

        .episode-remove-btn {
            flex-shrink: 0;
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: rgba(244, 67, 54, 0.8);
            color: white;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
        }

        .episode-remove-btn:hover {
            background: #f44336;
            transform: scale(1.12);
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.5);
        }
        
        .episode-img {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }
        
        .episode-info {
            padding: 0.8rem;
        }
        
        .episode-title {
            font-weight: 600;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
        }
        
        .episode-date {
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .torrents-container {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .torrents-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .torrents-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .torrent-item {
            background-color: var(--input-bg);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        
        .torrent-info {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .torrent-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        
        .torrent-details {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--gray);
            flex-wrap: wrap;
        }
        
        .torrent-quality {
            background-color: var(--tertiary);
            color: var(--dark);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        
        .cached-badge {
            background: linear-gradient(135deg, #198754 0%, #20c997 100%);
            color: #fff;
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            box-shadow: 0 2px 8px rgba(25, 135, 84, 0.3);
            animation: pulse-glow 3.5s cubic-bezier(0.45, 0, 0.55, 1) infinite;
        }
        
        .cached-badge::before {
            content: '';
            font-size: 0.9rem;
        }
        
        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 2px 8px rgba(25, 135, 84, 0.3);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 4px 16px rgba(25, 135, 84, 0.7);
                transform: scale(1.02);
            }
        }
        
        .torrent-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .torrent-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }

        .torrent-pagination button {
            background: none;
            border: none;
            color: var(--light);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .torrent-pagination button:disabled {
            color: var(--gray);
            cursor: not-allowed;
        }

        /* Chromecast Device Selection Styles */
        .chromecast-modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 2px solid rgba(139, 92, 246, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chromecast-modal-header h3 {
            font-size: 1.5rem;
            color: var(--light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0;
        }

        .chromecast-modal-header i {
            color: var(--tertiary);
        }

        .chromecast-device-list {
            min-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .chromecast-device-item {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(168, 85, 247, 0.05));
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 1.25rem;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .chromecast-device-item:hover {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(168, 85, 247, 0.1));
            border-color: var(--tertiary);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .chromecast-device-icon {
            font-size: 2rem;
            color: var(--tertiary);
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 50%;
        }

        .chromecast-device-info {
            flex: 1;
        }

        .chromecast-device-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--light);
            margin-bottom: 0.25rem;
        }

        .chromecast-device-host {
            font-size: 0.9rem;
            color: var(--gray);
        }

        .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 3rem;
            color: var(--gray);
        }

        .loading-spinner i {
            font-size: 2.5rem;
            color: var(--tertiary);
        }

        .chromecast-no-devices {
            text-align: center;
            padding: 3rem;
            color: var(--gray);
        }

        .chromecast-no-devices i {
            font-size: 3rem;
            color: var(--gray);
            margin-bottom: 1rem;
        }

        .chromecast-no-devices h4 {
            margin-bottom: 0.5rem;
            color: var(--light);
        }

        .chromecast-refresh-btn {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--secondary), var(--tertiary));
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .chromecast-refresh-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }


        .torrent-pagination span {
            margin: 0 1rem;
        }
        
        .provider-buttons {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: nowrap; /* keep on one line */
            overflow-x: auto; /* horizontal scroll */
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x proximity;
            padding-bottom: 0.25rem;
        }
        
        .provider-btn {
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            white-space: nowrap;
            flex: 0 0 auto; /* don't shrink */
            scroll-snap-align: start;
            min-width: 120px;
        }
        
        .provider-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .provider-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .provider-btn.active:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        /* Pretty pill/ghost button helpers */
        .btn-pill { border-radius: 999px; padding: 0.6rem 1rem; font-weight: 700; letter-spacing: .2px; }
        .btn-ghost { background: transparent; border: 2px solid rgba(255,255,255,0.15); color: var(--light); }
        .btn-ghost:hover { border-color: rgba(255,255,255,0.35); background: rgba(255,255,255,0.06); }
        .btn-accent { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: #fff; box-shadow: 0 8px 22px rgba(102,126,234,.35); }
        .btn-accent:hover { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(102,126,234,.45); }
        
        .torrent-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-play {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .btn-copy {
            background-color: var(--secondary);
            color: white;
        }

        .btn-play-now {
            background-color: var(--success);
            color: white;
        }

        /* API Key Setup Modal */
        .api-setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .api-setup-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .api-setup-content {
            background: var(--modal-bg);
            border-radius: 15px;
            padding: 3rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--vlc-orange);
        }
        
        .api-setup-title {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .api-setup-description {
            color: var(--light);
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .api-input-group {
            margin-bottom: 2rem;
        }
        
        .api-input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--tertiary);
            font-weight: 600;
        }
        
        .api-input {
            width: 100%;
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background-color: var(--input-bg);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .api-input:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background-color: var(--hover-bg);
        }
        
        #torrentSourceSelect {
            appearance: none;
            background-image: linear-gradient(45deg, transparent 50%, var(--primary) 50%),
                              linear-gradient(135deg, var(--primary) 50%, transparent 50%);
            background-position: calc(100% - 20px) calc(50% - 2px),
                                 calc(100% - 15px) calc(50% - 2px);
            background-size: 5px 5px, 5px 5px;
            background-repeat: no-repeat;
        }
        
        #torrentSourceSelect:hover {
            background-color: rgba(255,255,255,0.12);
            border-color: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }
        
        #torrentSourceSelect:focus {
            outline: none;
            border-color: var(--primary);
            background-color: rgba(255,255,255,0.12);
            box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.2);
        }
        
        #torrentSourceSelect option {
            background: #1a1a1a;
            color: #fff;
            padding: 0.75rem;
            font-weight: 500;
        }
        
        /* Torrent Engine Select Styles */
        #torrentEngineSelect {
            transition: all 0.3s ease;
        }
        
        #torrentEngineSelect:hover {
            border-color: #06b6d4;
            box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.15);
        }
        
        #torrentEngineSelect:focus {
            outline: none;
            border-color: #06b6d4;
            box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.25);
        }
        
        #torrentEngineSelect option {
            background: #1a1a2e;
            color: #fff;
            padding: 1rem;
            font-weight: 500;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        #torrentEngineSelect option:hover,
        #torrentEngineSelect option:focus {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: #fff;
        }
        
        #torrentEngineSelect option:checked {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: #fff;
        }
        
        /* Theme selector styles */
        #themeSelector {
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #themeSelector:hover {
            background: rgba(255,255,255,0.12);
            border-color: var(--vlc-orange);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        #themeSelector:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background: rgba(255,255,255,0.12);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.3);
        }
        
        #themeSelector option {
            background: var(--primary);
            color: var(--light);
            padding: 1rem;
            font-weight: 500;
            font-size: 1rem;
        }
        
        #themeSelector option:hover {
            background: var(--secondary);
        }
                .torrent-source-btn {
            position: relative;
            overflow: hidden;
        }

        .torrent-source-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .torrent-source-btn.active {
            background: rgba(76, 175, 80, 0.2) !important;
            border-color: #4CAF50 !important;
            color: #4CAF50 !important;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        .torrent-source-btn:not(.active):hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
        }
        
        .api-setup-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .api-btn {
            padding: 1rem 2rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }
        
        .api-btn-primary {
            background-color: var(--vlc-orange);
            color: white;
        }
        
        .api-btn-primary:hover {
            background-color: #e55a00;
            transform: translateY(-4px) scale(1.02);
        }

        /* Debrid provider select styling */
        #debridProvider {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            min-width: 240px;
            max-width: 320px;
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 10px;
            padding: 0.55rem 2.25rem 0.55rem 0.85rem;
            color: #e9ecef;
            font-weight: 600;
            letter-spacing: 0.2px;
            cursor: pointer;
            transition: border-color 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), background 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 20 20' fill='none'%3E%3Cpath d='M5 7l5 6 5-6' stroke='%23cfd4da' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.6rem center;
            background-size: 12px;
        }
        #debridProvider:hover {
            border-color: rgba(255,255,255,0.28);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.05));
        }
        #debridProvider:focus {
            outline: none;
            border-color: var(--vlc-orange);
            box-shadow: 0 0 0 2px rgba(255,117,24,0.25);
        }
        /* Attempt to style dropdown menu items (supported in Chromium) */
        #debridProvider option {
            background-color: #151a20;
            color: #e9ecef;
        }
        
        .api-btn-secondary {
            background-color: transparent;
            color: var(--gray);
            border: 2px solid var(--gray);
        }
        
        .api-btn-secondary:hover {
            color: var(--light);
            border-color: var(--light);
        }

        /* Donate modal removed */

        /* Discord Modal */
        .discord-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 6000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .discord-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .discord-content {
            background: linear-gradient(135deg, #5865F2, #4752C4);
            border-radius: 20px;
            padding: 3rem;
            max-width: 520px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(88, 101, 242, 0.4);
            border: 2px solid #7289DA;
            position: relative;
            animation: modalSlideIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes modalSlideIn {
            0% {
                transform: scale(0.85) translateY(-30px);
                opacity: 0;
            }
            50% {
                transform: scale(1.02) translateY(5px);
                opacity: 0.8;
            }
            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        .discord-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border: none;
            color: #fff;
            font-size: 1.5rem;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .discord-close:hover {
            background-color: #ED4245;
            transform: rotate(90deg);
        }
        
        .discord-title {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            font-weight: 700;
        }
        
        .discord-logo {
            width: 48px;
            height: 48px;
        }
        
        .discord-message {
            color: #fff;
            margin-bottom: 2rem;
            line-height: 1.8;
            font-size: 1.05rem;
        }
        
        .discord-join-btn {
            padding: 1rem 2.5rem;
            border-radius: 30px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            background: #fff;
            color: #5865F2;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .discord-join-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 4000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .settings-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .settings-content {
            background: var(--modal-bg);
            border-radius: 15px;
            padding: 2rem;
            max-width: 800px;
            width: min(92%, 800px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--vlc-orange);
            max-height: 85vh;
            overflow: auto;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }
        
        .settings-title {
            font-size: 1.8rem;
            color: var(--vlc-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .settings-close {
            background: transparent;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            padding: 0.5rem;
        }
        
        .settings-close:hover {
            color: var(--light);
        }
        
        .settings-section {
            margin-bottom: 2rem;
        }
        
        .settings-section h3 {
            color: var(--tertiary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        .source-badge { display:inline-block; padding:2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight:700; margin-left: 8px; background: #6c757d; color: #fff; }
        .source-badge.debrid { background:#198754; }
        .source-badge.webtorrent { background:#0d6efd; }
        .source-badge.direct-stream { background:#dc3545; }
        
        .current-api-key {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            color: var(--gray);
            font-family: monospace;
        }
        
        .settings-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* Floating Navigation Arrow (Old UI Only, Home Page Only) */
        .floating-nav-container {
            position: fixed;
            right: 30px;
            bottom: 30px;
            z-index: 1000;
            display: none;
        }

        .floating-nav-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--vlc-orange) 0%, var(--secondary) 100%);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.4rem;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(168, 85, 247, 0.3);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .floating-nav-btn:hover {
            transform: translateY(-4px) scale(1.02) scale(1.05);
            box-shadow: 0 12px 30px rgba(168, 85, 247, 0.4);
            background: linear-gradient(135deg, var(--tertiary) 0%, var(--vlc-orange) 100%);
        }

        .floating-nav-btn:active {
            transform: translateY(0) scale(0.95);
        }

        .floating-nav-menu {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(42, 24, 71, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 0.5rem 0;
            min-width: 160px;
            /* Make the menu usable on small screens */
            max-height: calc(100vh - 140px); /* leave room for FAB and margins */
            overflow-y: auto;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .floating-nav-container.active .floating-nav-menu {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: all;
        }

        .floating-nav-container.active .floating-nav-btn {
            background: linear-gradient(135deg, #6d28d9, #553c9a);
        }

        .floating-nav-container.active #floatingNavIcon {
            transform: rotate(180deg);
        }

        .floating-nav-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            color: #fff;
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .floating-nav-item:last-child {
            border-bottom: none;
        }

        .floating-nav-item:hover {
            background: rgba(139, 92, 246, 0.2);
            color: #c084fc;
        }

        .floating-nav-item i {
            width: 16px;
            text-align: center;
            opacity: 0.8;
        }

        .floating-nav-item span {
            font-weight: 500;
            font-size: 0.9rem;
        }

        /* Show floating nav only in old UI on home page */
        body:not(.ui-new) .floating-nav-container.show-on-home {
            display: block;
        }

        /* Hide in new UI */
        body.ui-new .floating-nav-container {
            display: none !important;
        }

        /* Books Page Styles */
        .books-search-section {
            margin-bottom: 2rem;
        }

        .books-search-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .books-search-bar {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 16px;
            padding: 0.5rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
        }

        .books-search-bar:focus-within {
            border-color: rgba(245, 158, 11, 0.5);
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.15);
        }

        .books-search-icon {
            position: absolute;
            left: 1.25rem;
            color: #9ca3af;
            font-size: 1.1rem;
        }

        #books-search-input, #music-search-input {
            flex: 1;
            padding: 1rem 1.5rem;
            padding-left: 3rem;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1.1rem;
            outline: none;
        }

        #books-search-input::placeholder, #music-search-input::placeholder {
            color: #9ca3af;
        }

        .books-search-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .books-search-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
        }

        .books-loading {
            text-align: center;
            padding: 4rem 2rem;
            color: #9ca3af;
        }

        .books-loading-spinner {
            font-size: 3rem;
            margin-bottom: 1.5rem;
            color: #f59e0b;
        }

        .books-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: #9ca3af;
        }

        .books-empty-icon {
            font-size: 4rem;
            margin-bottom: 2rem;
            color: #f59e0b;
        }

        .books-empty h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #fff;
        }

        .books-results {
            animation: fadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .books-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .books-results-header h3 {
            font-size: 1.5rem;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .books-results-count {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #fff;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .books-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.25rem;
        }

        /* Music (compact) overrides using books classes */
        #music-page .books-results-grid {
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
        }
        #music-page .books-book-card {
            cursor: default;
        }
        .music-card {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .music-card:hover {
            transform: translateY(-4px);
            border-color: rgba(236, 72, 153, 0.45);
            box-shadow: 0 10px 30px rgba(236, 72, 153, 0.15);
        }
        .music-cover {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: linear-gradient(135deg, #374151, #1f2937);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .music-cover img { width: 100%; height: 100%; object-fit: cover; }
        .music-info { padding: 0.75rem 0.85rem; }
        .music-title { font-size: 0.95rem; font-weight: 700; color: #fff; margin: 0 0 0.25rem 0; line-height: 1.25; }
        .music-artist { font-size: 0.85rem; color: #ec4899; margin: 0 0 0.5rem 0; }
        .music-actions { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; }
        .music-play-btn {
            flex: 1;
            display: inline-flex; align-items: center; justify-content: center; gap: 0.4rem;
            padding: 0.5rem 0.75rem;
            background: linear-gradient(135deg, #ec4899, #a855f7);
            border: none; border-radius: 10px; color: #fff; font-weight: 700; cursor: pointer;
        }
        .music-open-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(236,72,153,0.35); background: rgba(236,72,153,0.12); color: #ec4899; cursor: pointer;
        }
        .music-heart-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(236,72,153,0.35); background: rgba(236,72,153,0.12); color: #ec4899; cursor: pointer;
        }
        .music-heart-btn.added {
            border-color: rgba(244,114,182,0.6);
            background: rgba(244,114,182,0.2);
            color: #f472b6;
        }
        .music-plus-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(56,189,248,0.35); background: rgba(56,189,248,0.12); color: #38bdf8; cursor: pointer;
        }
        .music-download-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(34,197,94,0.35); background: rgba(34,197,94,0.12); color: #22c55e; cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .music-download-btn.downloaded {
            border-color: rgba(34,197,94,0.6);
            background: rgba(34,197,94,0.25);
            color: #22c55e;
        }
        .music-download-btn:hover {
            filter: brightness(1.15);
            transform: scale(1.08);
        }
        .music-folder-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(251,191,36,0.35); background: rgba(251,191,36,0.12); color: #fbbf24; cursor: pointer;
        }
        .music-delete-downloaded-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(239,68,68,0.35); background: rgba(239,68,68,0.12); color: #ef4444; cursor: pointer;
        }
        .music-play-btn:hover, .music-open-btn:hover, .music-heart-btn:hover, .music-plus-btn:hover, .music-folder-btn:hover, .music-delete-downloaded-btn:hover {
            filter: brightness(1.08);
        }
        /* Playlist open view header tweak */
        #music-page.playlist-open .books-results-header h3 i { display: none; }
        #music-page.playlist-open .books-results-header h3 { gap: 0; }

        /* Playlists list view buttons */
        .playlist-open-btn {
            display: inline-flex; align-items: center; gap: 0.35rem;
            padding: 0.35rem 0.6rem; border-radius: 8px; border: none;
            background: linear-gradient(135deg, #a855f7, #ec4899); color: #fff; cursor: pointer;
            font-weight: 600; font-size: 0.8rem;
        }
        .playlist-export-btn {
            display: inline-flex; align-items: center; gap: 0.35rem;
            padding: 0.35rem 0.6rem; border-radius: 8px; border: 1px solid rgba(56,189,248,0.35);
            background: rgba(56,189,248,0.12); color: #38bdf8; cursor: pointer;
            font-weight: 600; font-size: 0.8rem;
        }
        .playlist-delete-btn {
            width: 32px; height: 32px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 8px; border: 1px solid rgba(239,68,68,0.45); background: rgba(239,68,68,0.12); color: #ef4444; cursor: pointer;
            font-size: 0.85rem;
        }
        .playlist-open-btn:hover, .playlist-export-btn:hover, .playlist-delete-btn:hover { filter: brightness(1.08); }

        /* Close playlist header button */
        .playlist-close-btn {
            display: inline-flex; align-items: center; gap: 0.45rem;
            padding: 0.5rem 0.8rem; border-radius: 10px; border: 1px solid rgba(148,163,184,0.35);
            background: rgba(148,163,184,0.12); color: #e2e8f0; cursor: pointer;
            font-weight: 700; margin-left: auto;
        }
        .playlist-close-btn:hover { filter: brightness(1.08); }
        .music-add-btn {
            width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center;
            border-radius: 10px; border: 1px solid rgba(16,185,129,0.35); background: rgba(16,185,129,0.12); color: #10b981; cursor: pointer;
        }
        .music-add-btn.added {
            border-color: rgba(34,197,94,0.6);
            background: rgba(34,197,94,0.18);
            color: #22c55e;
        }

        /* Albums UI */
        .album-card {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(59,130,246,0.18);
            border-radius: 14px;
            overflow: hidden;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .album-card:hover { transform: translateY(-3px); border-color: rgba(59,130,246,0.35); box-shadow: 0 14px 34px rgba(2,6,23,0.45); }
        .album-cover { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; background:#111827; display:block; }
        .album-body { padding: 0.75rem; display:flex; flex-direction:column; gap:0.4rem; }
        .album-title { font-weight: 800; color:#e5e7eb; line-height:1.2; }
        .album-artist { color:#9ca3af; font-size:0.9rem; }
        .album-meta { color:#94a3b8; font-size:0.82rem; display:flex; gap:0.5rem; align-items:center; }
        .album-open-btn { display:inline-flex; align-items:center; gap:0.4rem; padding:0.45rem 0.75rem; border:none; border-radius:10px; background: linear-gradient(135deg,#38bdf8,#0ea5e9); color:#05222e; font-weight:800; cursor:pointer; }
        .album-open-btn:hover { filter: brightness(1.05); }

        .album-tracks-list .track-row {
            display:grid; grid-template-columns: 32px 1fr 90px 210px; gap:0.75rem; align-items:center;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(59,130,246,0.14);
            border-radius: 12px; padding: 0.5rem 0.6rem;
            transition: background 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .track-row:hover { background: rgba(255,255,255,0.07); border-color: rgba(59,130,246,0.25); }
        .track-index { color:#94a3b8; font-weight:700; text-align:center; }
        .track-title { color:#e5e7eb; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .track-duration { color:#94a3b8; text-align:right; font-variant-numeric: tabular-nums; }
        .track-actions { display:flex; justify-content:flex-end; gap:0.4rem; flex-wrap:wrap; }
        .track-play-btn, .track-plus-btn, .track-heart-btn, .track-download-btn {
            display:inline-flex; align-items:center; gap:0.35rem; border-radius: 10px; cursor:pointer;
            padding: 0.4rem 0.65rem; font-size: 0.8rem; font-weight: 800; border: 1px solid rgba(148,163,184,0.25);
            background: linear-gradient(135deg, rgba(51,65,85,0.8), rgba(15,23,42,0.6)); color:#e5e7eb;
            transition: transform 0.45s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .track-play-btn:hover, .track-plus-btn:hover, .track-heart-btn:hover, .track-download-btn:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(2,6,23,0.35); border-color: rgba(148,163,184,0.4); }
        .track-play-btn { background: linear-gradient(135deg, #34d399, #10b981); color:#052e2b; border:none; }
        .track-plus-btn { background: linear-gradient(135deg, #c4b5fd, #a78bfa); color:#1e1b4b; border:none; }
        .track-heart-btn { background: linear-gradient(135deg, #fda4af, #fb7185); color:#4c0519; border:none; }
        .track-download-btn { background: linear-gradient(135deg, #38bdf8, #0ea5e9); color:#082f49; border:none; }
        .track-download-btn.downloaded { background: linear-gradient(135deg, #10b981, #059669); color:#052e2b; cursor: default; opacity: 0.7; }
        .track-download-btn.downloaded:hover { transform: none; box-shadow: none; }
        .album-empty { color:#94a3b8; text-align:center; padding:1rem 0; }

        /* My Albums heart button */
        .album-heart-btn {
            width: 38px; height: 38px; display:inline-flex; align-items:center; justify-content:center;
            border-radius: 10px; border: 1px solid rgba(236,72,153,0.35); background: rgba(236,72,153,0.12); color:#ec4899; cursor:pointer;
            transition: filter 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .album-heart-btn.added {
            border-color: rgba(236,72,153,0.6); background: rgba(236,72,153,0.2); color:#f472b6;
        }
        .album-heart-btn:hover { filter: brightness(1.08); }

        .books-book-card {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }

        .books-book-card:hover {
            transform: translateY(-5px);
            border-color: rgba(245, 158, 11, 0.4);
            box-shadow: 0 10px 40px rgba(245, 158, 11, 0.15);
        }

        .books-book-cover {
            position: relative;
            width: 100%;
            aspect-ratio: 2/3;
            min-height: 240px;
            overflow: hidden;
            background: linear-gradient(135deg, #374151, #1f2937);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .books-book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .books-book-card:hover .books-book-cover img {
            transform: scale(1.08);
        }

        .books-book-cover-placeholder {
            font-size: 3rem;
            color: #9ca3af;
        }

        .books-book-format {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #fff;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .books-book-info {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .books-book-title {
            font-size: 0.95rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 0.4rem;
            line-height: 1.3;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .books-book-author {
            color: #9ca3af;
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
            display: -webkit-box;
            line-clamp: 1;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .books-book-year {
            display: inline-block;
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .books-book-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: auto;
        }

        .books-read-btn {
            flex: 1;
            padding: 0.6rem 0.5rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            white-space: nowrap;
        }

        .books-read-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }
        
        .books-read-btn:disabled,
        .books-download-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none !important;
        }
        
        /* Ensure Library "Read" buttons look styled as well */
        .read-btn {
            width: 100%;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 4px 14px rgba(245, 158, 11, 0.25);
        }
        .read-btn:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 8px 22px rgba(245, 158, 11, 0.35); }
        .read-btn:active { transform: translateY(0); }

        .books-download-btn {
            flex: 1;
            padding: 0.6rem 0.5rem;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            color: #60a5fa;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            white-space: nowrap;
        }

        .books-download-btn:hover {
            background: rgba(59, 130, 246, 0.25);
            border-color: rgba(59, 130, 246, 0.5);
            color: #93c5fd;
            transform: translateY(-1px);
        }

        /* Responsive book cards */
        @media (max-width: 600px) {
            .books-results-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 0.75rem;
            }
            .books-book-cover {
                min-height: 180px;
            }
            .books-book-info {
                padding: 0.75rem;
            }
            .books-book-title {
                font-size: 0.85rem;
            }
            .books-book-author {
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }
            .books-book-actions {
                flex-direction: column;
                gap: 0.4rem;
            }
            .books-read-btn,
            .books-download-btn {
                padding: 0.5rem;
                font-size: 0.75rem;
            }
        }

        /* Books Reader Modal */
        .books-reader-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.98);
            z-index: 9999;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .books-reader-content {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            display: flex;
            flex-direction: column;
            background: var(--dark);
            overflow: hidden;
        }
        
        /* Music player modal gets constrained size */
        #music-player-modal .books-reader-content {
            width: 90%;
            max-width: 560px;
            height: auto;
            max-height: 90vh;
        }

        .books-reader-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 2rem;
            background: var(--primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            min-height: 70px;
        }

        .books-reader-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .books-reader-back-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(-2px);
        }

        .books-reader-title {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .books-reader-frame-container {
            flex: 1;
            width: 100%;
            height: calc(100vh - 70px);
            position: relative;
            background: #fff;
            overflow: hidden;
        }

        .books-reader-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: #fff;
            display: block;
        }

        /* Ensure no body scroll when reader is open */
        body.books-reader-open {
            overflow: hidden;
        }

        /* IPTV Source Selector */
        .iptv-source-selector {
            background: #1a0f2e;
            padding: 15px 20px;
            border-bottom: 1px solid #2d1b4e;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .iptv-source-label {
            color: #a78bfa;
            font-size: 14px;
            font-weight: 600;
            min-width: 80px;
        }

        .iptv-source-dropdown {
            background: #2d1b4e;
            border: 1px solid #4c1d95;
            border-radius: 8px;
            color: #e5e7eb;
            padding: 8px 12px;
            font-size: 14px;
            min-width: 300px;
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .iptv-source-dropdown:hover {
            border-color: #7c3aed;
            background: #362159;
        }

        .iptv-source-dropdown:focus {
            outline: none;
            border-color: #a78bfa;
            box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
        }

        .iptv-source-dropdown option {
            background: #2d1b4e;
            color: #e5e7eb;
            padding: 8px 12px;
            border: none;
        }

        .iptv-source-dropdown option:hover {
            background: #4c1d95;
        }

        .iptv-source-dropdown option:selected {
            background: #7c3aed;
            color: #ffffff;
        }

        /* Server Selection Modal */
        .server-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* Match page background instead of pure black overlay */
            background: var(--dark);
            z-index: 9998;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        .server-selection-content {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: var(--dark);
            overflow: visible;
        }

        .server-selection-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 2rem;
            background: var(--primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            min-height: 70px;
        }

        .server-selection-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .server-selection-back-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(-2px);
        }

        .server-selection-title {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .server-selection-body {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            /* Make the server selection (and embedded iframe) a bit wider */
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .server-selection-info {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1.5rem;
        }

        .media-info {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }

        .media-poster {
            width: 120px;
            height: 180px;
            border-radius: 12px;
            object-fit: cover;
            background: linear-gradient(135deg, #374151, #1f2937);
        }

        .media-details {
            flex: 1;
        }

        .media-details h4 {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .media-details p {
            color: #9ca3af;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .media-meta {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .media-year {
            background: rgba(168, 85, 247, 0.2);
            color: #a855f7;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .media-rating {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .server-dropdown-section {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
        }

        .server-dropdown-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .server-dropdown-container {
            position: relative;
        }

        .server-dropdown {
            width: 100%;
            padding: 1rem 1.5rem;
            padding-right: 4.5rem; /* extra space so custom chevron never overlaps scrollbar */
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            color: #fff;
            font-size: 1rem;
            font-weight: 500;
            appearance: none;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-height: 200px;
            overflow-y: auto;
            /* Make the dropdown scrollbar easier to see */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #22d3ee rgba(255, 255, 255, 0.12); /* thumb color | track color */
            scrollbar-gutter: stable both-edges; /* reserve space for scrollbar (Chromium/Firefox) */
        }

        /* WebKit-based scrollbars (Chromium/Electron) */
        .server-dropdown::-webkit-scrollbar {
            width: 14px; /* thicker for visibility */
        }

        .server-dropdown::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5); /* darker track for contrast */
            border-radius: 8px;
        }

        .server-dropdown::-webkit-scrollbar-thumb {
            background: #22d3ee; /* bright cyan for high contrast */
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.15);
        }

        .server-dropdown::-webkit-scrollbar-thumb:hover {
            background: #06b6d4;
        }

        .server-dropdown option {
            background: var(--dark);
            color: #fff;
            padding: 0.5rem;
        }

        .server-dropdown:focus {
            outline: none;
            border-color: rgba(168, 85, 247, 0.5);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.15);
        }

        .server-dropdown option {
            background: var(--primary);
            color: #fff;
            padding: 1rem;
            font-weight: 500;
        }

        .server-dropdown-arrow {
            position: absolute;
            right: 2.5rem; /* shift left so it never covers the scrollbar */
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
            pointer-events: none;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .server-dropdown:focus + .server-dropdown-arrow {
            transform: translateY(-50%) rotate(180deg);
        }

        .server-actions {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .server-watch-btn {
            flex: 1;
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-width: 200px;
        }

        .server-watch-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
        }

        .server-torrent-btn {
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            color: #9ca3af;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-width: 180px;
        }

        .server-torrent-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
        }

        /* Embedded Video Player Section */
        .server-video-section {
            margin-top: 2rem;
            background: var(--dark);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .server-video-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: var(--dark);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .server-video-header h4 {
            color: #fff;
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .server-video-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .server-video-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #e50914;
        }

        .server-video-container {
            position: relative;
            width: 100%;
            /* Make the embedded server player noticeably larger and responsive */
            height: 70vh;
            min-height: 480px;
            /* Match the app background so the area under the iframe blends in */
            background: var(--dark);
        }

        .server-video-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .server-video-controls {
            padding: 1rem 1.5rem;
            background: var(--dark);
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        /* Video Player Modal */
        .video-player-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.98);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .video-player-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--dark);
            overflow: hidden;
        }

        .video-player-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            background: var(--primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            min-height: 70px;
        }

        .video-player-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .video-player-back-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(-2px);
        }

        .video-player-title {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 600;
            flex: 1;
            margin: 0 2rem;
        }

        .video-player-controls {
            display: flex;
            gap: 0.5rem;
        }

        .video-player-control-btn {
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .video-player-control-btn:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .video-player-frame-container {
            flex: 1;
            width: 100%;
            height: calc(100vh - 70px);
            position: relative;
            background: #000;
            overflow: hidden;
        }

        .video-player-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: #000;
            display: block;
        }

        /* Prevent body scroll when modals are open */
        body.server-modal-open,
        body.video-modal-open {
            overflow: hidden;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(30px) scale(0.95); }
            60% { opacity: 0.8; transform: translateY(-5px) scale(1.01); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* BookTorrio Page Styles */
        .booktorrio-nav {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            justify-content: center;
        }

        /* EPUB Reader Styles */
        #epubReaderOverlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            /* Solid bar theming variables (no transparency) */
            --bar-bg: #202225; /* solid by default (dark) */
            --bar-border: rgba(255,255,255,0.1);
            --bar-btn-bg: #2b2b2b;       /* dark default */
            --bar-btn-border: #3a3a3a;
            --bar-input-bg: #1f1f1f;
            --bar-input-border: #3a3a3a;
        }
        /* Light theme overrides */
        #epubReaderOverlay.theme-light {
            --bar-bg: #ffffff;
            --bar-border: rgba(0,0,0,0.08);
            --bar-btn-bg: #f3f4f6;      /* slate-100 */
            --bar-btn-border: #e5e7eb;  /* slate-200 */
            --bar-input-bg: #ffffff;
            --bar-input-border: #e5e7eb;
        }
        /* Night theme overrides */
        #epubReaderOverlay.theme-night {
            --bar-bg: #000000;
            --bar-border: rgba(255,255,255,0.12);
            --bar-btn-bg: #111111;
            --bar-btn-border: #262626;
            --bar-input-bg: #0b0b0b;
            --bar-input-border: #262626;
        }
        .reader-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background-color: var(--bar-bg) !important;
            /* Solid header bar, no transparency */
            backdrop-filter: none;
            border-bottom: 1px solid var(--bar-border);
            box-shadow: 0 2px 6px rgba(0,0,0,0.22);
            position: sticky;
            top: 0;
            z-index: 2100;
        }
        .reader-esc-hint {
            color: var(--text);
            font-size: 0.85rem;
            white-space: nowrap;
            /* Make the hint itself solid (no transparency) */
            background: var(--bar-btn-bg);
            border: 1px solid var(--bar-btn-border);
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
        }
        .reader-title { 
            text-align: center; 
            color: var(--text); 
            font-weight: 600; 
            flex: 1;
        }
        #readerContainer { 
            flex: 1; 
            overflow-y: auto; 
            overflow-x: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Bottom navigation bar */
        .reader-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background-color: var(--bar-bg) !important;
            /* Solid footer bar, no transparency */
            backdrop-filter: none;
            border-top: 1px solid var(--bar-border);
            box-shadow: 0 -2px 6px rgba(0,0,0,0.22);
            position: sticky;
            bottom: 0;
            z-index: 2100;
        }
        .reader-nav-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
            justify-content: center;
        }
        .reader-chapter-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text);
        }
        .reader-chapter-controls .chapter-count-label {
            font-size: 0.9rem;
            opacity: 0.8;
            white-space: nowrap;
        }
        .reader-chapter-controls input[type="number"] {
            width: 84px;
            height: 36px;
            padding: 0 0.5rem;
            border-radius: 6px;
            border: 1px solid var(--bar-input-border);
            background: var(--bar-input-bg);
            color: var(--text);
            outline: none;
        }
        .reader-chapter-controls input[type="number"]::placeholder {
            color: rgba(255,255,255,0.55);
        }
        .reader-nav-btn, .reader-gear, .reader-back-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 44px; 
            height: 44px;
            padding: 0 1rem;
            border-radius: 8px;
            border: 1px solid var(--bar-btn-border);
            background: var(--bar-btn-bg);
            color: var(--text);
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .reader-nav-btn {
            min-width: 44px;
            padding: 0;
        }
        .reader-nav-btn:hover:not(:disabled), .reader-gear:hover, .reader-back-btn:hover {
            background: #6d28d9; /* solid purple on hover */
            border-color: #7c3aed;
            color: #fff;
            transform: translateY(-4px) scale(1.02);
        }
        .reader-back-btn:hover {
            background: #dc2626; /* solid red for back hover */
            border-color: #ef4444;
            color: #fff;
        }
        .reader-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .reader-settings {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 340px;
            max-height: 80vh;
            background: var(--bar-bg);
            color: var(--text);
            border: 1px solid var(--bar-border);
            border-radius: 12px;
            transform: translateY(0);
            transition: transform 0.3s ease, opacity 0.3s ease;
            padding: 1.5rem;
            z-index: 2200;
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            opacity: 1;
            pointer-events: auto;
            overflow-y: auto;
        }
        .reader-settings.hidden { 
            transform: translateY(20px); 
            opacity: 0; 
            pointer-events: none; 
        }
        .settings-row.justify { justify-content: space-between; }
        .align-btn { 
            flex: 1; 
            padding: 0.5rem; 
            border: 1px solid var(--bar-btn-border); 
            background: var(--bar-btn-bg); 
            color: var(--text); 
            cursor: pointer; 
            border-radius: 6px; 
            display: flex; 
            justify-content: center; 
            align-items: center;
        }
        .align-btn.active { background: var(--vlc-orange); color: #fff; border-color: var(--vlc-orange); }
        .align-btn:not(:last-child) { margin-right: 0.5rem; }
        .reader-settings-section { margin-bottom: 1rem; }
        .settings-row { display: flex; gap: 0.5rem; }
        .theme-btn { padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); color: #eee; cursor: pointer; }

        #focusRuler {
            position: absolute;
            left: 0;
            right: 0;
            height: 60px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.85);
            z-index: 50;
            pointer-events: none;
            display: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        /* Themes for overlay container */
        .theme-light { --bg: #ffffff; --text: #111111; }
        .theme-dark  { --bg: #202225; --text: #f2f2f2; }
        .theme-night { --bg: #000000; --text: #e5e7eb; }
        
        .booktorrio-tab-btn {
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 2px solid rgba(168, 85, 247, 0.3);
            background: rgba(42, 24, 71, 0.4);
            color: var(--light);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(10px);
        }
        
        .booktorrio-tab-btn:hover {
            border-color: #06b6d4;
            background: rgba(6, 182, 212, 0.1);
        }
        
        .booktorrio-tab-btn.active {
            border-color: #06b6d4;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
        }
        
        .booktorrio-tab {
            display: block;
        }
        
        .search-container-books {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .search-input-books {
            flex: 1;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: 2px solid rgba(168, 85, 247, 0.3);
            background: rgba(42, 24, 71, 0.4);
            color: var(--light);
            font-size: 1rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
        }
        
        .search-input-books:focus {
            outline: none;
            border-color: var(--vlc-orange);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.2);
        }
        
        .search-btn-books {
            padding: 1rem 2rem;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .search-btn-books:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.4);
        }
        
        .books-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .book-card {
            background: rgba(42, 24, 71, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 16px;
            padding: 1.5rem;
            backdrop-filter: blur(15px);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .book-card:hover {
            transform: translateY(-4px);
            border-color: #06b6d4;
            box-shadow: 0 8px 25px rgba(6, 182, 212, 0.2);
        }
        
        .book-cover-container {
            position: relative;
            width: 100%;
            margin-bottom: 1rem;
        }
        
        .book-cover {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 12px;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            display: block;
        }
        
        .playtorrio-logo {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 50%;
            height: 50%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            border-radius: 0 0 12px 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            backdrop-filter: blur(10px);
            border-left: 2px solid rgba(139, 92, 246, 0.5);
            border-top: 2px solid rgba(139, 92, 246, 0.5);
            box-shadow: 
                0 -2px 15px rgba(139, 92, 246, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }
        
        .playtorrio-logo::before {
            content: '';
            font-size: 1.8rem;
            color: #8b5cf6;
            filter: drop-shadow(0 2px 6px rgba(139, 92, 246, 0.8));
            animation: pulse 2s ease-in-out infinite;
            margin-bottom: 2px;
        }
        
        .playtorrio-logo::after {
            content: 'AUDIOBOOK';
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 2.5px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            border-top: 1px solid rgba(139, 92, 246, 0.3);
            padding-top: 4px;
            width: 90%;
            text-align: center;
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }
        
        .book-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--light);
            margin-bottom: 0.5rem;
            line-height: 1.3;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .book-author {
            color: #06b6d4;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        .book-details {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .book-tag {
            background: rgba(6, 182, 212, 0.2);
            color: #06b6d4;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            border: 1px solid rgba(6, 182, 212, 0.3);
        }
        
        .book-tag.epub-highlight {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border-color: #10b981;
        }
        
        .download-btn {
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .download-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.4);
        }
        
        .search-placeholder {
            grid-column: 1 / -1;
            text-align: center;
            padding: 3rem;
            color: var(--gray);
        }
        
        .search-placeholder h3 {
            color: var(--light);
            margin-bottom: 0.5rem;
        }
        
        /* Spinner for loading */
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(6, 182, 212, 0.3);
            border-left-color: #06b6d4;
            border-radius: 50%;
            animation: spin 1.4s cubic-bezier(0.65, 0, 0.35, 1) infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* EPUB Download Modal Styles */
        .epub-download-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }
        
        .epub-modal-content {
            background: linear-gradient(135deg, var(--primary) 0%, #1a0d2e 100%);
            border-radius: 16px;
            border: 1px solid rgba(168, 85, 247, 0.3);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        .epub-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }
        
        .epub-modal-header h3 {
            color: var(--light);
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .epub-modal-close {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .epub-modal-close:hover {
            background: rgba(168, 85, 247, 0.2);
            color: var(--light);
        }
        
        .epub-modal-body {
            padding: 1.5rem;
        }
        
        .epub-download-instruction {
            margin-bottom: 1.5rem;
        }
        
        .epub-download-instruction p {
            color: var(--light);
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        
        .epub-path-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid rgba(168, 85, 247, 0.2);
            margin-bottom: 1rem;
        }
        
        .epub-path-container code {
            flex: 1;
            color: #06b6d4;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            word-break: break-all;
        }
        
        .copy-path-btn {
            background: rgba(6, 182, 212, 0.2);
            border: 1px solid #06b6d4;
            color: #06b6d4;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .copy-path-btn:hover {
            background: #06b6d4;
            color: white;
        }
        
        .epub-note {
            font-size: 0.9rem;
            color: var(--gray);
            font-style: italic;
        }
        
        .epub-modal-actions {
            display: flex;
            justify-content: center;
        }
        
        .epub-download-btn {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }
        
        .epub-download-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 20px rgba(6, 182, 212, 0.4);
        }

        /* VLC Player Styles */
        .vlc-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--vlc-dark);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            /* Prevent any child from increasing the viewport height */
            overflow: hidden;
        }
        
        .vlc-player-container.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .vlc-player-header {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--vlc-orange);
            position: sticky;
            top: 0;
            z-index: 2100;
        }
        
        .vlc-player-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            position: relative;
            z-index: 2101;
        }
        
        .vlc-player-close {
            background: var(--vlc-orange);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            position: relative;
            z-index: 2102;
            pointer-events: auto;
        }
        
        .vlc-player-close:hover {
            background: #e55a00;
        }
        
        .vlc-player-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--vlc-dark);
            /* Allow inner flex children to shrink within viewport */
            min-height: 0;
            min-width: 0;
            position: relative;
            z-index: 1;
        }
        
        .file-selector {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem 2rem;
            border-bottom: 1px solid #444;
            position: relative;
            z-index: 1;
        }
        
        .file-selector h3 {
            color: var(--vlc-orange);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .file-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }

        /* MPV controls layout and spacing */
        #mpvControls {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 0 1.25rem;
            position: relative;
            z-index: 0;
        }

        #mpvControls .vlc-btn { width: auto; }
        
        .file-item {
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid transparent;
        }
        
        .file-item:hover {
            background: rgba(255, 105, 0, 0.2);
            border-color: var(--vlc-orange);
        }
        
        .file-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: white;
            white-space: normal;
            word-break: break-word;
            font-size: 0.9rem;
        }

        .file-name-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--dark);
            color: var(--light);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            white-space: normal;
            width: max-content;
            max-width: 300px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .file-size {
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .vlc-player-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            /* Ensure contained media never pushes layout */
            min-height: 0;
            min-width: 0;
            overflow: hidden;
            z-index: 1;
        }
        
        .vlc-loading {
            color: var(--vlc-orange);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            position: relative;
            z-index: 2;
            pointer-events: none;
        }
        
        .vlc-loading i {
            animation: spin 1.4s cubic-bezier(0.65, 0, 0.35, 1) infinite;
        }
        
        /* Base button styles for MPV/WCJS action buttons */
        .vlc-btn {
            background: var(--vlc-orange);
            border: none;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 2rem 2rem 1rem;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 3;
        }
        
        .vlc-btn:hover {
            background: #e55a00;
            transform: translateY(-4px) scale(1.02);
        }
        
        .vlc-btn.secondary {
            background: var(--secondary);
        }
        
        .vlc-btn.secondary:hover {
            background: #0199c7;
        }
        
        .subtitle-controls {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem 2rem;
            flex-direction: column;
            position: relative;
            z-index: 0;
        }
        
        .subtitle-controls h4 {
            color: var(--vlc-orange);
            margin-bottom: 1rem;
        }
        
        .subtitle-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 1rem; /* For scrollbar */
        }
        
        .subtitle-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }
        
        .subtitle-item:hover {
            background: rgba(255, 105, 0, 0.2);
            border-color: var(--vlc-orange);
        }

        .subtitle-item.selected {
            border-color: var(--success);
            background-color: rgba(40, 167, 69, 0.2);
        }
        
        .subtitle-lang {
            font-weight: 600;
            color: white;
            flex-grow: 1;
        }

        /* Custom Video Player Styles */
        .custom-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            /* Lock overlay to viewport */
            overflow: hidden;
        }

        .custom-player-container.active {
            opacity: 1;
            pointer-events: all;
        }

        .player-header {
            background: none;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 5;
        }

        .player-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .subtitle-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .subtitle-upload input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .upload-btn {
            background: var(--secondary);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .upload-btn:hover {
            background: #0199c7;
            transform: translateY(-1px);
        }

        .close-player-btn {
            background: var(--danger);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .close-player-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .video-container {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Critical for flex children so they don't overflow the viewport */
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }

        .custom-video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Always fit inside container */
            /* Ensure the video stays beneath overlays */
            z-index: 1;
        }
        
        /* Video.js subtitle positioning and styling */
        .video-js .vjs-text-track-display {
            bottom: 8em !important;
            pointer-events: none;
        }
        
        .video-js .vjs-text-track-cue {
            pointer-events: auto;
        }
        
        /* Hide Video.js error messages */
        .video-js .vjs-error-display,
        .video-js .vjs-modal-dialog {
            display: none !important;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 2rem 2rem 1rem;
            /* Always visible to avoid being pushed off-screen */
            transform: translateY(0);
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 2;
        }

        /* Auto-hide behavior scoped to custom player only */
        .custom-player-container .video-controls { transform: translateY(100%); opacity: 0; pointer-events: none; }
        .custom-player-container .video-container.show-controls .video-controls,
        .custom-player-container .video-controls.force-visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        /* Hide player header (title and close button) when controls are hidden */
        .custom-player-container .player-header { 
            transform: translateY(-100%); 
            opacity: 0; 
            pointer-events: none; 
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .custom-player-container.show-controls .player-header,
        .custom-player-container .player-header.force-visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        /* Hide cursor when controls are hidden */
        .custom-player-container:not(.show-controls) {
            cursor: none;
        }
        .custom-player-container:not(.show-controls) * {
            cursor: none;
        }

        .progress-container {
            margin-bottom: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .progress-filled {
            height: 100%;
            background: var(--vlc-orange);
            border-radius: 3px;
            width: 0%;
            transition: width 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .progress-time {
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .control-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        .control-left,
        .control-right { display:flex; align-items:center; gap:1rem; }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 0.8rem;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            width: 50px;
            height: 50px;
        }

        .control-btn:hover {
            background: var(--vlc-orange);
            transform: scale(1.12);
        }

        .control-btn.play-pause {
            background: var(--vlc-orange);
            font-size: 1.5rem;
            width: 60px;
            height: 60px;
        }

        .control-btn.play-pause:hover {
            background: #e55a00;
        }

        .fullscreen-btn {
            position: absolute;
            right: 1rem;
            bottom: 1rem;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--vlc-orange);
            font-size: 1.5rem;
            z-index: 2; /* below controls, above video */
        }

        .subtitle-display {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 500;
            text-align: center;
            max-width: 80%;
            display: none;
        }
        
        .notification {
            position: fixed;
            top: 2rem;
            right: 2rem;
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.95) 0%, rgba(30, 30, 30, 0.95) 100%);
            color: var(--text-primary);
            padding: 1.25rem 1.75rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10000;
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-width: 400px;
            min-width: 300px;
            font-weight: 500;
            font-size: 0.95rem;
            line-height: 1.4;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            /* Allow clicks to pass through so it never blocks UI like the music search bar */
            pointer-events: none;
        }

        .notification.success {
            border-left: 4px solid #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.success::before {
            content: '';
            color: #22c55e;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .notification.error {
            border-left: 4px solid #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.error::before {
            content: '';
            color: #ef4444;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .notification.info {
            border-left: 4px solid #3b82f6;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.info::before {
            content: '';
            color: #3b82f6;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .notification.warning {
            border-left: 4px solid #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(40, 40, 40, 0.95) 100%);
        }

        .notification.warning::before {
            content: '';
            color: #f59e0b;
            font-weight: bold;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        /* Subtitles menu panel */
        .subs-panel {
            position: absolute;
            right: 1rem;
            bottom: 6rem;
            width: 340px;
            max-height: 40vh;
            overflow: auto;
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.5rem;
            display: none;
            z-index: 10;
        }
        .subs-item { display:flex; align-items:center; justify-content:space-between; background: rgba(255,255,255,0.06); color:#fff; padding:0.5rem 0.6rem; border-radius:6px; margin:0.35rem 0; cursor:pointer; }
        .subs-item:hover { background: rgba(168,85,247,0.25); }
        .subs-badge { font-size: 0.75rem; color:#ccc; }
        .subs-source { font-size: 0.75rem; opacity: 0.8; margin-left: 0.4rem; }
        .row-spread { display:flex; align-items:center; justify-content:space-between; gap:0.5rem; }
        .subs-header { display:flex; align-items:center; justify-content:space-between; color:#fff; margin-bottom:0.25rem; }
        .subs-help { color:#bbb; font-size:0.8rem; margin-bottom:0.25rem; }
        .menu-actions { display:flex; align-items:center; gap:0.5rem; }
        .menu-refresh { background: rgba(255,255,255,0.15); border:none; color:#fff; padding:0.2rem 0.5rem; border-radius:4px; cursor:pointer; }
        
        /* Subtitle Upload and Customization Styles */
        .subs-upload { display:flex; flex-direction:column; gap:0.4rem; margin:0.5rem 0; background: rgba(255,255,255,0.06); padding:0.5rem; border-radius:6px; }
        .subs-upload-btn { background: var(--vlc-orange); color:#fff; border:none; padding:0.45rem 0.75rem; border-radius:6px; cursor:pointer; display:flex; align-items:center; gap:0.4rem; font-weight:600; justify-content:center; font-size:0.85rem; }
        .subs-upload-btn:hover { background:#e55a00; }
        .subs-divider { height:1px; background: rgba(255,255,255,0.12); margin:0.6rem 0; }
        .subs-settings { display:flex; flex-direction:column; gap:0.5rem; margin:0.5rem 0; }
        .subs-setting-row { display:flex; align-items:center; gap:0.5rem; font-size:0.8rem; color:#eee; }
        .subs-setting-row label { flex: 0 0 85px; }
        .subs-setting-row input[type="range"] { flex:1; }
        .subs-setting-row input[type="color"] { width:42px; height:28px; border:none; padding:0; background:none; cursor:pointer; }
        .subs-setting-row select { 
            flex:1; 
            padding:0.4rem 0.6rem; 
            border-radius:6px; 
            border:1px solid rgba(255,255,255,0.15); 
            background: rgba(255,255,255,0.08); 
            color:#fff; 
            font-size:0.85rem;
            font-weight:500;
            cursor:pointer;
        }
        .subs-setting-row select option {
            background: #1a1a1a;
            color: #fff;
        }
        .subs-setting-value { min-width:46px; text-align:right; color:#bbb; font-size:0.75rem; }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        /* ===== TRAKT PAGE STYLES ===== */
        .trakt-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .trakt-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .trakt-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 32px rgba(237, 28, 36, 0.2);
            border-color: rgba(237, 28, 36, 0.3);
        }

        .trakt-card-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            background: linear-gradient(90deg, rgba(237, 28, 36, 0.1) 0%, transparent 100%);
        }

        .trakt-card-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .trakt-card-header i {
            color: #ed1c24;
            font-size: 1.1rem;
        }

        .trakt-card-body {
            padding: 2rem;
        }

        .trakt-status-card {
            border: 2px solid rgba(237, 28, 36, 0.3);
        }

        .trakt-status-section {
            text-align: center;
        }

        .trakt-status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trakt-status-indicator.connected {
            color: #22c55e;
        }

        .trakt-status-indicator.disconnected {
            color: #ef4444;
        }

        .trakt-status-indicator i {
            font-size: 1.3rem;
        }

        .trakt-description {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 2rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .trakt-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: none;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .trakt-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .trakt-btn-primary {
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            color: white;
        }

        .trakt-btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #d41920 0%, #b8161c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(237, 28, 36, 0.4);
        }

        .trakt-btn-secondary {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .trakt-btn-secondary:hover:not(:disabled) {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .trakt-btn-info {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
        }

        .trakt-btn-info:hover:not(:disabled) {
            background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%);
        }

        .trakt-user-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Device Code Panel */
        .trakt-device-code {
            margin-top: 2rem;
            padding: 2rem;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid rgba(237, 28, 36, 0.2);
        }

        .trakt-code-header h4 {
            margin: 0 0 1.5rem 0;
            color: var(--text-primary);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .trakt-code-content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .trakt-code-display {
            text-align: center;
        }

        .trakt-code-display label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .trakt-code-value {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .trakt-code-value span {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 1.5rem;
            font-weight: 800;
            background: rgba(255,255,255,0.1);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: 2px solid rgba(237, 28, 36, 0.3);
            color: #ed1c24;
            letter-spacing: 0.2em;
        }

        .trakt-copy-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .trakt-copy-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .trakt-verify-section {
            text-align: center;
        }

        .trakt-verify-section p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .trakt-verify-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .trakt-status-message {
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid #ed1c24;
        }

        .trakt-status-message span {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Actions Grid */
        .trakt-actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        .trakt-action-card {
            cursor: pointer;
            padding: 2rem;
            text-align: center;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
        }

        .trakt-action-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ed1c24 0%, #d41920 100%);
            transform: scaleX(0);
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .trakt-action-card:hover::before {
            transform: scaleX(1);
        }

        .trakt-action-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 32px rgba(237, 28, 36, 0.15);
        }

        .trakt-action-icon {
            margin-bottom: 1rem;
        }

        .trakt-action-icon i {
            font-size: 2.5rem;
            color: #ed1c24;
        }

        .trakt-action-content h4 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
            font-size: 1.1rem;
        }

        .trakt-action-content p {
            margin: 0 0 1rem 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .trakt-action-count {
            display: inline-block;
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .trakt-action-badge {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* Settings Grid */
        .trakt-settings-grid {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .trakt-setting-item {
            padding: 1.5rem;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .trakt-setting-item:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(237, 28, 36, 0.3);
        }

        .trakt-setting-main {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .trakt-setting-content h4 {
            margin: 0 0 0.25rem 0;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .trakt-setting-content p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* Custom Toggle Switch */
        .trakt-toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            flex-shrink: 0;
        }

        .trakt-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .trakt-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255,255,255,0.2);
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .trakt-toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 50%;
        }

        .trakt-toggle input:checked + .trakt-toggle-slider {
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            border-color: #ed1c24;
        }

        .trakt-toggle input:checked + .trakt-toggle-slider:before {
            transform: translateX(26px);
        }

        /* Activity List */
        .trakt-activity-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .trakt-activity-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 4px solid #ed1c24;
        }

        .trakt-activity-icon {
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .trakt-activity-content {
            flex: 1;
        }

        .trakt-activity-title {
            margin: 0 0 0.25rem 0;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.95rem;
        }

        .trakt-activity-meta {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .trakt-container {
                padding: 1rem;
                gap: 1.5rem;
            }

            .trakt-card-body {
                padding: 1.5rem;
            }

            .trakt-actions-grid {
                grid-template-columns: 1fr;
            }

            .trakt-verify-actions {
                flex-direction: column;
                align-items: center;
            }

            .trakt-user-actions {
                flex-direction: column;
                align-items: center;
            }

            .trakt-setting-main {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem;
            }
        }
        /* ===== END TRAKT PAGE STYLES ===== */

        .error-message {
            background-color: var(--danger);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Genres pages styles */
        .genre-card {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 120px;
            text-align: center;
        }
        .genre-title {
            color: var(--light);
            font-size: 1.2rem;
        }
        .genre-chip {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.1);
            color: var(--tertiary);
            border: 1px solid rgba(255,255,255,0.15);
        }
        .genre-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .genre-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .toggle-btn {
            padding: 0.5rem 1rem;
            border-radius: 30px;
            border: 2px solid var(--vlc-orange);
            background: transparent;
            color: var(--vlc-orange);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .toggle-btn.active {
            background: var(--vlc-orange);
            color: #fff;
        }
        
        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                gap: 1rem;
            }
            
            .search-container {
                margin: 1rem 0;
                width: 100%;
            }
            
            .user-actions {
                gap: 0.5rem;
                flex-wrap: nowrap; /* Keep on same line */
            }
            
            .user-actions .btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
                min-height: 34px;
            }
            
            .user-actions .btn i {
                font-size: 0.85rem;
            }
            
            /* Hide text on very small screens, show icons only */
            @media (max-width: 600px) {
                .user-actions {
                    gap: 0.4rem;
                }
                
                .user-actions .btn span {
                    display: none;
                }
                .user-actions .btn {
                    padding: 0.5rem;
                    justify-content: center;
                    min-height: 32px;
                    font-size: 0.9rem;
                }
            }
            
            .modal-header-content {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .modal-poster {
                width: 150px;
                height: 225px;
            }
            
            .modal-title {
                font-size: 1.8rem;
            }
            
            .file-list {
                grid-template-columns: 1fr;
            }
            
            .video-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            .vlc-btn { /* mobile sizing override only */
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            .player-header {
                z-index: 3;
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .player-actions {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .control-buttons {
                gap: 0.5rem;
            }

            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }

            .control-btn.play-pause {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }

            .api-setup-content {
                padding: 2rem;
            }

            .api-setup-buttons {
                flex-direction: column;
            }

            .settings-content {
                padding: 1.5rem;
            }

            .settings-buttons {
                flex-direction: column;
            }
        }

        /* ========================================
           NEW UI STYLES - Modern App Interface
           ======================================== */
        
        /* OLD UI: Show app-container but without flex layout, hide sidebar */
        body.ui-old {
            display: block;
            height: auto;
            overflow: visible;
        }
        
        body.ui-old .app-container {
            display: block;
            height: auto;
        }
        
        body.ui-old .app-sidebar {
            display: none !important;
        }
        
        body.ui-old .app-main {
            display: block;
            overflow: visible;
            height: auto;
        }
        
        body.ui-old header {
            position: sticky;
            top: 0;
        }
        
        body.ui-old main {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
            overflow: visible;
        }
        
        /* NEW UI: Sidebar Navigation */
        body.ui-new {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        body.ui-new .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        body.ui-new .app-sidebar {
            display: flex;
            width: 240px;
            background: var(--modal-bg);
            border-right: 1px solid rgba(168, 85, 247, 0.2);
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.65s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.65s cubic-bezier(0.25, 0.46, 0.45, 0.94), width 0.65s cubic-bezier(0.25, 0.46, 0.45, 0.94), min-width 0.65s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.65s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            min-width: 240px;
        }
        
        /* Sidebar hidden state */
        body.ui-new .app-sidebar.sidebar-hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
            width: 0;
            min-width: 0;
            border-right: none;
        }
        
        /* Sidebar toggle button */
        .sidebar-toggle-btn {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border: 2px solid rgba(168, 85, 247, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
            opacity: 0;
            pointer-events: none;
        }
        
        .sidebar-toggle-btn:hover {
            transform: translateY(-50%) scale(1.15);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.7);
        }
        
        .sidebar-toggle-btn i {
            color: white;
            font-size: 1.1rem;
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* Show toggle button only when sidebar is hidden */
        body.ui-new .app-sidebar.sidebar-hidden ~ .app-main .sidebar-toggle-btn {
            opacity: 1;
            pointer-events: all;
        }
        
        /* Adjust main content when sidebar is hidden */
        body.ui-new .app-sidebar.sidebar-hidden ~ .app-main {
            margin-left: 0;
        }
        
        body.ui-new .sidebar-logo {
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--light);
            border-bottom: 1px solid rgba(168, 85, 247, 0.15);
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .sidebar-logo:hover {
            background: rgba(168, 85, 247, 0.1);
        }
        
        body.ui-new .sidebar-logo i {
            color: var(--vlc-orange);
            font-size: 1.8rem;
        }
        
        /* Sidebar close button hover effect */
        .sidebar-close-btn:hover {
            background: rgba(168, 85, 247, 0.2) !important;
            color: rgba(255, 255, 255, 1) !important;
        }
        
        /* Sidebar Stats Panel */
        body.ui-new .sidebar-stats {
            padding: 1rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        body.ui-new .stat-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        body.ui-new .stat-item i {
            font-size: 1.5rem;
            color: var(--vlc-orange);
            width: 32px;
            text-align: center;
        }
        
        body.ui-new .stat-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        body.ui-new .stat-label {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        body.ui-new .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--light);
        }
        
        body.ui-new .sidebar-divider {
            height: 1px;
            background: rgba(168, 85, 247, 0.15);
            margin: 0.5rem 1rem;
        }
        
        body.ui-new .nav-section-title {
            padding: 1rem 1.5rem 0.5rem;
            font-size: 0.7rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
        }
        
        body.ui-new .nav-badge {
            margin-left: auto;
            padding: 0.15rem 0.5rem;
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
        }
        
        /* Sidebar Quick Actions */
        body.ui-new .sidebar-quick-actions {
            padding: 0.75rem 1.5rem;
            margin-top: auto;
        }
        
        body.ui-new .quick-action-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
        }
        
        body.ui-new .quick-action-btn {
            width: 100%;
            padding: 0.65rem;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        body.ui-new .quick-action-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-1px);
        }
        
        body.ui-new .sidebar-user-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        body.ui-new .sidebar-user-info i {
            font-size: 1.5rem;
            color: var(--vlc-orange);
        }
        
        body.ui-new .sidebar-nav {
            flex: 1;
            padding: 0.5rem 0;
        }
        
        body.ui-new .nav-item {
            padding: 0.85rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-left: 3px solid transparent;
            font-weight: 500;
        }
        
        body.ui-new .nav-item:hover {
            background: rgba(168, 85, 247, 0.1);
            color: var(--light);
            border-left-color: var(--vlc-orange);
        }
        
        body.ui-new .nav-item.active {
            background: rgba(168, 85, 247, 0.15);
            color: var(--light);
            border-left-color: var(--vlc-orange);
        }
        
        body.ui-new .nav-item i {
            width: 20px;
            text-align: center;
        }
        
        body.ui-new .sidebar-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        /* Main Content Area */
        body.ui-new .app-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--dark);
        }
        
        /* Modern Header */
        body.ui-new header {
            position: static;
            background: linear-gradient(90deg, var(--primary) 0%, #1f1035 100%);
            padding: 1.25rem 2rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
        }
        
        body.ui-new .header-container {
            justify-content: space-between;
            max-width: none;
        }
        
        body.ui-new .logo {
            display: none; /* Logo in sidebar instead */
        }
        
        body.ui-new .search-container {
            flex: 0 1 500px;
            margin: 0;
        }
        
        body.ui-new .search-container input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .search-container input:focus {
            background: rgba(0, 0, 0, 0.4);
            border-color: var(--vlc-orange);
        }
        
        body.ui-new .user-actions {
            gap: 0.75rem;
        }
        
        body.ui-new .btn {
            border-radius: 8px;
            padding: 0.65rem 1.1rem;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .btn-outline {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .btn-outline.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            color: white;
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .btn-primary {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
        }
        
        /* Connection Status */
        body.ui-new .connection-status {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.8rem;
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid rgba(40, 167, 69, 0.3);
            border-radius: 20px;
            font-size: 0.8rem;
            color: #28a745;
            white-space: nowrap;
        }
        
        body.ui-new .connection-status i {
            font-size: 0.5rem;
            animation: pulse 3s cubic-bezier(0.45, 0, 0.55, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.97); }
        }
        
        @keyframes shimmer {
            0% { background-position: -200% 0; opacity: 0.8; }
            50% { opacity: 1; }
            100% { background-position: 200% 0; opacity: 0.8; }
        }
        
        /* Hide connection status in OLD UI */
        body.ui-old .connection-status {
            display: none;
        }
        
        /* Enhanced Page Header */
        body.ui-new .page-header-enhanced {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(168, 85, 247, 0.05);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .page-title-section {
            flex: 1;
        }
        
        body.ui-new .page-subtitle {
            margin-top: 0.5rem;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }
        
        body.ui-new .page-actions {
            display: flex;
            gap: 0.75rem;
        }
        
        body.ui-new .action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.65rem 1.25rem;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: var(--light);
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 0.9rem;
        }
        
        body.ui-new .action-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-4px) scale(1.02);
        }
        
        /* Hide enhanced elements in OLD UI */
        body.ui-old .page-header-enhanced {
            display: none;
        }
        
        body.ui-old .page-subtitle {
            display: none;
        }
        
        /* Content Area */
        body.ui-new main {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            margin: 0;
            padding: 2rem 2.5rem;
            max-width: none;
            background: linear-gradient(135deg, var(--dark) 0%, #0a0612 100%);
        }
        
        /* Modern Section Titles */
        body.ui-new .section-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid rgba(168, 85, 247, 0.3);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        body.ui-new .section-title i {
            color: var(--vlc-orange);
        }
        
        /* Category Pills */
        body.ui-new .categories {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        
        body.ui-new .category {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1.5rem;
            border-radius: 25px;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-weight: 500;
        }
        
        body.ui-new .category i {
            font-size: 0.9rem;
        }
        
        body.ui-new .category:hover {
            background: var(--hover-bg);
            border-color: var(--vlc-orange);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.2);
        }
        
        body.ui-new .category.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
        }
        
        /* Modern Movie Cards with Glass Morphism */
        body.ui-new .movie-card {
            background: var(--card-bg);
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .movie-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 30px rgba(168, 85, 247, 0.35);
            border-color: var(--vlc-orange);
        }
        
        body.ui-new .movie-poster {
            position: relative;
            overflow: hidden;
        }
        
        body.ui-new .movie-poster::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
            opacity: 0;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        body.ui-new .movie-card:hover .movie-poster::after {
            opacity: 1;
        }
        
        body.ui-new .movie-poster img {
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .movie-card:hover .movie-poster img {
            transform: scale(1.12);
        }
        
        /* New UI Add to List Button */
        body.ui-new .add-to-list-btn {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(168, 85, 247, 0.5);
            color: var(--light);
            padding: 0.6rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            opacity: 0;
            transform: scale(0.7) translateY(10px);
            backdrop-filter: blur(10px);
            z-index: 2;
        }
        
        body.ui-new .movie-card:hover .add-to-list-btn {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        body.ui-new .add-to-list-btn:hover {
            background: var(--success);
            border-color: var(--success);
            transform: scale(1.12) translateY(0);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        
        body.ui-new .add-to-list-btn.in-list {
            background: var(--success);
            border-color: var(--success);
            opacity: 1;
            transform: scale(1) translateY(0);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
        
        body.ui-new .add-to-list-btn.in-list i:before {
            content: "\f00c"; /* checkmark */
        }
        
        /* New UI Done Watching Button */
        body.ui-new .movie-card .done-watching-btn {
            position: absolute;
            top: 12px;
            left: 60px; /* Position next to the add-to-list button */
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(23, 162, 184, 0.5);
            color: var(--light);
            padding: 0.6rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            opacity: 0;
            transform: scale(0.7) translateY(10px);
            backdrop-filter: blur(10px);
            z-index: 2;
        }
        
        body.ui-new .movie-card:hover .done-watching-btn {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        body.ui-new .movie-card .done-watching-btn:hover {
            background: #17a2b8;
            border-color: #17a2b8;
            transform: scale(1.12) translateY(0);
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.4);
        }
        
        body.ui-new .movie-card .done-watching-btn.is-done {
            background: #17a2b8;
            border-color: #17a2b8;
            opacity: 1;
            transform: scale(1) translateY(0);
            box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
        }
        
        body.ui-new .movie-card .done-watching-btn.is-done i:before {
            content: "\f058"; /* check-circle */
        }
        
        /* Continue Watching specific styles */
        .continue-watching-card .remove-continue-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(220, 38, 38, 0.9);
            border: 1px solid rgba(220, 38, 38, 0.5);
            color: white;
            padding: 0.6rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            opacity: 0;
            transform: scale(0.7);
            backdrop-filter: blur(10px);
            z-index: 2;
        }
        
        .continue-watching-card:hover .remove-continue-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .continue-watching-card .remove-continue-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.12);
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.5);
        }
        
        /* Fix width for continue watching cards in slider to match trending cards */
        #continueWatchingSlider .continue-watching-card {
            flex: 0 0 260px;
            width: 260px;
        }
        
        /* Progress bar for continue watching cards */
        .continue-watching-card .movie-poster {
            position: relative;
        }
        
        .continue-watching-placeholder {
            width: 100%;
            padding-top: 150%; /* 2:3 aspect ratio to match posters */
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(255, 111, 0, 0.2) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .continue-watching-placeholder i {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: rgba(255, 255, 255, 0.3);
        }
        
        .continue-watching-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--vlc-orange) 0%, #ff8c42 100%);
            transition: width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 10px rgba(255, 111, 0, 0.5);
            z-index: 2;
        }
        
        body.ui-new .movie-info {
            padding: 1.25rem;
            background: linear-gradient(180deg, rgba(42, 24, 71, 0.6) 0%, rgba(18, 10, 31, 0.8) 100%);
        }
        
        body.ui-new .movie-title {
            font-size: 1.05rem;
            margin-bottom: 0.5rem;
            color: var(--light);
        }
        
        body.ui-new .movie-meta {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            font-size: 0.85rem;
        }
        
        body.ui-new .movie-rating {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
            border: 1px solid rgba(255, 193, 7, 0.4);
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .movie-year {
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
        }
        
        /* Genre Boxes */
        body.ui-new .genre-box {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(139, 92, 246, 0.1) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .genre-box:hover {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.25) 0%, rgba(139, 92, 246, 0.2) 100%);
            border-color: var(--vlc-orange);
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(168, 85, 247, 0.3);
        }
        
        /* Modern Modal */
        body.ui-new .modal-content {
            background: linear-gradient(135deg, rgba(42, 24, 71, 0.95) 0%, rgba(18, 10, 31, 0.95) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        body.ui-new .modal-close {
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .modal-close:hover {
            background: rgba(220, 53, 69, 0.3);
            border-color: #dc3545;
            transform: rotate(90deg);
        }
        
        /* Buttons in Modal */
        body.ui-new .play-btn {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border: none;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .play-btn:hover {
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.6);
            transform: translateY(-4px) scale(1.02);
        }
        
        /* ==== HERO SECTION ==== */
        body.ui-new .hero-section {
            position: relative;
            height: 80vh;
            min-height: 600px;
            margin: -2rem -1rem 3rem -1rem;
            overflow: hidden;
            border-radius: 0 0 20px 20px;
        }
        
        body.ui-new .hero-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: brightness(0.4);
        }
        
        body.ui-new .hero-gradient {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60%;
            background: linear-gradient(to top, var(--dark) 0%, transparent 100%);
        }
        
        body.ui-new .hero-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4rem 3rem;
            z-index: 2;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        body.ui-new .hero-title {
            font-size: 4rem;
            font-weight: 900;
            margin-bottom: 1.5rem;
            text-shadow: 2px 2px 20px rgba(0, 0, 0, 0.8);
            line-height: 1.1;
            max-width: 800px;
        }
        
        body.ui-new .hero-meta {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            font-size: 1.2rem;
        }
        
        body.ui-new .hero-rating {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(168, 85, 247, 0.9);
            padding: 0.5rem 1rem;
            border-radius: 30px;
            font-weight: 700;
            color: white;
        }
        
        body.ui-new .hero-year, body.ui-new .hero-runtime {
            color: var(--tertiary);
            font-weight: 600;
        }
        
        body.ui-new .hero-overview {
            font-size: 1.2rem;
            line-height: 1.8;
            max-width: 700px;
            margin-bottom: 2rem;
            text-shadow: 1px 1px 10px rgba(0, 0, 0, 0.8);
            color: rgba(255, 255, 255, 0.95);
        }
        
        body.ui-new .hero-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        body.ui-new .hero-btn {
            padding: 1rem 2.5rem;
            border-radius: 8px;
            border: none;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        body.ui-new .hero-btn-primary {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5);
        }
        
        body.ui-new .hero-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(168, 85, 247, 0.7);
        }
        
        body.ui-new .hero-btn-secondary {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        
        body.ui-new .hero-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-3px);
        }
        
        /* ==== HORIZONTAL SLIDERS ==== */
        body.ui-new .slider-section {
            margin-bottom: 3rem;
        }
        
        body.ui-new .slider-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding: 0 1rem;
        }
        
        body.ui-new .slider-title {
            font-size: 1.8rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        body.ui-new .slider-title i {
            color: var(--vlc-orange);
        }
        
        body.ui-new .slider-nav {
            display: flex;
            gap: 0.5rem;
        }
        
        body.ui-new .slider-arrow {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid rgba(168, 85, 247, 0.3);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .slider-arrow:hover {
            background: var(--vlc-orange);
            border-color: var(--vlc-orange);
            transform: scale(1.12);
        }
        
        body.ui-new .slider-arrow.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        body.ui-new .slider-container {
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0 1rem;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        body.ui-new .slider-container::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        
        body.ui-new .slider-track {
            display: flex;
            gap: 1rem;
            padding-bottom: 1rem;
        }
        
        body.ui-new .slider-item {
            flex: 0 0 260px;
            width: 260px;
            background: var(--card-bg);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
        }
        
        body.ui-new .slider-item:hover {
            transform: scale(1.08);
            z-index: 10;
            box-shadow: 0 12px 40px rgba(168, 85, 247, 0.4);
            border-color: var(--vlc-orange);
        }
        
        body.ui-new .slider-poster {
            width: 100%;
            height: 375px;
            object-fit: cover;
            display: block;
        }
        
        body.ui-new .slider-info {
            padding: 1rem;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .slider-item:hover .slider-info {
            opacity: 1;
            transform: translateY(0);
        }
        
        body.ui-new .slider-item-title {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: white;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        body.ui-new .slider-item-meta {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
        }
        
        body.ui-new .slider-rating {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            color: var(--vlc-orange);
            font-weight: 700;
        }
        
        body.ui-new .slider-year {
            color: var(--tertiary);
        }
        
        /* Settings Modal */
        body.ui-new .settings-content {
            background: linear-gradient(135deg, rgba(42, 24, 71, 0.95) 0%, rgba(18, 10, 31, 0.95) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(20px);
        }
        
        body.ui-new .settings-section {
            background: rgba(168, 85, 247, 0.05);
            border: 1px solid rgba(168, 85, 247, 0.2);
            backdrop-filter: blur(10px);
        }
        
        /* Loading Indicators */
        body.ui-new .loading {
            color: var(--vlc-orange);
        }
        
        /* Scrollbar Styling for New UI */
        body.ui-new ::-webkit-scrollbar {
            width: 10px;
        }
        
        body.ui-new ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        
        body.ui-new ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-radius: 5px;
        }
        
        body.ui-new ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #9333ea 0%, var(--vlc-orange) 100%);
        }
        
        /* ==== ENHANCED MODAL STYLES (NEW UI) ==== */
        body.ui-new .modal-header {
            height: 500px;
            position: relative;
        }
        
        body.ui-new .modal-backdrop {
            filter: brightness(0.3);
        }
        
        body.ui-new .modal-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to top, var(--card-bg) 0%, transparent 100%);
        }
        
        body.ui-new .modal-header-content {
            z-index: 2;
            padding: 3rem;
        }
        
        body.ui-new .modal-poster {
            width: 220px;
            height: 330px;
            border-radius: 12px;
            border: 3px solid rgba(168, 85, 247, 0.3);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
        }
        
        body.ui-new .modal-title {
            font-size: 3rem;
            font-weight: 900;
            text-shadow: 2px 2px 15px rgba(0, 0, 0, 0.8);
            margin-bottom: 1rem;
        }
        
        body.ui-new .modal-rating {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            padding: 0.5rem 1rem;
            border-radius: 30px;
            font-size: 1.1rem;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .modal-tagline {
            font-size: 1.2rem;
            color: var(--tertiary);
            font-style: italic;
        }
        
        body.ui-new .modal-body {
            background: var(--card-bg);
            padding: 3rem;
        }
        
        body.ui-new .modal-section-title {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            margin-top: 2rem;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid rgba(168, 85, 247, 0.3);
        }
        
        body.ui-new .modal-section-title:first-of-type {
            margin-top: 0;
        }
        
        body.ui-new .modal-section-title i {
            color: var(--vlc-orange);
        }
        
        body.ui-new .modal-overview {
            font-size: 1.1rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
        }
        
        /* Enhanced Modal Action Buttons */
        body.ui-new .modal-actions-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        body.ui-new .primary-actions {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        body.ui-new .btn-enhanced {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
            min-width: 200px;
        }
        
        body.ui-new .btn-enhanced::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        body.ui-new .btn-enhanced:hover::before {
            opacity: 1;
        }
        
        body.ui-new .btn-enhanced-primary {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.4);
            color: white;
        }
        
        body.ui-new .btn-enhanced-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(168, 85, 247, 0.6);
        }
        
        body.ui-new .btn-enhanced-secondary {
            background: rgba(168, 85, 247, 0.15);
            border: 2px solid rgba(168, 85, 247, 0.3);
            color: white;
        }
        
        body.ui-new .btn-enhanced-secondary:hover {
            background: rgba(168, 85, 247, 0.25);
            border-color: var(--vlc-orange);
            transform: translateY(-3px);
        }
        
        body.ui-new .btn-icon {
            width: 48px;
            height: 48px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        body.ui-new .btn-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.25rem;
        }
        
        body.ui-new .btn-title {
            font-size: 1.1rem;
            font-weight: 700;
            line-height: 1;
        }
        
        body.ui-new .btn-subtitle {
            font-size: 0.85rem;
            opacity: 0.8;
            line-height: 1;
        }
        
        body.ui-new .secondary-actions {
            display: flex;
            gap: 0.75rem;
        }
        
        body.ui-new .btn-icon-only {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid rgba(168, 85, 247, 0.3);
            background: rgba(168, 85, 247, 0.1);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 1.1rem;
        }
        
        body.ui-new .btn-icon-only:hover {
            background: var(--vlc-orange);
            border-color: var(--vlc-orange);
            transform: scale(1.12);
        }
        
        /* Trakt Watchlist Button - Override circular icon styling */
        body.ui-new #traktWatchlistBtn {
            width: auto;
            height: auto;
            min-width: 160px;
            border-radius: 12px;
            padding: 0.75rem 1.25rem;
            font-size: 0.95rem;
            font-weight: 600;
            gap: 0.5rem;
            border: 2px solid rgba(168, 85, 247, 0.4);
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15), rgba(139, 92, 246, 0.1));
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new #traktWatchlistBtn:hover {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(139, 92, 246, 0.2));
            border-color: rgba(168, 85, 247, 0.6);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
        }
        
        body.ui-new #traktWatchlistBtn.btn-success {
            border-color: rgba(16, 185, 129, 0.4);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1));
            color: #10b981;
        }
        
        body.ui-new #traktWatchlistBtn.btn-success:hover {
            border-color: rgba(16, 185, 129, 0.6);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(5, 150, 105, 0.2));
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        body.ui-new #traktWatchlistBtn.btn-secondary {
            border-color: rgba(168, 85, 247, 0.4);
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15), rgba(139, 92, 246, 0.1));
            color: #a855f7;
        }
        
        body.ui-new #traktWatchlistBtn.btn-secondary:hover {
            border-color: rgba(168, 85, 247, 0.6);
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(139, 92, 246, 0.2));
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
        }
        
        body.ui-new #traktWatchlistBtn i {
            font-size: 1rem;
        }
        
        body.ui-new #traktWatchlistBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        body.ui-new .action-note {
            padding: 0.75rem 1rem;
            background: rgba(168, 85, 247, 0.1);
            border-left: 3px solid var(--vlc-orange);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        body.ui-new .action-note i {
            color: var(--vlc-orange);
        }
        
        body.ui-new .cast-card {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .cast-card:hover {
            border-color: var(--vlc-orange);
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.3);
            transform: translateY(-5px);
        }
        
        body.ui-new .cast-img {
            border-radius: 12px 12px 0 0;
        }
        
        body.ui-new .episode-card {
            background: rgba(168, 85, 247, 0.08);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .episode-card:hover {
            background: rgba(168, 85, 247, 0.15);
            border-color: var(--vlc-orange);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.3);
            transform: translateY(-3px);
        }
        
        /* Ensure selected episode is clearly highlighted in the new UI */
        body.ui-new .episode-card.selected {
            border-color: var(--vlc-orange) !important;
            background: rgba(255, 105, 0, 0.14) !important;
            box-shadow: 0 8px 24px rgba(255, 105, 0, 0.35);
            transform: translateY(-3px);
        }
        
        body.ui-new .season-btn {
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .season-btn:hover {
            background: rgba(168, 85, 247, 0.25);
            border-color: var(--vlc-orange);
            transform: translateY(-4px) scale(1.02);
        }
        
        body.ui-new .season-btn.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.5);
        }
        
        body.ui-new .torrent-item {
            background: rgba(168, 85, 247, 0.08);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new .torrent-item:hover {
            background: rgba(168, 85, 247, 0.15);
            border-color: var(--vlc-orange);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.25);
        }
        
        /* Enhanced Torrents Section */
        body.ui-new .torrents-container {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid rgba(168, 85, 247, 0.2);
        }
        
        body.ui-new .torrents-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        body.ui-new .provider-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 0.5rem;
            scrollbar-width: thin;
            scrollbar-color: rgba(168, 85, 247, 0.5) rgba(168, 85, 247, 0.1);
        }
        
        body.ui-new .provider-buttons::-webkit-scrollbar {
            height: 6px;
        }
        
        body.ui-new .provider-buttons::-webkit-scrollbar-track {
            background: rgba(168, 85, 247, 0.1);
            border-radius: 3px;
        }
        
        body.ui-new .provider-buttons::-webkit-scrollbar-thumb {
            background: rgba(168, 85, 247, 0.5);
            border-radius: 3px;
        }
        
        body.ui-new .provider-buttons::-webkit-scrollbar-thumb:hover {
            background: rgba(168, 85, 247, 0.7);
        }
        
        body.ui-new .provider-btn {
            padding: 0.75rem 1.25rem;
            border-radius: 10px;
            border: 2px solid rgba(168, 85, 247, 0.3);
            background: rgba(168, 85, 247, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        body.ui-new .provider-btn:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: var(--vlc-orange);
            transform: translateY(-4px) scale(1.02);
        }
        
        body.ui-new .provider-btn.active {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            border-color: transparent;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.5);
        }
        
        body.ui-new .torrents-list {
            display: grid;
            gap: 1rem;
        }
        
        body.ui-new .torrent-item {
            background: rgba(168, 85, 247, 0.08);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        
        body.ui-new .torrent-item:hover {
            background: rgba(168, 85, 247, 0.15);
            border-color: var(--vlc-orange);
            box-shadow: 0 3px 12px rgba(168, 85, 247, 0.2);
            transform: translateX(3px);
        }
        
        body.ui-new .torrent-title {
            font-weight: 600;
            font-size: 0.95rem;
            color: white;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        body.ui-new .torrent-meta {
            display: flex;
            gap: 1rem;
            align-items: center;
            font-size: 0.85rem;
        }
        
        body.ui-new .torrent-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.8rem;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            white-space: nowrap;
        }
        
        body.ui-new .torrent-badge.seeders {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.4);
            color: #22c55e;
        }
        
        body.ui-new .torrent-badge.leechers {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #ef4444;
        }
        
        body.ui-new .torrent-badge.size {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            color: #3b82f6;
        }
        
        body.ui-new .torrent-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        body.ui-new .torrent-actions button {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.4rem;
            white-space: nowrap;
        }
        
        body.ui-new .torrent-actions .btn-play {
            background: linear-gradient(135deg, var(--vlc-orange) 0%, #9333ea 100%);
            color: white;
        }
        
        body.ui-new .torrent-actions .btn-play:hover {
            transform: scale(1.03);
            box-shadow: 0 3px 12px rgba(168, 85, 247, 0.4);
        }
        
        body.ui-new .torrents-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        /* Enhanced Filter Controls */
        body.ui-new .filter-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
            align-items: center;
        }
        
        body.ui-new .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        body.ui-new .filter-group label {
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        body.ui-new .filter-group select,
        body.ui-new .filter-group input {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 2px solid rgba(168, 85, 247, 0.3);
            background: rgba(168, 85, 247, 0.1);
            color: white;
            font-size: 0.95rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            min-width: 150px;
        }
        
        body.ui-new .filter-group select:focus,
        body.ui-new .filter-group input:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background: rgba(168, 85, 247, 0.15);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.1);
        }
        
        body.ui-new .filter-group select option {
            background: #1a1a1a;
            color: white;
        }
        
        body.ui-new .search-torrents-input {
            flex: 1;
            min-width: 250px;
        }
        
        /* Audio Issues Notice */
        body.ui-new .audio-issues-notice {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(147, 51, 234, 0.15) 100%);
            border: 2px solid rgba(168, 85, 247, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid var(--vlc-orange);
        }
        
        body.ui-new .audio-issues-notice h4 {
            color: var(--vlc-orange);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        body.ui-new .audio-issues-notice p {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
        }
        
        /* Enhanced Music Section */
        body.ui-new #music-page .page-header-enhanced {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.15) 0%, rgba(168, 85, 247, 0.15) 100%);
            border: 2px solid rgba(236, 72, 153, 0.3);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        body.ui-new #music-page .page-title-section {
            margin-bottom: 1rem;
        }
        
        body.ui-new #music-page .section-title i {
            font-size: 1.5rem;
        }
        
        body.ui-new #music-page .page-actions {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        body.ui-new #music-page .action-btn {
            background: rgba(236, 72, 153, 0.1);
            border: 2px solid rgba(236, 72, 153, 0.3);
            border-radius: 10px;
            padding: 0.65rem 1.25rem;
            color: white;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        body.ui-new #music-page .action-btn i {
            font-size: 1rem;
        }
        
        body.ui-new #music-page .action-btn:hover {
            background: linear-gradient(135deg, #ec4899 0%, #a855f7 100%);
            border-color: transparent;
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 6px 16px rgba(236, 72, 153, 0.35);
        }
        
        body.ui-new #music-page .books-search-section {
            margin-bottom: 2.5rem;
        }
        
        body.ui-new #music-page .books-search-bar {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: rgba(236, 72, 153, 0.1);
            border: 2px solid rgba(236, 72, 153, 0.3);
            border-radius: 12px;
            padding: 1rem 1.5rem;
        }
        
        body.ui-new #music-page #music-search-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.05rem;
            outline: none;
        }
        
        body.ui-new #music-page .books-search-button {
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        body.ui-new #music-page #music-search-btn {
            background: linear-gradient(135deg, #ec4899 0%, #a855f7 100%);
            color: white;
        }
        
        body.ui-new #music-page #music-album-search-btn {
            background: linear-gradient(135deg, #38bdf8 0%, #0ea5e9 100%);
            color: white;
        }
        
        body.ui-new #music-page .books-search-button:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 15px rgba(236, 72, 153, 0.5);
        }
        
        body.ui-new #music-page .books-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
        }
        
        body.ui-new #music-page .music-card,
        body.ui-new #music-page .album-card {
            background: rgba(236, 72, 153, 0.08);
            border: 1px solid rgba(236, 72, 153, 0.2);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
        }
        
        body.ui-new #music-page .music-card:hover,
        body.ui-new #music-page .album-card:hover {
            background: rgba(236, 72, 153, 0.15);
            border-color: #ec4899;
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(236, 72, 153, 0.3);
        }
        
        body.ui-new #music-page .album-tracks-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }
        
        body.ui-new #music-page .track-item {
            background: rgba(236, 72, 153, 0.08);
            border: 1px solid rgba(236, 72, 153, 0.2);
            border-radius: 10px;
            padding: 1rem 1.25rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new #music-page .track-item:hover {
            background: rgba(236, 72, 153, 0.15);
            border-color: #ec4899;
            transform: translateX(5px);
        }
        
        body.ui-new #music-page .books-empty {
            text-align: center;
            padding: 4rem 2rem;
            background: rgba(236, 72, 153, 0.05);
            border: 2px dashed rgba(236, 72, 153, 0.3);
            border-radius: 16px;
        }
        
        body.ui-new #music-page .books-empty-icon {
            font-size: 4rem;
            color: #ec4899;
            margin-bottom: 1.5rem;
        }
        
        body.ui-new #music-page .books-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            gap: 1rem;
        }
        
        body.ui-new #music-page .books-loading-spinner {
            font-size: 3rem;
            color: #ec4899;
        }
        
        body.ui-new #music-page .playlist-close-btn {
            background: rgba(239, 68, 68, 0.15);
            border: 2px solid rgba(239, 68, 68, 0.3);
            border-radius: 10px;
            padding: 0.75rem 1.25rem;
            color: #ef4444;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }
        
        body.ui-new #music-page .playlist-close-btn:hover {
            background: rgba(239, 68, 68, 0.25);
            transform: scale(1.08);
        }
        
        /* Enhanced Books Section */
        body.ui-new #books-page .page-header-enhanced {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(168, 85, 247, 0.15) 100%);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        
        body.ui-new #books-page .books-search-bar {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1rem 1.5rem;
        }
        
        body.ui-new #books-page #books-search-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.05rem;
            outline: none;
        }
        
        body.ui-new #books-page .books-search-button {
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            border: none;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        body.ui-new #books-page .books-search-button:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.5);
        }
        
        body.ui-new #books-page .books-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1.5rem;
        }
        
        body.ui-new #books-page .book-card {
            background: rgba(59, 130, 246, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
        }
        
        body.ui-new #books-page .book-card:hover {
            background: rgba(59, 130, 246, 0.15);
            border-color: #3b82f6;
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(59, 130, 246, 0.3);
        }
        
        body.ui-new #books-page .books-empty {
            text-align: center;
            padding: 4rem 2rem;
            background: rgba(59, 130, 246, 0.05);
            border: 2px dashed rgba(59, 130, 246, 0.3);
            border-radius: 16px;
        }
        
        body.ui-new #books-page .books-empty-icon {
            font-size: 4rem;
            color: #3b82f6;
            margin-bottom: 1.5rem;
        }
        
        body.ui-new #books-page .books-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            gap: 1rem;
        }
        
        body.ui-new #books-page .books-loading-spinner {
            font-size: 3rem;
            color: #3b82f6;
        }
        
        /* Settings Page Styles */
        .settings-page-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .settings-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid rgba(168, 85, 247, 0.2);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        
        .settings-tab {
            padding: 1rem 2rem;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-bottom: 3px solid transparent;
            position: relative;
            bottom: -2px;
        }
        
        .settings-tab:hover {
            color: var(--light);
            background: rgba(168, 85, 247, 0.05);
        }
        
        .settings-tab.active {
            color: var(--vlc-orange);
            border-bottom-color: var(--vlc-orange);
            background: rgba(255, 111, 0, 0.05);
        }
        
        .settings-sections {
            position: relative;
        }
        
        .settings-section {
            display: none;
            animation: fadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .settings-section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .settings-card {
            background: var(--card-bg);
            border-radius: 12px;
            margin-bottom: 1.5rem;
            overflow: hidden;
            border: 1px solid rgba(168, 85, 247, 0.15);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .settings-card:hover {
            border-color: rgba(168, 85, 247, 0.3);
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.1);
        }
        
        .settings-card-header {
            background: var(--modal-bg);
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgba(168, 85, 247, 0.15);
        }
        
        .settings-card-header h3 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .settings-card-header h3 i {
            color: var(--vlc-orange);
        }
        
        .settings-card-body {
            padding: 1.5rem;
        }
        
        .settings-card-body .form-group {
            margin-bottom: 1.5rem;
        }
        
        .settings-card-body .form-group:last-child {
            margin-bottom: 0;
        }
        
        .settings-card-body label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .settings-card-body input[type="text"],
        .settings-card-body input[type="url"],
        .settings-card-body input[type="password"],
        .settings-card-body select,
        .settings-card-body textarea {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--input-bg);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 8px;
            color: var(--light);
            font-size: 0.95rem;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .settings-card-body input:focus,
        .settings-card-body select:focus,
        .settings-card-body textarea:focus {
            outline: none;
            border-color: var(--vlc-orange);
            background: rgba(0, 0, 0, 0.4);
        }
        
        .settings-card-body button {
            padding: 0.75rem 1.5rem;
            background: var(--vlc-orange);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .settings-card-body button:hover {
            background: #e65100;
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 4px 12px rgba(255, 111, 0, 0.3);
        }
        
        .settings-card-body .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .settings-card-body .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }
        
        .settings-card-body .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .settings-card-body .radio-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .settings-card-body .radio-option:hover {
            background: rgba(168, 85, 247, 0.1);
        }
        
        .settings-card-body .radio-option input[type="radio"] {
            width: auto;
            cursor: pointer;
        }
        
        /* Responsive adjustments for New UI */
        @media (max-width: 1024px) {
            body.ui-new .app-sidebar {
                width: 200px;
            }
            
            body.ui-new main {
                padding: 1.5rem 1.5rem;
            }
        }
        
        @media (max-width: 768px) {
            body.ui-new .app-sidebar {
                position: fixed;
                left: -240px;
                top: 0;
                bottom: 0;
                z-index: 1000;
                transition: left 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }
            
            body.ui-new .app-sidebar.mobile-open {
                left: 0;
            }
            
            body.ui-new .search-container {
                flex: 1;
            }
        }
        
        /* Custom Scrollbar for IPTV Category Select Dropdown */
        #xtream-category-select {
            /* Enhanced dropdown styling */
            cursor: pointer;
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-height: 300px;
            overflow-y: auto;
        }
        
        #xtream-category-select:hover {
            border-color: rgba(59, 130, 246, 0.5) !important;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        #xtream-category-select:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.7) !important;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        /* Custom scrollbar for the dropdown options */
        #xtream-category-select::-webkit-scrollbar {
            width: 12px;
        }
        
        #xtream-category-select::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.05);
        }
        
        #xtream-category-select::-webkit-scrollbar-thumb {
            background: #6b7280;
            border-radius: 10px;
            border: 2px solid rgba(0, 0, 0, 0.3);
            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        #xtream-category-select::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
            border-color: rgba(0, 0, 0, 0.5);
        }
        
        #xtream-category-select::-webkit-scrollbar-thumb:active {
            background: #4b5563;
        }
        
        /* Dropdown options styling */
        #xtream-category-select option {
            background: #1b1b1b;
            color: #fff;
            padding: 0.5rem;
            transition: background 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        #xtream-category-select option:hover {
            background: rgba(59, 130, 246, 0.2);
        }
        
        #xtream-category-select option:checked {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: #fff;
            font-weight: 600;
        }

        /* Reader Fullscreen Mode */
        body.reader-fullscreen-mode .custom-title-bar,
        body.reader-fullscreen-mode header,
        body.reader-fullscreen-mode .app-sidebar,
        body.reader-fullscreen-mode .sidebar-toggle-btn {
            display: none !important;
        }
        
        body.reader-fullscreen-mode.ui-new:not(.platform-darwin) {
            padding-top: 0 !important;
        }
        
        body.reader-fullscreen-mode .app-main {
            margin: 0 !important;
            height: 100vh !important;
            width: 100vw !important;
        }
        
        body.reader-fullscreen-mode main {
            padding: 0 !important;
            margin: 0 !important;
            max-width: none !important;
        }

        /* Comics specific fullscreen overrides */
        body.reader-fullscreen-mode #comics-page .page-header-enhanced,
        body.reader-fullscreen-mode #comics-filter-container,
        body.reader-fullscreen-mode #comics-back-btn,
        body.reader-fullscreen-mode #comics-browse-btn {
            display: none !important;
        }
        
        body.reader-fullscreen-mode #comics-search-container {
            margin-top: 1rem !important;
            margin-bottom: 1rem !important;
        }

        body.reader-fullscreen-mode #mangaReaderBack {
            display: none !important;
        }
    </style>
    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
</head>
<body class="ui-new">
<!-- Custom Title Bar -->
<div class="custom-title-bar" id="customTitleBar">
    <div class="title-bar-left">
        <i class="fas fa-play-circle" style="color: var(--vlc-orange);"></i>
        <span class="title-bar-title">PlayTorrio</span>
    </div>
    <div class="title-bar-controls">
        <button class="title-bar-btn" id="minimizeBtn" title="Minimize">
            <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 12 12" fill="currentColor"><rect x="1" y="5.5" width="10" height="1"/></svg>
        </button>
        <button class="title-bar-btn" id="maximizeBtn" title="Maximize">
            <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1"><rect x="2" y="2" width="8" height="8"/></svg>
        </button>
        <button class="title-bar-btn title-bar-close" id="closeBtn" title="Close">
            <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1"><path d="M2 2 L10 10 M10 2 L2 10"/></svg>
        </button>
    </div>
</div>
<!-- API Setup Modal - REMOVED -->

<!-- Donate modal removed -->

<!-- Discord Modal -->
<div class="discord-modal" id="discordModal">
    <div class="discord-content">
        <button class="discord-close" id="discordClose">
            <i class="fas fa-times"></i>
        </button>
        <h2 class="discord-title">
            <svg class="discord-logo" viewBox="0 0 71 55" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g clip-path="url(#clip0)">
                    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="white"/>
                </g>
                <defs>
                    <clipPath id="clip0">
                        <rect width="71" height="55" fill="white"/>
                    </clipPath>
                </defs>
            </svg>
            Join the Discord
        </h2>
        <div class="discord-message">
            <p>Suggest features, report bugs, be a part of the community, and help me make a better app.</p>
        </div>
        <div style="display:flex; gap:0.75rem; flex-wrap: wrap;">
            <button class="discord-join-btn" id="discordJoinBtn" style="flex:1;">
                <i class="fab fa-discord"></i>
                Join Discord
            </button>
            <button class="discord-join-btn" id="discordDontShowBtn" style="background: rgba(255,255,255,0.12); flex:1; color:#fff; text-shadow:0 0 4px rgba(0,0,0,0.6); font-weight:600;">
                <i class="fas fa-eye-slash"></i>
                Don't show again
            </button>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div class="settings-modal" id="settingsModal">
    <div class="settings-content">

        <div class="settings-header">
            <h2 class="settings-title">
                <i class="fas fa-cog"></i>
                Settings
            </h2>
            <button class="settings-close" id="settingsClose">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        

        <div class="settings-section">
            <h3>Jackett API Configuration</h3>
            <div class="current-api-key" id="currentApiKey">
                No API key configured
            </div>
            <div class="api-input-group">
                <label for="newApiKey">New API Key:</label>
                <input type="text" id="newApiKey" class="api-input" placeholder="Enter new Jackett API key..." />
            </div>
            <div class="api-input-group" style="margin-top:1rem;">
                <label for="jackettUrl">Jackett Base URL:</label>
                <input type="text" id="jackettUrl" class="api-input" placeholder="http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab" />
                <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem;">Default: http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab</small>
            </div>
        </div>

        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>Streaming Mode</h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                    <input type="checkbox" id="useStreamingServersToggle" />
                    <span>Use Streaming Servers instead of Torrents</span>
                </label>
                <div style="margin-top:0.5rem; color:#10b981; font-size:0.9rem;">
                    Stream directly from web servers (faster startup, no downloads)
                </div>
                <div style="margin-top:0.25rem; color:#9ca3af; font-size:0.85rem;">
                    When enabled, movies/shows will stream from online servers instead of torrent files
                </div>
            </div>
        </div>

        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>Cache & Storage</h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <div class="api-input-group">
                    <label for="cacheLocation">Cache Location:</label>
                    <div style="display:flex; gap:0.5rem; align-items:center;">
                        <input type="text" id="cacheLocation" class="api-input" readonly placeholder="System default temp folder" style="flex:1;" />
                        <button class="api-btn" id="selectCacheBtn" style="background:#0d6efd; color:#fff; white-space:nowrap;">
                            <i class="fas fa-folder-open"></i> Browse
                        </button>
                    </div>
                    <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem;">
                        <i class="fas fa-info-circle"></i> Location where WebTorrent streams and subtitles are cached
                    </small>
                </div>
            </div>
        </div>

        <div class="settings-section" id="debridSection" style="margin-top:1.25rem;">
            <h3>Debrid (Cloud Cache) </h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05); display:flex; flex-direction: column; gap:0.75rem;">
                <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                    <input type="checkbox" id="useDebridToggle" />
                    <span>Use Debrid</span>
                </label>
                <div style="display:flex; gap:0.75rem; align-items:center; flex-wrap: wrap;">
                    <label for="debridProvider">Provider:</label>
                    <select id="debridProvider" class="api-input" style="min-width:220px; max-width:260px;">
                        <option value="realdebrid">Real-Debrid</option>
                        <option value="alldebrid">AllDebrid</option>
                        <option value="torbox">TorBox</option>
                        <option value="premiumize">Premiumize</option>
                    </select>
                    <span id="debridStatus" style="font-size:0.9rem; opacity:0.85;">Not logged in</span>
                </div>
                <div class="api-input-group" id="rdClientIdGroup">
                    <label for="rdClientId">Real-Debrid Client ID (device flow):</label>
                    <input type="text" id="rdClientId" class="api-input" placeholder="Enter your RD Client ID (e.g., XXXXXXXXXXXXX)" />
                </div>
                <div id="rdButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items:center;">
                    <button class="api-btn" id="rdDeviceLogin" style="background:#198754; color:#fff;">
                        <i class="fas fa-sign-in-alt"></i> Login with Real-Debrid
                    </button>
                    <small style="opacity:0.85;">No password needed. Authenticate on real-debrid.com using a short code.</small>
                </div>
            </div>
        </div>

        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>User Interface</h3>
            <div style="margin-top:0.5rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <div style="margin-bottom:1rem; padding-bottom:0.75rem; border-bottom:1px solid rgba(255,255,255,0.1);">
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="checkbox" id="fullscreenToggle" />
                        <span><i class="fas fa-expand-arrows-alt" style="margin-right:0.25rem; color:var(--vlc-orange);"></i><strong>Fullscreen Mode</strong></span>
                    </label>
                    <div style="margin-top:0.25rem; color:var(--secondary); font-size:0.85rem; margin-left:1.85rem;">
                        <i class="fas fa-info-circle"></i> Toggle between fullscreen and windowed mode
                    </div>
                </div>
                
                <div style="display:flex; flex-direction:column; gap:0.75rem;">
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="radio" name="uiMode" value="new" id="uiModeNew" checked />
                        <span><strong>NEW UI</strong> - Modern app-like interface</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:0.6rem; cursor:pointer;">
                        <input type="radio" name="uiMode" value="old" id="uiModeOld" />
                        <span><strong>OLD UI</strong> - Classic website layout</span>
                    </label>
                </div>
                <div style="margin-top:0.5rem; color:var(--secondary); font-size:0.9rem;">
                    <i class="fas fa-info-circle"></i> Changes will apply immediately after saving
                </div>
                
                <div style="margin-top:1.5rem; padding-top:1rem; border-top:1px solid rgba(255,255,255,0.1);">
                    <label style="display:block; margin-bottom:0.75rem; color:var(--light); font-weight:600; font-size:1rem;">
                        <i class="fas fa-palette" style="margin-right:0.5rem; color:var(--vlc-orange);"></i>
                        Color Theme
                    </label>
                    <select id="themeSelector" class="api-input" style="width:100%; max-width:350px; padding:0.75rem 1rem; background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.2); border-radius:10px; color:var(--light); font-size:0.95rem;">
                        <option value="default">Default (Purple Dream)</option>
                        <option value="green-forest">Green Forest</option>
                        <option value="cyberpunk-neon">Cyberpunk Neon</option>
                        <option value="ocean-breeze">Ocean Breeze</option>
                        <option value="cherry-blossom">Cherry Blossom</option>
                        <option value="midnight-dark">Midnight Dark</option>
                        <option value="sunset-orange">Sunset Orange</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Nuvio Febbox Token Section -->
        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>
                <i class="fas fa-stream" style="color: #667eea; margin-right: 0.5rem;"></i>
                Nuvio Configuration
            </h3>
            <div style="padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                    <i class="fas fa-info-circle"></i>
                    Configure your Febbox token for Nuvio streaming (ShowBox). A default token is provided, but you can use your own.
                </div>

                <label for="febboxTokenInput" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">
                    Febbox JWT Token (Optional)
                </label>
                <input 
                    type="text" 
                    id="febboxTokenInput" 
                    placeholder="Leave empty to use default token or paste your Febbox JWT token here"
                    style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--light); font-size: 0.95rem; font-family: monospace; margin-bottom: 1rem;"
                />

                <button id="saveFebboxToken" class="btn" style="width: 100%;">
                    <i class="fas fa-save"></i> Save Token
                </button>

                <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(103, 126, 234, 0.1); border-left: 3px solid var(--secondary); border-radius: 4px; font-size: 0.85rem;">
                    <i class="fas fa-check-circle" style="color: var(--secondary);"></i> Default token is active. You can continue using Nuvio without adding your own token.
                </div>

                <!-- NodeMPV Player Toggle (Windows Only) -->
                <div id="nodempvSectionMain" style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255,255,255,0.1); display: none;">
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem;">
                        <div style="flex: 1; min-width: 200px;">
                            <label style="font-weight: 500; display: flex; align-items: center; gap: 0.5rem;">
                                <i class="fas fa-play-circle" style="color: #ff6b35;"></i>
                                Use MPV Player
                            </label>
                            <div style="font-size: 0.85rem; color: var(--gray); margin-top: 0.25rem;">
                                Better codec support (DTS, TrueHD), hardware acceleration. Requires <a href="https://mpv.io/installation/" target="_blank" style="color: #ff6b35;">MPV</a> installed.
                            </div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useNodeMPVToggleMain">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>



        <!-- Trakt Integration Section -->
        <div class="settings-section" style="margin-top:1.25rem;">
            <h3>
                <i class="fas fa-tv" style="color: #ed1c24; margin-right: 0.5rem;"></i>
                Trakt Integration
            </h3>
            <div style="padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                    <i class="fas fa-info-circle"></i>
                    Sync your watch history, progress, and manage your watchlist with Trakt.tv
                </div>
                
                <div id="traktNotConnected" style="display: block;">
                    <div style="margin-bottom: 1rem;">
                        <span id="traktStatus" style="color: #dc3545; font-weight: 500;">
                            <i class="fas fa-times-circle"></i> Not connected
                        </span>
                    </div>
                    <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                        <button class="api-btn" id="traktLogin" style="background: #ed1c24; color: #fff;">
                            <i class="fas fa-sign-in-alt"></i> Connect to Trakt
                        </button>
                        <small style="opacity: 0.85;">Authenticate with your Trakt.tv account using a secure device code</small>
                    </div>
                </div>

                <div id="traktConnected" style="display: none;">
                    <div style="margin-bottom: 1rem;">
                        <span id="traktConnectedStatus" style="color: #198754; font-weight: 500;">
                            <i class="fas fa-check-circle"></i> Connected as <span id="traktUsername">User</span>
                        </span>
                    </div>
                    <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; margin-bottom: 1rem;">
                        <button class="api-btn" id="traktViewWatchlist" style="background: #0d6efd; color: #fff;">
                            <i class="fas fa-list"></i> View Watchlist
                        </button>
                        <button class="api-btn" id="traktViewHistory" style="background: #6f42c1; color: #fff;">
                            <i class="fas fa-history"></i> View History
                        </button>
                        <button class="api-btn" id="traktViewStats" style="background: #17a2b8; color: #fff;">
                            <i class="fas fa-chart-bar"></i> View Stats
                        </button>
                    </div>
                    <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                        <button class="api-btn api-btn-secondary" id="traktDisconnect">
                            <i class="fas fa-sign-out-alt"></i> Disconnect
                        </button>
                    </div>
                </div>

                <div id="traktCodePanel" style="display: none; margin-top: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
                        <div>Device Code:</div>
                        <div id="traktUserCode" style="font-family: monospace; font-weight: 800; background: rgba(255,255,255,0.1); padding: 0.25rem 0.5rem; border-radius: 6px;">----</div>
                        <button class="api-btn" id="traktCopyCode" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                        <div>Authorize at:</div>
                        <a id="traktVerifyUrl" href="#" target="_blank" style="color: #0d6efd; text-decoration: underline;">https://trakt.tv/activate</a>
                        <button class="api-btn" id="traktOpenVerify" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                            <i class="fas fa-external-link-alt"></i> Open
                        </button>
                        <span id="traktLoginStatus" style="margin-left: auto; font-size: 0.9rem; opacity: 0.9;">Waiting for authorization</span>
                        <button class="api-btn api-btn-secondary" id="traktCancelLogin">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </div>

                <div id="traktSettings" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="margin-bottom: 0.75rem; color: var(--text-primary);">Scrobbling Settings</h4>
                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                        <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                            <input type="checkbox" id="traktAutoScrobble" checked />
                            <span>Automatically track what I watch</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                            <input type="checkbox" id="traktScrobbleProgress" checked />
                            <span>Sync watch progress</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                            <input type="checkbox" id="traktSyncWatchlist" checked />
                            <span>Show Trakt watchlist items in search</span>
                        </label>
                    </div>
                    <div style="margin-top: 0.5rem; color: var(--secondary); font-size: 0.85rem;">
                        <i class="fas fa-info-circle"></i> Your viewing activity will automatically sync to Trakt.tv
                    </div>
                </div>
            </div>
        </div>
        
        <div class="settings-buttons">
            <button class="api-btn api-btn-secondary" id="cancelSettings">
                <i class="fas fa-times"></i>
                Cancel
            </button>
            <button class="api-btn api-btn-primary" id="saveSettings">
                <i class="fas fa-save"></i>
                Save Changes
            </button>
        </div>

    </div>
</div>


<!-- Floating Navigation Arrow (Old UI Only, Home Page Only) -->
<div class="floating-nav-container" id="floatingNavContainer">
    <button class="floating-nav-btn" id="floatingNavBtn">
        <i class="fas fa-chevron-up" id="floatingNavIcon"></i>
    </button>
    <div class="floating-nav-menu" id="floatingNavMenu">
        <div class="floating-nav-item" data-action="settings">
            <i class="fas fa-cog"></i>
            <span>Settings</span>
        </div>
        <div class="floating-nav-item" data-action="home">
            <i class="fas fa-home"></i>
            <span>Home</span>
        </div>
        <div class="floating-nav-item" data-action="genres">
            <i class="fas fa-layer-group"></i>
            <span>Genres</span>
        </div>
        <div class="floating-nav-item" data-action="my-list">
            <i class="fas fa-list"></i>
            <span>My List</span>
        </div>
        <div class="floating-nav-item" data-action="done-watching">
            <i class="fas fa-check-double"></i>
            <span>Done Watching</span>
        </div>
        <div class="floating-nav-item" data-action="trakt">
            <i class="fas fa-tv"></i>
            <span>Trakt</span>
        </div>
        <div class="floating-nav-item" data-action="livetv">
            <i class="fas fa-broadcast-tower"></i>
            <span>Live TV</span>
        </div>
        <div class="floating-nav-item" data-action="iptv">
            <i class="fas fa-tv"></i>
            <span>IPTV</span>
        </div>
        <div class="floating-nav-item" data-action="books">
            <i class="fas fa-book"></i>
            <span>Books</span>
        </div>
        <div class="floating-nav-item" data-action="audiobooks">
            <i class="fas fa-headphones"></i>
            <span>AudioBooks</span>
        </div>
        <div class="floating-nav-item" data-action="booktorrio">
            <i class="fas fa-book-open"></i>
            <span>BookTorrio</span>
        </div>
        <div class="floating-nav-item" data-action="anime">
            <i class="fas fa-dragon"></i>
            <span>Anime</span>
        </div>
        <div class="floating-nav-item" data-action="comics">
            <i class="fas fa-mask"></i>
            <span>Comics</span>
        </div>
        <div class="floating-nav-item" data-action="manga">
            <i class="fas fa-book-dead"></i>
            <span>Manga</span>
        </div>
        <div class="floating-nav-item" data-action="music">
            <i class="fas fa-music"></i>
            <span>Music</span>
        </div>
        <div class="floating-nav-item" data-action="games-downloader">
            <i class="fas fa-download"></i>
            <span>Games Downloader</span>
        </div>
        <div class="floating-nav-item" data-action="minigames">
            <i class="fas fa-gamepad"></i>
            <span>MiniGames</span>
        </div>
        <div class="floating-nav-item" data-action="downloader">
            <i class="fas fa-download"></i>
            <span>Media Downloader</span>
        </div>
        <div class="floating-nav-item" data-action="trakt">
            <i class="fab fa-trakt"></i>
            <span>Trakt</span>
        </div>
        <a href="casino.html" class="floating-nav-item acebet-nav-item" id="acebet-floating-btn" style="color: #10b981; border: 1px solid rgba(16, 185, 129, 0.3); position: relative; padding-right: 28px;">
            <div class="acebet-nav-particles">
                <span style="position:absolute;width:3px;height:3px;background:#10b981;border-radius:50%;top:20%;left:10%;animation:acebet-float 2s ease-in-out infinite;"></span>
                <span style="position:absolute;width:3px;height:3px;background:#10b981;border-radius:50%;top:60%;right:15%;animation:acebet-float 2s ease-in-out infinite 0.5s;"></span>
            </div>
            <span style="font-weight:bold;font-size:1.1rem;"></span>
            <span>Ace Bet</span>
            <button class="acebet-floating-close" onclick="event.preventDefault(); event.stopPropagation(); hideSponsor();" style="position:absolute; right:6px; top:50%; transform:translateY(-50%); width:16px; height:16px; background:#dc3545; border:none; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10; padding:0; font-size:10px; color:white; line-height:1;">&times;</button>
        </a>
    </div>
</div>

<!-- MPV Install Helper Modal removed -->

<!-- App Container for New UI -->
<div class="app-container">
    <!-- Sidebar Navigation (New UI Only) -->
    <aside class="app-sidebar" id="appSidebar">
        <div class="sidebar-logo" id="sidebarLogo" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; align-items: center; gap: 0.75rem;">
                <i class="fas fa-play-circle"></i>
                <div><span style="color: var(--vlc-orange);">Play</span>Torrio</div>
            </div>
            <button class="sidebar-close-btn" id="sidebarCloseBtn" title="Hide Sidebar" style="background: transparent; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 0.5rem; transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); border-radius: 6px;">
                <i class="fas fa-times" style="font-size: 1.2rem;"></i>
            </button>
        </div>
        
        <div class="sidebar-divider"></div>
        
        <nav class="sidebar-nav">
            <div class="nav-section-title">DISCOVER</div>
            <div class="nav-item active" data-page="home">
                <i class="fas fa-home"></i>
                <span>Home</span>
                <span class="nav-badge">New</span>
            </div>
            <div class="nav-item" data-page="genres">
                <i class="fas fa-layer-group"></i>
                <span>Genres</span>
            </div>
            <div class="nav-item" id="customMagnetBtn" onclick="showCustomMagnetModal(); event.stopPropagation(); event.preventDefault(); return false;">
                <i class="fas fa-magnet"></i>
                <span>Play Magnet</span>
            </div>
            <div class="nav-item" data-page="my-list">
                <i class="fas fa-heart"></i>
                <span>My List</span>
            </div>
            <div class="nav-item" data-page="done-watching">
                <i class="fas fa-check-circle"></i>
                <span>Done Watching</span>
            </div>
            
            <div class="nav-section-title">LIBRARY</div>
            
            <!-- Ace Bet Sponsor Button -->
            <div class="nav-item acebet-nav-item" id="acebet-nav-btn" onclick="window.location.href='casino.html';" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); border: 1px solid rgba(16, 185, 129, 0.3); position: relative; overflow: visible; padding-right: 32px;">
                <div class="acebet-nav-particles">
                    <span class="acebet-particle-nav"></span>
                    <span class="acebet-particle-nav"></span>
                    <span class="acebet-particle-nav"></span>
                </div>
                <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #10b981, #059669); border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: 900; color: white; font-size: 14px;">A</div>
                <span style="color: #10b981; font-weight: 600;">Ace Bet</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #10b981, #059669);">Sponsor</span>
                <button id="acebet-close-btn" onclick="event.stopPropagation(); hideSponsor();" style="position:absolute; right:8px; top:50%; transform:translateY(-50%); width:18px; height:18px; background:#dc3545; border:none; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10; padding:0; font-size:10px; color:white; line-height:1;">&times;</button>
            </div>
            
            <div class="nav-item" data-page="trakt">
                <i class="fas fa-tv" style="color: #ed1c24;"></i>
                <span>Trakt</span>
                <span class="nav-badge" style="background: #ed1c24;">Sync</span>
            </div>
            <div class="nav-item" data-page="livetv">
                <i class="fas fa-broadcast-tower" style="color: #10b981;"></i>
                <span>Live TV</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #10b981, #059669);">Live</span>
            </div>
            <div class="nav-item" data-page="iptv">
                <i class="fas fa-tv" style="color: #3b82f6;"></i>
                <span>IPTV</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">M3U8</span>
            </div>
            <div class="nav-item" data-page="books">
                <i class="fas fa-book" style="color: #f59e0b;"></i>
                <span>Books</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #f59e0b, #d97706);">Z-Lib</span>
            </div>
            <div class="nav-item" data-page="audiobooks">
                <i class="fas fa-headphones" style="color: #8b5cf6;"></i>
                <span>AudioBooks</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed);">Audio</span>
            </div>
            <div class="nav-item" data-page="booktorrio">
                <i class="fas fa-book-open" style="color: #06b6d4;"></i>
                <span>BookTorrio</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #06b6d4, #0891b2);">EPUB</span>
            </div>
            <div class="nav-item" data-page="anime">
                <i class="fas fa-dragon" style="color: #3b82f6;"></i>
                <span>Anime</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">Nyaa</span>
            </div>

            <div class="nav-item" data-page="comics">
                <i class="fas fa-mask" style="color: #f97316;"></i>
                <span>Comics</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #f97316, #ea580c);">ReadComics</span>
            </div>
            <div class="nav-item" data-page="manga">
                <i class="fas fa-book-reader" style="color: #ec4899;"></i>
                <span>Manga</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #ec4899, #db2777);">Otaku</span>
            </div>
            <div class="nav-item" data-page="music">
                <i class="fas fa-music" style="color: #ec4899;"></i>
                <span>Music</span>
                <!-- Updated badge to reflect new music provider -->
                <span class="nav-badge" style="background: linear-gradient(135deg, #ec4899, #db2777);">Unlimited</span>
            </div>
            <div class="nav-item" data-page="games-downloader">
                <i class="fas fa-download" style="color: #8b5cf6;"></i>
                <span>Games Downloader</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed);">PC</span>
            </div>
            <div class="nav-item" data-page="minigames">
                <i class="fas fa-gamepad" style="color: #10b981;"></i>
                <span>MiniGames</span>
                <span class="nav-badge" style="background: linear-gradient(135deg, #10b981, #059669);">Play</span>
            </div>
            <div class="nav-item" data-page="downloader">
                <i class="fas fa-download" style="color: #a855f7;"></i>
                <span>Media Downloader</span>
            </div>
            <div class="nav-item" id="sidebarClearCache">
                <i class="fas fa-trash"></i>
                <span>Clear Cache</span>
            </div>
        </nav>
        
        <!-- Quick Actions -->
        <div class="sidebar-quick-actions">
            <div class="quick-action-title">QUICK ACTIONS</div>
            <button class="quick-action-btn" id="quickRefresh">
                <i class="fas fa-sync-alt"></i>
                <span>Refresh</span>
            </button>
        </div>
        
        <div class="sidebar-footer">
            <div class="sidebar-user-info">
                <i class="fas fa-user-circle"></i>
                <span id="windowsUsername">Local User</span>
            </div>
            <button class="btn btn-primary" id="sidebarSettings" style="width: 100%; margin-top: 0.5rem;">
                <i class="fas fa-cog"></i> Settings
            </button>
        </div>
    </aside>
    
    <!-- Main App Content -->
    <div class="app-main">
        <!-- Header -->
        <header>
        <div class="header-container">
        <a class="logo" href="http://localhost:6987">
        <i class="fas fa-play-circle"></i>
        <span>Play</span> Torrio
                    </a>
        <div class="search-container" style="display:flex; align-items:center; gap:0.5rem;">
            <select id="searchSourceSelect" class="modal-select" style="max-width: 120px; padding: 0.5rem; background: rgba(255,255,255,0.06); border-radius: 20px; border: 1px solid rgba(168, 85, 247, 0.3); height: 42px;">
                <option value="tmdb">TMDB</option>
            </select>
            <div style="position:relative; flex:1;">
                <i class="fas fa-search search-icon"></i>
                <input id="searchInput" placeholder="Search for movies, shows, anime..." type="text"/>
            </div>
        </div>
        <div class="user-actions">
        <!-- Connection Status (NEW UI only) -->
        <div class="connection-status">
            <i class="fas fa-circle"></i>
            <span>Connected</span>
        </div>
        <button class="btn btn-outline" id="doneWatchingBtn">
            <i class="fas fa-check-circle"></i> <span>Done Watching</span>
        </button>
        <button class="btn btn-outline" id="clearCacheBtn">
            <i class="fas fa-trash"></i> <span>Clear Cache</span>
        </button>
    <!-- Donate button removed -->
        <button class="btn btn-outline" id="discordBtn" title="Join Discord Community">
            <i class="fab fa-discord"></i> <span>Discord</span>
        </button>
        <button class="btn btn-outline" id="genresBtn">
            <i class="fas fa-layer-group"></i> <span>Genres</span>
        </button>
        <button class="btn btn-outline" id="myListBtn">
            <i class="fas fa-heart"></i> <span>My List</span>
        </button>
        <button class="btn btn-primary" id="donateBtn" title="Support development" style="margin-left: 0.5rem;">
            <i class="fas fa-heart"></i> <span>Donate</span>
        </button>
        <!-- Install MPV button removed -->
        </div>
        </div>
        </header>

        <!-- Sidebar Toggle Button (shows when sidebar is hidden) -->
        <button class="sidebar-toggle-btn" id="sidebarToggleBtn" title="Show Sidebar">
            <i class="fas fa-bars"></i>
        </button>

<!-- Main Content -->
<main>
    <!-- Home Page -->
    <div id="homePage">
        <!-- Hero Section (New UI Only) -->
        <div class="hero-section" id="heroSection" style="display: none;">
            <img class="hero-backdrop" id="heroBackdrop" src="" alt="">
            <div class="hero-gradient"></div>
            <div class="hero-content">
                <h1 class="hero-title" id="heroTitle"></h1>
                <div class="hero-meta">
                    <div class="hero-rating" id="heroRating" style="display: none;">
                        <i class="fas fa-star"></i>
                        <span id="heroRatingValue"></span>
                    </div>
                    <span class="hero-year" id="heroYear"></span>
                    <span class="hero-runtime" id="heroRuntime" style="display: none;"></span>
                </div>
                <p class="hero-overview" id="heroOverview"></p>
                <div class="hero-buttons">
                    <button class="hero-btn hero-btn-primary" id="heroPlayBtn">
                        <i class="fas fa-play"></i>
                        Watch Now
                    </button>
                    <button class="hero-btn hero-btn-secondary" id="heroInfoBtn">
                        <i class="fas fa-info-circle"></i>
                        More Info
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Back to Home Button (for search results) -->
        <div id="backToHomeBtn" style="display: none; margin-bottom: 2rem;">
            <button style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem 2rem; background: linear-gradient(135deg, var(--vlc-orange) 0%, #ff8c42 100%); border: none; border-radius: 12px; color: white; font-size: 1.1rem; font-weight: 600; cursor: pointer; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); box-shadow: 0 4px 15px rgba(255, 111, 0, 0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255, 111, 0, 0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255, 111, 0, 0.3)'">
                <i class="fas fa-arrow-left" style="font-size: 1.2rem;"></i>
                <span>Back to Home</span>
            </button>
        </div>
        
        <div class="categories">
            <div class="category active" data-category="all">
                <i class="fas fa-th"></i> All
            </div>
            <div class="category" data-category="movie">
                <i class="fas fa-film"></i> Movies
            </div>
            <div class="category" data-category="tv">
                <i class="fas fa-tv"></i> TV Shows
            </div>
        </div>
        
        <!-- Content Sliders (New UI Only) -->
        <div id="slidersContainer" style="display: none;">
            <!-- Continue Watching Slider (dynamic - only shows if items exist) -->
            <div class="slider-section" id="continueWatchingSection" style="display: none;">
                <div class="slider-header">
                    <h2 class="slider-title">
                        <i class="fas fa-clock"></i>
                        Continue Watching
                    </h2>
                    <div class="slider-nav">
                        <button class="slider-arrow slider-arrow-left" data-slider="continue">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <button class="slider-arrow slider-arrow-right" data-slider="continue">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div class="slider-container">
                    <div class="slider-track" id="continueWatchingSlider"></div>
                </div>
            </div>
            
            <!-- Trending Slider -->
            <div class="slider-section">
                <div class="slider-header">
                    <h2 class="slider-title">
                        <i class="fas fa-fire"></i>
                        Trending Now
                    </h2>
                    <div class="slider-nav">
                        <button class="slider-arrow slider-arrow-left" data-slider="trending">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <button class="slider-arrow slider-arrow-right" data-slider="trending">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div class="slider-container">
                    <div class="slider-track" id="trendingSlider"></div>
                </div>
            </div>
            
            <!-- Popular Movies Slider -->
            <div class="slider-section">
                <div class="slider-header">
                    <h2 class="slider-title">
                        <i class="fas fa-film"></i>
                        Popular Movies
                    </h2>
                    <div class="slider-nav">
                        <button class="slider-arrow slider-arrow-left" data-slider="popular">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <button class="slider-arrow slider-arrow-right" data-slider="popular">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div class="slider-container">
                    <div class="slider-track" id="popularSlider"></div>
                </div>
            </div>
            
            <!-- Top Rated Slider -->
            <div class="slider-section">
                <div class="slider-header">
                    <h2 class="slider-title">
                        <i class="fas fa-star"></i>
                        Top Rated
                    </h2>
                    <div class="slider-nav">
                        <button class="slider-arrow slider-arrow-left" data-slider="toprated">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <button class="slider-arrow slider-arrow-right" data-slider="toprated">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div class="slider-container">
                    <div class="slider-track" id="topratedSlider"></div>
                </div>
            </div>
            
            <!-- TV Shows Slider -->
            <div class="slider-section">
                <div class="slider-header">
                    <h2 class="slider-title">
                        <i class="fas fa-tv"></i>
                        Popular TV Shows
                    </h2>
                    <div class="slider-nav">
                        <button class="slider-arrow slider-arrow-left" data-slider="tvshows">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <button class="slider-arrow slider-arrow-right" data-slider="tvshows">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div class="slider-container">
                    <div class="slider-track" id="tvshowsSlider"></div>
                </div>
            </div>
        </div>
        
        <div id="addonCatalogsContainer" style="display: none; padding-bottom: 2rem;"></div>
        <div class="movies-grid" id="moviesGrid" style="content-visibility:auto; contain-intrinsic-size: 1000px 1000px;">
            <!-- Movie cards will be loaded here -->
        </div>
        <div class="loading" id="loadingIndicator">
            <i class="fas fa-spinner"></i> Loading more content...
        </div>
    </div>

    <!-- Music Page -->
    <div id="music-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-music" style="color: #ec4899;"></i> <span>Music</span>
                </h2>
                <!-- Updated subtitle to reference Spotify-based streaming -->
                <p class="page-subtitle">Search and stream music powered by Spotify</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="music-my-btn" title="Open My Music">
                    <i class="fas fa-heart"></i>
                    <span>My Music</span>
                </button>
                <button class="action-btn" id="music-my-albums-btn" title="Open My Albums">
                    <i class="fas fa-compact-disc"></i>
                    <span>My Albums</span>
                </button>
                <button class="action-btn" id="music-playlists-btn" title="Open Playlists">
                    <i class="fas fa-list"></i>
                    <span>Playlists</span>
                </button>
                <button class="action-btn" id="music-downloaded-btn" title="Open Downloaded Music">
                    <i class="fas fa-download"></i>
                    <span>Downloaded</span>
                </button>
                
            </div>
        </div>

        <div class="page-content">
            <!-- Search Section -->
            <div class="books-search-section">
                <div class="books-search-container">
                    <div class="books-search-bar">
                        <i class="fas fa-search books-search-icon"></i>
                        <input 
                            type="text" 
                            id="music-search-input" 
                            placeholder="Search for songs, artists, or albums..."
                            autocomplete="off"
                        />
                        <button id="music-search-btn" class="books-search-button">
                            <i class="fas fa-search"></i>
                            Search
                        </button>
                        <button id="music-album-search-btn" class="books-search-button" style="margin-left:0.5rem; background: linear-gradient(135deg, #38bdf8, #0ea5e9);">
                            <i class="fas fa-compact-disc"></i>
                            Albums
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div id="music-loading" class="books-loading" style="display: none;">
                <div class="books-loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                </div>
                <p>Searching music...</p>
            </div>

            <!-- Empty State -->
            <div id="music-empty" class="books-empty">
                <div class="books-empty-icon">
                    <i class="fas fa-music"></i>
                </div>
                <h3>Welcome to Music</h3>
                <p>Search for any song, artist, or album to get started.</p>
            </div>

            <!-- Results Section -->
            <div id="music-results" class="books-results" style="display: none;">
                <div class="books-results-header">
                    <h3 id="music-results-title">Search Results</h3>
                    <div id="music-results-count" class="books-results-count"></div>
                </div>
                <div id="music-results-grid" class="books-results-grid">
                    <!-- Results will be populated here -->
                </div>
            </div>

            <!-- Albums Results Section -->
            <div id="music-albums" class="books-results" style="display:none;">
                <div class="books-results-header">
                    <h3 id="music-albums-title"><i class="fas fa-compact-disc" style="color:#38bdf8"></i> Album Results</h3>
                    <div id="music-albums-count" class="books-results-count"></div>
                </div>
                <div id="music-albums-grid" class="books-results-grid"></div>
            </div>

            <!-- Album View (open a specific album) -->
            <div id="music-album-view" class="books-results" style="display:none;">
                <div class="books-results-header" style="align-items:center; gap:1rem; flex-wrap:wrap;">
                    <div style="display:flex; align-items:center; gap:0.75rem;">
                        <img id="album-view-cover" src="" alt="Album Cover" style="width:68px; height:68px; border-radius:10px; object-fit:cover; border:1px solid rgba(255,255,255,0.1);">
                        <div>
                            <h3 id="album-view-title" style="margin:0; display:flex; align-items:center; gap:0.5rem;"></h3>
                            <div id="album-view-meta" style="color:#9ca3af; font-size:0.9rem;"></div>
                        </div>
                    </div>
                    <button id="album-play-all-btn" class="action-btn" style="background: linear-gradient(135deg, #ec4899, #a855f7);">
                        <i class="fas fa-play"></i>
                        <span>Play All</span>
                    </button>
                    <button id="album-save-all-btn" class="action-btn" title="Save all tracks to a playlist">
                        <i class="fas fa-plus"></i>
                        <span>Save All</span>
                    </button>
                    <button id="album-shuffle-btn" class="action-btn" title="Shuffle and play this album">
                        <i class="fas fa-random"></i>
                        <span>Shuffle</span>
                    </button>
                    <button id="album-close-btn" class="playlist-close-btn" style="margin-left:auto;">
                        <i class="fas fa-times"></i>
                        <span>Close Album</span>
                    </button>
                </div>
                <div id="album-tracks" class="album-tracks-list" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
            </div>

            <!-- My Albums Section -->
            <div id="my-albums" class="books-results" style="display:none;">
                <div class="books-results-header">
                    <h3><i class="fas fa-compact-disc" style="color:#38bdf8"></i> My Albums</h3>
                    <div id="my-albums-count" class="books-results-count"></div>
                </div>
                <div id="my-albums-grid" class="books-results-grid"></div>
                <div id="my-albums-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-compact-disc"></i></div>
                    <h3>No saved albums yet</h3>
                    <p>Click the heart on any album to add it here.</p>
                </div>
            </div>

            <!-- My Music Section -->
            <div id="my-music" class="books-results" style="display: none;">
                <div class="books-results-header" style="align-items:center; gap:1rem;">
                    <h3><i class="fas fa-heart" style="color:#ec4899"></i> My Music</h3>
                    <div id="my-music-count" class="books-results-count"></div>
                    <button id="my-music-play-all-btn" class="action-btn" style="margin-left:auto; background: linear-gradient(135deg, #ec4899, #a855f7);">
                        <i class="fas fa-play"></i>
                        <span>Play All</span>
                    </button>
                    <button id="my-music-shuffle-btn" class="action-btn" title="Shuffle and play My Music">
                        <i class="fas fa-random"></i>
                        <span>Shuffle</span>
                    </button>
                </div>
                <div id="my-music-grid" class="books-results-grid"></div>
                <div id="my-music-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-heart"></i></div>
                    <h3>No saved tracks yet</h3>
                    <p>Click the heart on any track to add it here for quick access.</p>
                </div>
            </div>

            <!-- Playlists Section -->
            <div id="music-playlists" class="books-results" style="display: none;">
                <div class="books-results-header" style="gap: 1rem; align-items: center;">
                    <h3><i class="fas fa-list" style="color:#38bdf8"></i> Playlists</h3>
                    <div style="flex:1"></div>
                    <input id="playlist-name-input" placeholder="New playlist name" style="padding:0.5rem 0.75rem; border-radius:8px; background:var(--surface); border:1px solid var(--border); color:var(--light); width:220px;" />
                    <button class="action-btn" id="playlist-import-btn" title="Import playlist from JSON file"><i class="fas fa-file-import"></i><span>Import</span></button>
                    <button class="action-btn" id="playlist-create-btn"><i class="fas fa-plus"></i><span>Create</span></button>
                </div>
                <div id="playlists-list" class="books-results-grid"></div>
                <div id="playlists-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-list"></i></div>
                    <h3>No playlists yet</h3>
                    <p>Create a playlist to get started.</p>
                </div>
            </div>

            <!-- Downloaded Music Section -->
            <div id="music-downloaded" class="books-results" style="display: none;">
                <div class="books-results-header" style="align-items:center; gap:1rem;">
                    <h3><i class="fas fa-download" style="color:#10b981"></i> Downloaded Music</h3>
                    <div id="music-downloaded-count" class="books-results-count"></div>
                    <div style="flex:1"></div>
                    <button class="action-btn" id="downloaded-play-all-btn" style="background: linear-gradient(135deg, #ec4899, #a855f7); display:none;">
                        <i class="fas fa-play"></i><span>Play All</span>
                    </button>
                    <button class="action-btn" id="downloaded-shuffle-btn" title="Shuffle and play all downloaded tracks" style="display:none;">
                        <i class="fas fa-random"></i><span>Shuffle</span>
                    </button>
                </div>
                <div id="music-downloaded-grid" class="books-results-grid"></div>
                <div id="music-downloaded-empty" class="books-empty" style="display:none;">
                    <div class="books-empty-icon"><i class="fas fa-download"></i></div>
                    <h3>No downloaded tracks yet</h3>
                    <p>Download tracks to listen offline.</p>
                </div>
            </div>

            
        </div>
    </div>

    <!-- Download Progress Modal -->
    <div id="music-download-modal" class="books-reader-modal" style="display:none; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); align-items: center; justify-content: center; padding: 0.75rem;">
        <div class="books-reader-content" style="max-width:300px; width:90%; margin: 0 auto; border:2px solid rgba(16,185,129,0.4); border-radius:12px; overflow:hidden; box-shadow: 0 12px 36px rgba(0,0,0,0.55);">
            <div style="background: linear-gradient(135deg, rgba(16,185,129,0.15), rgba(5,150,105,0.15)); border-bottom: 1px solid rgba(16,185,129,0.2); padding: 0.6rem 0.85rem; display: flex; align-items: center; justify-content: space-between;">
                <div style="display:flex; align-items:center; gap:0.4rem;">
                    <i class="fas fa-download" style="color:#10b981; font-size:0.85rem;"></i>
                    <span style="font-size:0.85rem; font-weight:600; color:var(--light);">Downloading</span>
                </div>
                <div style="display:flex; gap:0.25rem;">
                    <button id="music-download-minimize-btn" style="background:none; border:none; color:#38bdf8; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(56,189,248,0.1)'" onmouseout="this.style.background='none'" title="Minimize">
                        <i class="fas fa-minus"></i>
                    </button>
                    <button id="music-download-cancel-btn" style="background:none; border:none; color:#ef4444; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.1)'" onmouseout="this.style.background='none'" title="Cancel">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div style="padding:0.85rem;">
                <div id="music-download-info" style="margin-bottom:0.6rem;">
                    <div id="music-download-song-name" style="font-weight:600; color:var(--light); margin-bottom:0.1rem; font-size:0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
                    <div id="music-download-artist-name" style="color:#10b981; font-size:0.75rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
                </div>
                <div style="width:100%; height:5px; background: rgba(16,185,129,0.15); border-radius:2.5px; overflow:hidden; border: 1px solid rgba(16,185,129,0.2);">
                    <div id="music-download-progress-fill" style="height:100%; width:0%; background: linear-gradient(90deg, #10b981, #059669, #10b981); background-size: 200% 100%; animation: shimmer 2.5s cubic-bezier(0.45, 0, 0.55, 1) infinite; transition: width 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);"></div>
                </div>
                <div id="music-download-status" style="margin-top:0.4rem; text-align:center; color:var(--secondary); font-size:0.75rem;"></div>
            </div>
        </div>
    </div>

    <!-- Minimized Download Progress (in notification area) -->
    <div id="music-download-minimized" style="display:none; position:fixed; bottom:20px; right:20px; background:rgba(26,26,46,0.95); border:2px solid rgba(16,185,129,0.4); border-radius:10px; padding:0.75rem 1rem; min-width:280px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); z-index:9999;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.5rem;">
            <div style="display:flex; align-items:center; gap:0.5rem;">
                <i class="fas fa-download" style="color:#10b981; font-size:0.9rem;"></i>
                <span style="font-size:0.85rem; font-weight:600; color:var(--light);">Downloading...</span>
            </div>
            <div style="display:flex; gap:0.25rem;">
                <button id="music-download-restore-btn" style="background:none; border:none; color:#38bdf8; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(56,189,248,0.1)'" onmouseout="this.style.background='none'" title="Restore">
                    <i class="fas fa-window-maximize"></i>
                </button>
                <button id="music-download-cancel-minimized-btn" style="background:none; border:none; color:#ef4444; cursor:pointer; padding:0.2rem 0.4rem; font-size:0.85rem; border-radius:4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.1)'" onmouseout="this.style.background='none'" title="Cancel">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
        <div id="music-download-minimized-info" style="margin-bottom:0.5rem;">
            <div id="music-download-minimized-song" style="font-weight:600; color:var(--light); font-size:0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
            <div id="music-download-minimized-artist" style="color:#10b981; font-size:0.75rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
        </div>
        <div style="width:100%; height:5px; background: rgba(16,185,129,0.15); border-radius:2.5px; overflow:hidden; border: 1px solid rgba(16,185,129,0.2);">
            <div id="music-download-minimized-progress" style="height:100%; width:0%; background: linear-gradient(90deg, #10b981, #059669, #10b981); background-size: 200% 100%; animation: shimmer 2.5s cubic-bezier(0.45, 0, 0.55, 1) infinite; transition: width 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);"></div>
        </div>
        <div id="music-download-minimized-status" style="margin-top:0.4rem; text-align:center; color:var(--secondary); font-size:0.75rem;"></div>
        <div id="music-download-queue-info" style="margin-top:0.5rem; padding-top:0.5rem; border-top:1px solid rgba(16,185,129,0.2); display:none;">
            <div style="font-size:0.75rem; color:var(--secondary); display:flex; align-items:center; justify-content:space-between;">
                <span><i class="fas fa-list" style="color:#10b981; margin-right:0.3rem;"></i>Queue:</span>
                <span id="music-download-queue-count" style="color:#10b981; font-weight:600;">0</span>
            </div>
        </div>
    </div>

    <!-- Music Player Modal (transparent overlay + custom controls) -->
    <div id="music-player-modal" class="books-reader-modal" style="display: none; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);">
        <div class="books-reader-content" style="border:2px solid #ec4899; border-radius: 16px; max-width:560px; width:90%;">
            <div class="books-reader-header">
                <button id="music-player-back" class="books-reader-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3 id="music-player-title">Now Playing</h3>
                <button id="music-player-minimize" class="books-reader-back-btn" style="margin-left: auto; margin-right: 0;">
                    <i class="fas fa-minus"></i>
                    Minimize
                </button>
            </div>
            <div class="books-reader-frame-container" style="display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 1.75rem; background: linear-gradient(135deg, rgba(26,26,46,0.95), rgba(22,33,62,0.95));">
                <img id="music-player-cover" src="" alt="Album Cover" style="width: 240px; height: 240px; object-fit: cover; border-radius: 12px; margin-bottom: 1rem; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);">
                <h2 id="music-player-song-title" style="color: var(--light); margin-bottom: 0.25rem; text-align: center; font-size:1.3rem;"></h2>
                <p id="music-player-artist" style="color: #ec4899; font-size: 1rem; margin-bottom: 1rem; text-align: center;"></p>
                
                <!-- Custom Controls -->
                <div style="width:100%; max-width:520px;">
                    <div class="audio-progress-bar" id="music-progress-bar" style="width:100%; height:6px; background: rgba(255,255,255,0.12); border-radius:3px; cursor:pointer; overflow:hidden;">
                        <div class="audio-progress-fill" id="music-progress-fill" style="height:100%; width:0%; background: linear-gradient(90deg, #ec4899, #a855f7);"></div>
                    </div>
                    <div class="audio-time-display" style="display:flex; justify-content:space-between; color:#9ca3af; font-size:0.85rem; margin-top:0.5rem;">
                        <span id="music-current-time">0:00</span>
                        <span id="music-total-time">0:00</span>
                    </div>
                    <div class="audio-controls-buttons" style="display:flex; justify-content:center; align-items:center; gap:1rem; margin-top:1rem; flex-wrap:wrap;">
                        <button class="audio-control-btn" id="music-prev-track-btn" title="Previous track" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:42px; height:42px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-step-backward"></i></button>
                        <button class="audio-control-btn" id="music-backward-btn" title="Back 10s" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:46px; height:46px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-backward"></i></button>
                        <button class="audio-control-btn" id="music-play-pause-btn" title="Play/Pause" style="background: linear-gradient(135deg, #ec4899, #a855f7); color:white; border:none; border-radius:50%; width:56px; height:56px; display:flex; align-items:center; justify-content:center; font-size:1.1rem;"><i class="fas fa-play"></i></button>
                        <button class="audio-control-btn" id="music-forward-btn" title="Forward 10s" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:46px; height:46px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-forward"></i></button>
                        <button class="audio-control-btn" id="music-next-track-btn" title="Next track" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:42px; height:42px; display:flex; align-items:center; justify-content:center;"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <div style="display:flex; justify-content:center; align-items:center; margin-top:0.5rem;">
                        <button id="music-autoplay-toggle" title="Autoplay next track" style="display:inline-flex; align-items:center; gap:0.4rem; padding:0.35rem 0.7rem; border-radius:999px; background: rgba(236,72,153,0.08); border:1px solid rgba(236,72,153,0.35); color:#ec4899; font-weight:600;">
                            <i class="fas fa-play-circle"></i>
                            <span>Autoplay Next</span>
                        </button>
                    </div>
                    <div class="audio-volume-control" style="display:flex; align-items:center; gap:0.75rem; margin-top:1rem;">
                        <i class="fas fa-volume-up" id="music-volume-icon" style="color:#ec4899;"></i>
                        <div class="audio-volume-slider" id="music-volume-slider" style="flex:1; height:4px; background: rgba(255,255,255,0.12); border-radius:2px; cursor:pointer;">
                            <div class="audio-volume-fill" id="music-volume-fill" style="height:100%; width:100%; background:#ec4899;"></div>
                        </div>
                    </div>
                </div>

                <audio id="music-player-audio" style="display:none;" crossorigin="anonymous" preload="metadata"></audio>
            </div>
        </div>
    </div>

    <!-- Mini Music Player (Notification Style) -->
    <div id="music-mini-player" style="display: none; position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 10000; background: linear-gradient(135deg, rgba(26,26,46,0.98), rgba(22,33,62,0.98)); border: 2px solid #ec4899; border-radius: 12px; padding: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,0.6); backdrop-filter: blur(10px); width: 340px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
            <h4 id="mini-player-song-title" style="color: var(--light); margin: 0; font-size: 0.95rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;"></h4>
            <button id="music-player-maximize" style="background: rgba(236,72,153,0.1); border: 1px solid rgba(236,72,153,0.3); color: #ec4899; border-radius: 6px; padding: 0.4rem 0.6rem; cursor: pointer; margin-left: 0.5rem;">
                <i class="fas fa-expand"></i>
            </button>
        </div>
        <p id="mini-player-artist" style="color: #ec4899; font-size: 0.85rem; margin: 0 0 0.75rem 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></p>
        
        <!-- Mini Progress Bar -->
        <div class="audio-progress-bar" id="mini-progress-bar" style="width:100%; height:4px; background: rgba(255,255,255,0.12); border-radius:2px; cursor:pointer; overflow:hidden; margin-bottom: 0.5rem;">
            <div class="audio-progress-fill" id="mini-progress-fill" style="height:100%; width:0%; background: linear-gradient(90deg, #ec4899, #a855f7);"></div>
        </div>
        
        <!-- Mini Time Display -->
        <div style="display:flex; justify-content:space-between; color:#9ca3af; font-size:0.75rem; margin-bottom:0.75rem;">
            <span id="mini-current-time">0:00</span>
            <span id="mini-total-time">0:00</span>
        </div>
        
        <!-- Mini Controls -->
        <div style="display:flex; justify-content:center; align-items:center; gap:0.75rem;">
            <button class="audio-control-btn" id="mini-prev-track-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-step-backward"></i></button>
            <button class="audio-control-btn" id="mini-backward-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-backward"></i></button>
            <button class="audio-control-btn" id="mini-play-pause-btn" style="background: linear-gradient(135deg, #ec4899, #a855f7); color:white; border:none; border-radius:50%; width:44px; height:44px; display:flex; align-items:center; justify-content:center; font-size:1rem;"><i class="fas fa-play"></i></button>
            <button class="audio-control-btn" id="mini-forward-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-forward"></i></button>
            <button class="audio-control-btn" id="mini-next-track-btn" style="background: rgba(236,72,153,0.1); border:1px solid rgba(236,72,153,0.3); color:#ec4899; border-radius:50%; width:36px; height:36px; display:flex; align-items:center; justify-content:center; font-size:0.85rem;"><i class="fas fa-step-forward"></i></button>
        </div>
    </div>

    <!-- Playlist Chooser Modal -->
    <div id="music-playlist-chooser" class="books-reader-modal" style="display:none; background: rgba(0,0,0,0.7); backdrop-filter: blur(6px);">
        <div class="books-reader-content" style="max-width:520px; width:90%; border:1px solid rgba(56,189,248,0.35); border-radius:14px; overflow:hidden;">
            <div class="books-reader-header">
                <button id="playlist-chooser-back" class="books-reader-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3>Add to Playlist</h3>
            </div>
            <div style="padding:1rem; display:flex; flex-direction:column; gap:0.75rem;">
                <div style="display:flex; gap:0.5rem;">
                    <input id="playlist-chooser-new-name" placeholder="New playlist name" style="flex:1; padding:0.6rem 0.8rem; border-radius:8px; background:var(--surface); border:1px solid var(--border); color:var(--light);" />
                    <button id="playlist-chooser-create" class="action-btn"><i class="fas fa-plus"></i><span>Create</span></button>
                </div>
                <div id="playlist-chooser-empty" class="books-empty" style="display:none; margin:0;">
                    <div class="books-empty-icon"><i class="fas fa-list"></i></div>
                    <h3>No playlists yet</h3>
                    <p>Create one above, then add your track.</p>
                </div>
                <div id="playlist-chooser-list" class="books-results-grid" style="grid-template-columns: 1fr; gap:0.5rem;"></div>
            </div>
        </div>
    </div>
    <!-- Genres Page -->
    <div id="genresPage" style="display: none;">
        <h2 class="section-title">
            <i class="fas fa-layer-group"></i> Genres
        </h2>
        <div class="genre-grid" id="genresGrid">
            <!-- Genre boxes will be loaded here -->
        </div>
        <div class="loading" id="genresLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading genres...
        </div>
    </div>

    <!-- Genre Details Page -->
    <div id="genreDetailsPage" style="display: none;">
        <div class="genre-header">
            <h2 class="section-title" id="genreHeaderTitle">
                <i class="fas fa-tags"></i> <span id="genreTitle">Genre</span>
            </h2>
            <div class="genre-controls">
                <button class="toggle-btn" id="toggleMovies">Movies</button>
                <button class="toggle-btn" id="toggleTV">TV Shows</button>
            </div>
        </div>
        <div class="genre-results-grid" id="genreResultsGrid">
            <!-- Genre media items will be loaded here -->
        </div>
        <div class="loading" id="genreLoadingIndicator" style="display:none;">
            <i class="fas fa-spinner"></i> Loading more...
        </div>
        <div class="loading" id="genreEmptyMessage" style="display:none;">
            <i class="fas fa-info-circle"></i> No results found for this selection.
        </div>
    </div>

    <!-- My List Page -->
    <div id="myListPage" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-heart"></i> <span>My List</span>
                </h2>
                <p class="page-subtitle">Your personal collection of movies and shows</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="clearMyListBtn">
                    <i class="fas fa-trash"></i>
                    <span>Clear All</span>
                </button>
            </div>
        </div>
        
        <div class="movies-grid" id="myListGrid">
            <!-- My list items will be loaded here -->
        </div>
        <div class="loading" id="myListLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading your list...
        </div>
        <div class="loading" id="myListEmpty" style="display:none;">
            <i class="fas fa-heart-broken"></i> Your list is empty. Start adding movies and shows!
        </div>
    </div>

    <!-- Done Watching Page -->
    <div id="doneWatchingPage" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-check-circle"></i> <span>Done Watching</span>
                </h2>
                <p class="page-subtitle">Movies and shows you've finished watching</p>
            </div>
            <div class="page-actions">
                <button class="action-btn" id="clearDoneWatchingBtn">
                    <i class="fas fa-trash"></i>
                    <span>Clear All</span>
                </button>
            </div>
        </div>
        
        <div class="movies-grid" id="doneWatchingGrid">
            <!-- Done watching items will be loaded here -->
        </div>
        <div class="loading" id="doneWatchingLoading" style="display:none;">
            <i class="fas fa-spinner"></i> Loading your completed items...
        </div>
        <div class="loading" id="doneWatchingEmpty" style="display:none;">
            <i class="fas fa-check-circle"></i> No completed items yet. Mark movies and shows as done when you finish watching!
        </div>
    </div>

    <!-- Trakt Page -->
    <div id="trakt-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-tv" style="color: #ed1c24;"></i> <span>Trakt Integration</span>
                </h2>
                <p class="page-subtitle">Sync your watching activity with Trakt.tv</p>
            </div>
        </div>

        <div class="trakt-container">
            <!-- Connection Status Card -->
            <div class="trakt-card trakt-status-card">
                <div class="trakt-card-header">
                    <h3><i class="fas fa-wifi"></i> Connection Status</h3>
                </div>
                <div class="trakt-card-body">
                    <div id="traktPageNotConnected" class="trakt-status-section">
                        <div id="traktStatusIndicator" class="trakt-status-indicator disconnected">
                            <i class="fas fa-times-circle"></i>
                            <span>Not Connected</span>
                        </div>
                        <p id="traktStatusDescription" class="trakt-description">
                            Connect your Trakt.tv account to automatically track your watching activity, 
                            sync progress, and manage your watchlist.
                        </p>
                        <div id="traktStatusActions">
                            <button id="traktAuthenticateBtn" class="trakt-btn trakt-btn-primary">
                                <i class="fas fa-link"></i>Connect to Trakt
                            </button>
                        </div>
                    </div>

                    <div id="traktPageConnected" class="trakt-status-section" style="display: none;">
                        <div class="trakt-status-indicator connected">
                            <i class="fas fa-check-circle"></i>
                            <span>Connected as <strong id="traktPageUsername">User</strong></span>
                        </div>
                        <p class="trakt-description">
                            Your account is connected and actively syncing. All your watching activity 
                            is being tracked automatically.
                        </p>
                        <div class="trakt-user-actions">
                            <button class="trakt-btn trakt-btn-secondary" id="traktPageDisconnect">
                                <i class="fas fa-sign-out-alt"></i> Disconnect
                            </button>
                            <button class="trakt-btn trakt-btn-info" id="traktPageRefresh">
                                <i class="fas fa-sync-alt"></i> Refresh Status
                            </button>
                            <button class="trakt-btn trakt-btn-primary" id="traktPageResyncLibrary">
                                <i class="fas fa-cloud-download-alt"></i> Re-sync Library
                            </button>
                            <button class="trakt-btn trakt-btn-info" id="traktPageStats">
                                <i class="fas fa-chart-bar"></i> View Statistics
                            </button>
                        </div>
                    </div>

                    <!-- Device Code Panel -->
                    <div id="traktDeviceCodePanel" class="trakt-device-code" style="display: none;">
                        <div class="trakt-code-header">
                            <h4><i class="fas fa-mobile-alt"></i> Device Authorization</h4>
                        </div>
                        <div class="trakt-code-content">
                            <div class="trakt-code-display">
                                <label>Device Code:</label>
                                <div class="trakt-code-value">
                                    <span id="traktPageUserCode">----</span>
                                    <button id="traktCopyCodeBtn" class="trakt-copy-btn">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <label>Visit URL:</label>
                                <div class="trakt-code-value">
                                    <span id="traktPageVerificationUrl">https://trakt.tv/activate</span>
                                </div>
                            </div>
                            <div class="trakt-verify-section">
                                <p>Visit the URL above and enter the device code</p>
                                <div class="trakt-verify-actions">
                                    <button id="traktOpenUrlBtn" class="trakt-btn trakt-btn-primary">
                                        <i class="fas fa-external-link-alt"></i> Open Trakt URL
                                    </button>
                                    <button id="traktVerifyDeviceBtn" class="trakt-btn trakt-btn-secondary">
                                        <i class="fas fa-check"></i> Verify Code
                                    </button>
                                </div>
                                <div id="traktDeviceCodeStatus" class="trakt-status-message">
                                    <span>Waiting for authorization...</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Quick Actions Grid -->
            <div class="trakt-actions-grid">
                <div class="trakt-card trakt-action-card" data-action="watchlist">
                    <div class="trakt-action-icon">
                        <i class="fas fa-list"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Your Watchlist</h4>
                        <p>View and manage your Trakt watchlist</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>

                <div class="trakt-card trakt-action-card" data-action="history">
                    <div class="trakt-action-icon">
                        <i class="fas fa-history"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Watch History</h4>
                        <p>See your recently watched content</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>

                <div class="trakt-card trakt-action-card" data-action="collection">
                    <div class="trakt-action-icon">
                        <i class="fas fa-collection"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Collection</h4>
                        <p>Your collected movies and shows</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>

                <div class="trakt-card trakt-action-card" data-action="ratings">
                    <div class="trakt-action-icon">
                        <i class="fas fa-star"></i>
                    </div>
                    <div class="trakt-action-content">
                        <h4>Ratings</h4>
                        <p>Your rated content</p>
                        <span class="trakt-action-count">0</span>
                    </div>
                </div>
            </div>

            <!-- Scrobbling Settings Card -->
            <div class="trakt-card">
                <div class="trakt-card-header">
                    <h3><i class="fas fa-play-circle"></i> Scrobbling Settings</h3>
                </div>
                <div class="trakt-card-body">
                    <div class="trakt-settings-grid">
                        <div class="trakt-setting-item">
                            <div class="trakt-setting-main">
                                <label class="trakt-toggle">
                                    <input type="checkbox" id="traktPageAutoScrobble" checked>
                                    <span class="trakt-toggle-slider"></span>
                                </label>
                                <div class="trakt-setting-content">
                                    <h4>Auto-Track Watching</h4>
                                    <p>Automatically track movies and shows you watch</p>
                                </div>
                            </div>
                        </div>

                        <div class="trakt-setting-item">
                            <div class="trakt-setting-main">
                                <label class="trakt-toggle">
                                    <input type="checkbox" id="traktPageScrobbleProgress" checked>
                                    <span class="trakt-toggle-slider"></span>
                                </label>
                                <div class="trakt-setting-content">
                                    <h4>Sync Progress</h4>
                                    <p>Keep your watch progress synchronized in real-time</p>
                                </div>
                            </div>
                        </div>

                        <div class="trakt-setting-item">
                            <div class="trakt-setting-main">
                                <label class="trakt-toggle">
                                    <input type="checkbox" id="traktPageWatchlistSync" checked>
                                    <span class="trakt-toggle-slider"></span>
                                </label>
                                <div class="trakt-setting-content">
                                    <h4>Watchlist Integration</h4>
                                    <p>Show Trakt watchlist items in search results</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Recent Activity -->
            <div class="trakt-card" id="traktRecentActivity" style="display: none;">
                <div class="trakt-card-header">
                    <h3><i class="fas fa-clock"></i> Recent Activity</h3>
                </div>
                <div class="trakt-card-body">
                    <div class="trakt-activity-list" id="traktActivityList">
                        <!-- Activity items will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Page -->
    <div id="settings-page" style="display: none;">
        <div class="settings-page-container">
            <div class="page-header-enhanced">
                <h2 class="section-title">Settings</h2>
            </div>
            
            <div class="settings-tabs">
                <button class="settings-tab active" data-section="streaming">Streaming</button>
                <button class="settings-tab" data-section="debrid">Debrid</button>
                <button class="settings-tab" data-section="nodempv" id="nodempvTab" style="display:none;">Player</button>
                <button class="settings-tab" data-section="engine">Engine</button>
                <button class="settings-tab" data-section="ui">User Interface</button>
                <button class="settings-tab" data-section="trakt">Trakt Integration</button>
                <button class="settings-tab" data-section="addons">Addon Manager</button>
                <button class="settings-tab" data-section="aiostreams">AIOStreams</button>
            </div>

            <div class="settings-sections">
                <!-- Streaming Section -->
                <div id="streamingContent" class="settings-section active">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-server"></i> Jackett Configuration</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="current-api-key" id="currentApiKey">
                                No API key configured
                            </div>
                            <div class="form-group">
                                <label for="newApiKey">New API Key:</label>
                                <input type="text" id="newApiKey" placeholder="Enter new Jackett API key..." />
                            </div>
                            <div class="form-group">
                                <label for="jackettUrl">Jackett Base URL:</label>
                                <input type="text" id="jackettUrl" placeholder="http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab" />
                                <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem; display:block;">Default: http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab</small>
                            </div>
                            <button id="jackettTutorialBtn" class="api-btn" style="background: white; color: #1a1a1a; padding: 0.5rem 1rem; font-size: 0.9rem; margin-top: 1rem; font-weight: 600;">
                                Video Tutorial
                            </button>
                        </div>
                    </div>
                    
                    
                    
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-play-circle"></i> Streaming Mode</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="useStreamingServersToggle" />
                                <label for="useStreamingServersToggle">Use Streaming Servers instead of Torrents</label>
                            </div>
                            <div style="margin-top:0.5rem; color:#10b981; font-size:0.9rem;">
                                Stream directly from web servers (faster startup, no downloads)
                            </div>
                            <div style="margin-top:0.25rem; color:#9ca3af; font-size:0.85rem;">
                                When enabled, movies/shows will stream from online servers instead of torrent files
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-hdd"></i> Cache & Storage</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="form-group">
                                <label for="cacheLocation">Cache Location:</label>
                                <div style="display:flex; gap:0.5rem; align-items:center;">
                                    <input type="text" id="cacheLocation" readonly placeholder="System default temp folder" style="flex:1;" />
                                    <button class="api-btn" id="selectCacheBtn" style="background:#0d6efd; color:#fff; white-space:nowrap;">
                                        <i class="fas fa-folder-open"></i> Browse
                                    </button>
                                </div>
                                <small style="color:var(--secondary); font-size:0.85rem; margin-top:0.25rem; display:block;">
                                    <i class="fas fa-info-circle"></i> Location where WebTorrent streams and subtitles are cached
                                </small>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-stream" style="color: #667eea;"></i> Nuvio Configuration</h3>
                        </div>
                        <div class="settings-card-body">
                            <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                                <i class="fas fa-info-circle"></i>
                                Configure your Febbox token for Nuvio streaming (ShowBox). A default token is provided, but you can use your own.
                            </div>
                            
                            <div class="form-group">
                                <label for="febboxTokenInput">
                                    Febbox JWT Token (Optional)
                                </label>
                                <input 
                                    type="text" 
                                    id="febboxTokenInput" 
                                    placeholder="Leave empty to use default token or paste your Febbox JWT token here"
                                    style="font-family: monospace;"
                                />
                            </div>
                            
                            <button id="saveFebboxToken" class="btn" style="width: 100%;">
                                <i class="fas fa-save"></i> Save Token
                            </button>
                            
                            <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(103, 126, 234, 0.1); border-left: 3px solid var(--secondary); border-radius: 4px; font-size: 0.85rem;">
                                <i class="fas fa-check-circle" style="color: var(--secondary);"></i> Default token is active. You can continue using Nuvio without adding your own token.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Debrid Section -->
                <div id="debridContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-cloud"></i> Debrid Services (Cloud Cache)</h3>
                        </div>
                        <div class="settings-card-body" id="debridSection">
                            <div class="checkbox-group">
                                <input type="checkbox" id="useDebridToggle" />
                                <label for="useDebridToggle">Use Debrid</label>
                            </div>
                            
                            <div class="form-group">
                                <div style="display:flex; gap:0.75rem; align-items:center; flex-wrap: wrap;">
                                    <label for="debridProvider">Provider:</label>
                                    <select id="debridProvider" style="min-width:220px; max-width:260px;">
                                        <option value="realdebrid">RealDebrid</option>
                                        <option value="alldebrid">AllDebrid</option>
                                        <option value="torbox">TorBox</option>
                                        <option value="premiumize">Premiumize</option>
                                    </select>
                                    <span id="debridStatus" style="font-size:0.9rem; opacity:0.85;">Not logged in</span>
                                </div>
                            </div>
                            
                            <!-- Real-Debrid Section -->
                            <div class="form-group" id="rdClientIdGroup">
                                <label for="rdClientId">RealDebrid Client ID (device flow):</label>
                                <input type="text" id="rdClientId" placeholder="Enter your RD Client ID (e.g., XXXXXXXXXXXXX)" />
                            </div>
                            
                            <div id="rdButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap; align-items:center;">
                                <button class="api-btn" id="rdDeviceLogin" style="background:#198754; color:#fff;">
                                    <i class="fas fa-sign-in-alt"></i> Login with RealDebrid
                                </button>
                                <small style="opacity:0.85;">No password needed. Authenticate on realdebrid.com using a short code.</small>
                            </div>
                            
                            <div id="rdCodePanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                                <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                    <div>Code:</div>
                                    <div id="rdUserCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                                    <button class="api-btn" id="rdCopyCode" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                                </div>
                                <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                    <div>Verify at:</div>
                                    <a id="rdVerifyUrl" href="#" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://real-debrid.com/device</a>
                                    <button class="api-btn" id="rdOpenVerify" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                                    <span id="rdLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting for approval</span>
                                    <button class="api-btn api-btn-secondary" id="rdCancelLogin"><i class="fas fa-times"></i> Cancel</button>
                                </div>
                            </div>
                            
                            <div class="form-group" id="rdTokenGroup">
                                <label for="debridToken">RealDebrid Token (temporary MVP):</label>
                                <input type="password" id="debridToken" placeholder="Paste RD token..." />
                            </div>
                            
                            <div id="rdTokenButtons" style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                <button class="api-btn" id="saveDebridToken" style="background:#0d6efd; color:#fff;">
                                    <i class="fas fa-key"></i> Save Token
                                </button>
                                <button class="api-btn api-btn-secondary" id="clearDebridToken">
                                    <i class="fas fa-sign-out-alt"></i> Logout
                                </button>
                            </div>
                            
                            <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Your token is stored locally and never exposed to websites.</div>

                            <!-- AllDebrid PIN Login UI -->
                            <div id="adSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                                <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
                                    <button class="api-btn" id="adStartPin" style="background:#198754; color:#fff;"><i class="fas fa-sign-in-alt"></i> Login with AllDebrid (PIN)</button>
                                    <small style="opacity:0.85;">Authenticate on alldebrid.com/pin with the code shown.</small>
                                </div>
                                <div id="adPinPanel" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
                                    <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                        <div>PIN:</div>
                                        <div id="adPinCode" style="font-family:monospace; font-weight:800; background:rgba(255,255,255,0.1); padding:0.25rem 0.5rem; border-radius:6px;">----</div>
                                        <button class="api-btn" id="adCopyPin" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-copy"></i> Copy</button>
                                    </div>
                                    <div style="margin-top:0.5rem; display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
                                        <div>Open:</div>
                                        <a id="adUserUrl" href="https://alldebrid.com/pin/" target="_blank" style="color:#0d6efd; text-decoration:underline;">https://alldebrid.com/pin/</a>
                                        <button class="api-btn" id="adOpenUserUrl" style="padding:0.4rem 0.6rem; background:#0d6efd; color:#fff;"><i class="fas fa-external-link-alt"></i> Open</button>
                                        <span id="adLoginStatus" style="margin-left:auto; font-size:0.9rem; opacity:0.9;">Waiting</span>
                                        <button class="api-btn api-btn-secondary" id="adCancelPin"><i class="fas fa-times"></i> Cancel</button>
                                    </div>
                                </div>
                                <div class="form-group" style="margin-top:0.75rem;">
                                    <label for="adApiKey">AllDebrid API Key (optional/manual):</label>
                                    <input type="password" id="adApiKey" placeholder="Paste AD API key..." />
                                </div>
                                <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                    <button class="api-btn" id="adSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                                    <button class="api-btn api-btn-secondary" id="adClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                                </div>
                            </div>

                            <!-- TorBox Auth (token) -->
                            <div id="tbSection" style="display:none; margin-top:1rem; padding:1rem; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                                <div class="form-group">
                                    <label for="tbToken">TorBox Token (temporary):</label>
                                    <input type="password" id="tbToken" placeholder="Paste TorBox token..." />
                                </div>
                                <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                    <button class="api-btn" id="tbSaveToken" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save Token</button>
                                    <button class="api-btn api-btn-secondary" id="tbClearToken"><i class="fas fa-sign-out-alt"></i> Logout</button>
                                </div>
                                <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">Token stored locally.</div>
                            </div>

                            <!-- Premiumize Auth (API Key) -->
                            <div id="pmSection" style="display:none; margin-top:1rem; padding:1px solid rgba(255,255,255,0.15); border-radius:8px; background: rgba(255,255,255,0.05);">
                                <div class="form-group">
                                    <label for="pmApiKey">Premiumize API Key:</label>
                                    <input type="password" id="pmApiKey" placeholder="Enter your Premiumize API key..." />
                                </div>
                                <div style="display:flex; gap:0.5rem; flex-wrap: wrap;">
                                    <button class="api-btn" id="pmSaveApiKey" style="background:#0d6efd; color:#fff;"><i class="fas fa-key"></i> Save API Key</button>
                                    <button class="api-btn api-btn-secondary" id="pmClearApiKey"><i class="fas fa-sign-out-alt"></i> Logout</button>
                                </div>
                                <div style="margin-top:0.25rem; color:#ffc107; font-size:0.9rem;">
                                    Get your API key from <a href="https://www.premiumize.me/account" target="_blank" style="color:#0d6efd; text-decoration:underline;">premiumize.me/account</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- NodeMPV Player Section (Windows Only) -->
                <div id="nodempvContent" class="settings-section" style="display:none;">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-play-circle" style="color: #f97316;"></i> Player Settings</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="useNodeMPVToggle" />
                                <label for="useNodeMPVToggle">Use MPV Player (Better codec support)</label>
                            </div>
                            <div style="margin-top:0.5rem; color:var(--gray); font-size:0.85rem;">
                                <i class="fas fa-info-circle"></i> Requires MPV installed on your system. Uses native MPV for better audio/video codec support including DTS, TrueHD, etc.
                            </div>
                            
                            <div class="form-group" style="margin-top:1rem;">
                                <label for="mpvPathInput">Custom MPV Path (optional)</label>
                                <div style="display:flex; gap:0.5rem;">
                                    <input type="text" id="mpvPathInput" placeholder="Leave empty to use global MPV" style="flex:1;" />
                                    <button class="api-btn" id="browseMpvPathBtn" style="background:var(--gray-dark);">
                                        <i class="fas fa-folder-open"></i> Browse
                                    </button>
                                </div>
                                <div style="margin-top:0.25rem; color:var(--gray); font-size:0.8rem;">
                                    Path to mpv.exe (e.g., C:\mpv\mpv.exe)
                                </div>
                            </div>
                            
                            <div style="margin-top:0.75rem; padding:0.75rem; background:rgba(249,115,22,0.1); border-left:3px solid #f97316; border-radius:4px; font-size:0.85rem;">
                                <i class="fas fa-download" style="color:#f97316;"></i> 
                                <a href="#" id="downloadMpvLink" style="color:#f97316; text-decoration:underline;">Download MPV</a> if not installed.
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Torrent Engine Section -->
                <div id="engineContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-sync-alt" style="color: #06b6d4;"></i> Torrent Engine</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="form-group">
                                <label for="torrentEngineSelect">Engine Type</label>
                                <select id="torrentEngineSelect">
                                    <option value="stremio">Stremio Engine (Default)</option>
                                    <option value="webtorrent">WebTorrent</option>
                                    <option value="torrentstream">TorrentStream</option>
                                    <option value="hybrid">Hybrid Mode</option>
                                </select>
                                <div style="margin-top:0.5rem; color:var(--gray); font-size:0.8rem;">
                                    <i class="fas fa-info-circle"></i> Choose your preferred torrent streaming engine.
                                </div>
                            </div>
                            
                            <div id="engineInstancesContainer" class="form-group" style="display:none; margin-top:1.25rem;">
                                <label for="engineInstancesSlider">
                                    <i class="fas fa-layer-group" style="color:#06b6d4;"></i> 
                                    Engine Instances: <span id="engineInstanceLabel" style="color:#06b6d4; font-weight:bold;">1</span>
                                </label>
                                <input type="range" id="engineInstancesSlider" min="1" max="3" value="1" style="width:100%; accent-color:#06b6d4; margin-top:0.5rem;" />
                                <div style="display:flex; justify-content:space-between; color:var(--gray); font-size:0.75rem; margin-top:0.25rem;">
                                    <span>1 (Light)</span>
                                    <span>2 (Balanced)</span>
                                    <span>3 (Maximum)</span>
                                </div>
                                <div style="margin-top:0.5rem; color:var(--gray); font-size:0.8rem;">
                                    <i class="fas fa-bolt"></i> More instances = more peers = faster downloads. Uses more resources.
                                </div>
                            </div>
                            
                            <div id="engineInfoBox" style="margin-top:1.25rem; padding:1rem; background:rgba(6,182,212,0.1); border-left:4px solid #06b6d4; border-radius:6px;">
                                <p id="engineDescription" style="color:#67e8f9; font-size:0.9rem; margin:0; line-height:1.5;">
                                    Stremio's engine provides reliable streaming with built-in transcoding support.
                                </p>
                            </div>
                            
                            <div id="engineStatus" style="margin-top:1rem; padding:0.75rem; background:rgba(34,197,94,0.1); border-radius:6px; display:none;">
                                <span style="color:#4ade80; font-size:0.85rem;">
                                    <i class="fas fa-check-circle"></i> <span id="engineStatusText">Engine ready</span>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Addon Manager Section -->
                <div id="addonsContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-puzzle-piece" style="color: var(--vlc-orange);"></i> Addon Manager</h3>
                        </div>
                        <div class="settings-card-body">
                            <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                                <i class="fas fa-info-circle"></i> Install Stremio addons to expand content sources.
                            </div>
                            
                            <div class="form-group">
                                <label for="addonManifestUrl">Manifest URL:</label>
                                <div style="display: flex; gap: 0.5rem;">
                                    <input type="text" id="addonManifestUrl" placeholder="https://example.com/manifest.json" style="flex:1;" />
                                    <button class="api-btn" id="installAddonBtn" style="background: var(--success); color: #fff;">
                                        <i class="fas fa-plus"></i> Install
                                    </button>
                                </div>
                            </div>

                            <div style="margin-top: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Installed Addons:</label>
                                <div id="installedAddonsList" style="display: flex; flex-direction: column; gap: 0.5rem; max-height: 200px; overflow-y: auto;">
                                    <!-- Addons will be injected here -->
                                    <div style="text-align: center; color: var(--gray); padding: 1rem;">No addons installed</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- AIOStreams Section -->
                <div id="aiostreamsContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-plug"></i> AIOStreams Plugin Installer</h3>
                        </div>

                        <div class="settings-card-body" id="aiostreamsSection">

                            <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                                <i class="fas fa-info-circle"></i>
                                Install additional streaming providers using an AIOStreams manifest URL.
                            </div>

                            <div class="form-group">
                                <label for="manifestUrl">Plugin Manifest URL (Go to https://aiostreams.elfhosted.com/stremio/configure setup the plugin, setup a password, click install, click copy url and paste it here</label>
                                <input 
                                    type="text" 
                                    id="manifestUrl"
                                    placeholder="https://example.com/manifest.json"
                                    style="width:100%; padding:0.65rem; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:var(--light); font-family:monospace;"
                                />
                            </div>

                            <button onclick="saveManifest()" class="api-btn" style="background:#0d6efd; color:#fff; width:100%; margin-top:1rem;">
                                <i class="fas fa-save"></i> Save Manifest
                            </button>


                            <div id="manifestSavedBox" style="display:none; margin-top:1rem; padding:0.75rem; background:rgba(103,126,234,0.1); border-left:3px solid var(--secondary); border-radius:4px; font-size:0.85rem;">
                                <i class="fas fa-check-circle" style="color:var(--secondary);"></i> Manifest URL saved locally.
                            </div>

                        </div>
                    </div>
                </div>

                <!-- User Interface Section -->
                <div id="uiContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-desktop"></i> Display Settings</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="fullscreenToggle" />
                                <label for="fullscreenToggle">
                                    <i class="fas fa-expand-arrows-alt" style="margin-right:0.25rem; color:var(--vlc-orange);"></i>
                                    <strong>Fullscreen Mode</strong>
                                </label>
                            </div>
                            <div style="margin-top:0.25rem; color:var(--secondary); font-size:0.85rem; margin-left:1.85rem;">
                                <i class="fas fa-info-circle"></i> Toggle between fullscreen and windowed mode
                            </div>
                            
                            <div class="radio-group" style="margin-top:1.5rem; padding-top:1rem; border-top:1px solid rgba(255,255,255,0.1);">
                                <label style="display:block; margin-bottom:0.75rem; color:var(--light); font-weight:600;">
                                    UI Mode
                                </label>
                                <div class="radio-option">
                                    <input type="radio" name="uiMode" value="new" id="uiModeNew" checked />
                                    <label for="uiModeNew"><strong>NEW UI</strong> - Modern app-like interface</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" name="uiMode" value="old" id="uiModeOld" />
                                    <label for="uiModeOld"><strong>OLD UI</strong> - Classic website layout</label>
                                </div>
                                <div style="margin-top:0.75rem; padding-top:0.75rem; border-top:1px solid rgba(255,255,255,0.05);">
                                    <button onclick="if(window.electronAPI?.setPreferredMode) window.electronAPI.setPreferredMode('basic'); window.location.href='basicmode/index.html'" class="btn btn-outline" style="width:100%; justify-content:center;">
                                        <i class="fas fa-bolt"></i> Switch to Basic Mode
                                    </button>
                                </div>
                                <div style="margin-top:0.5rem; color:var(--secondary); font-size:0.9rem;">
                                    <i class="fas fa-info-circle"></i> Changes will apply immediately after saving
                                </div>
                            </div>
                        </div>
                    </div>


                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-palette"></i> Theme</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="form-group">
                                <label for="themeSelector" style="display:block; margin-bottom:0.75rem; color:var(--light); font-weight:600; font-size:1rem;">
                                    <i class="fas fa-palette" style="margin-right:0.5rem; color:var(--vlc-orange);"></i>
                                    Color Theme
                                </label>
                                <select id="themeSelector" style="width:100%; max-width:350px; padding:0.75rem 1rem; background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.2); border-radius:10px; color:var(--light); font-size:0.95rem; font-weight:500; cursor:pointer; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27rgba(255,255,255,0.6)%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.75rem center; background-size: 1.25rem; padding-right: 2.5rem;">
                                    <option value="default">Default (Purple Dream)</option>
                                    <option value="green-forest">Green Forest</option>
                                    <option value="cyberpunk-neon">Cyberpunk Neon</option>
                                    <option value="ocean-breeze">Ocean Breeze</option>
                                    <option value="cherry-blossom">Cherry Blossom</option>
                                    <option value="midnight-dark">Midnight Dark</option>
                                    <option value="sunset-orange">Sunset Orange</option>
                                </select>
                                <small style="margin-top:0.5rem; color:var(--secondary); font-size:0.85rem; display:block;">
                                    <i class="fas fa-info-circle"></i> Choose your preferred color scheme
                                </small>
                            </div>
                        </div>
                    </div>

                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fab fa-discord"></i> Discord Activity</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="discordActivityToggle" checked />
                                <label for="discordActivityToggle">
                                    <i class="fab fa-discord" style="margin-right:0.25rem; color:#5865F2;"></i>
                                    <strong>Show Discord Rich Presence</strong>
                                </label>
                            </div>
                            <div style="margin-top:0.5rem; color:#9ca3af; font-size:0.9rem;">
                                <i class="fas fa-info-circle"></i> Display what you're watching on your Discord profile
                            </div>
                        </div>
                    </div>

                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-ad" style="color: #10b981;"></i> Sponsor</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="showSponsorToggle" checked />
                                <label for="showSponsorToggle">
                                    <i class="fas fa-heart" style="margin-right:0.25rem; color:#10b981;"></i>
                                    <strong>Show Sponsor Button</strong>
                                </label>
                            </div>
                            <div style="margin-top:0.5rem; color:#9ca3af; font-size:0.9rem;">
                                <i class="fas fa-info-circle"></i> Display the Ace Bet sponsor button in the navigation. Sponsors help keep PlayTorrio free!
                            </div>
                        </div>
                    </div>

                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-sync-alt"></i> AutoUpdater</h3>
                        </div>
                        <div class="settings-card-body">
                            <div class="checkbox-group">
                                <input type="checkbox" id="autoUpdateToggle" checked />
                                <label for="autoUpdateToggle">Automatically download and install updates</label>
                            </div>
                            <div style="margin-top:0.5rem; color:#9ca3af; font-size:0.9rem;">
                                When enabled, the app will check for updates on launch and install them when available.
                            </div>
                        </div>
                    </div>

                    <!-- Attribution Card -->
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-brush" style="color: var(--vlc-orange);"></i> Icon Attribution</h3>
                        </div>
                        <div class="settings-card-body" style="font-size:0.9rem; line-height:1.5; color:var(--secondary);">
                            <p style="margin:0 0 0.75rem; color:var(--light);"><strong>PlayTorrio App Icon</strong></p>
                            <p style="margin:0 0 0.75rem;">Designed by <strong>Adnan Ahmed</strong>.</p>
                            <p style="margin:0 0 0.5rem;">
                                <i class="fas fa-globe" style="color:var(--vlc-orange);"></i>
                                <a href="https://adnan-ahmed.pages.dev/" target="_blank" style="color:#0d6efd; text-decoration:underline; cursor:pointer;" onclick="event.preventDefault(); if (window.electronAPI?.openExternal) { window.electronAPI.openExternal('https://adnan-ahmed.pages.dev/'); } else { window.open('https://adnan-ahmed.pages.dev/', '_blank'); }">Website</a>
                            </p>
                            <p style="margin:0 0 0.5rem;">
                                <i class="fab fa-github" style="color:var(--vlc-orange);"></i>
                                <a href="https://github.com/ddosintruders" target="_blank" style="color:#0d6efd; text-decoration:underline; cursor:pointer;" onclick="event.preventDefault(); if (window.electronAPI?.openExternal) { window.electronAPI.openExternal('https://github.com/ddosintruders'); } else { window.open('https://github.com/ddosintruders', '_blank'); }">GitHub Profile</a>
                            </p>
                            <p style="margin:0; font-size:0.75rem; opacity:0.8;">Credit preserved per creator request. Thank you Adnan for the visual identity.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Trakt Integration Section -->
                <div id="traktContent" class="settings-section">
                    <div class="settings-card">
                        <div class="settings-card-header">
                            <h3><i class="fas fa-tv" style="color: #ed1c24;"></i> Trakt Connection</h3>
                        </div>
                        <div class="settings-card-body">
                            <div style="margin-bottom: 1rem; color: var(--secondary); font-size: 0.9rem;">
                                <i class="fas fa-info-circle"></i>
                                Sync your watch history, progress, and manage your watchlist with Trakt.tv
                            </div>
                            
                            <div id="traktNotConnected" style="display: block;">
                                <div style="margin-bottom: 1rem;">
                                    <span id="traktStatus" style="color: #dc3545; font-weight: 500;">
                                        <i class="fas fa-times-circle"></i> Not connected
                                    </span>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                                    <button class="api-btn" id="traktLogin" style="background: #ed1c24; color: #fff;">
                                        <i class="fas fa-sign-in-alt"></i> Connect to Trakt
                                    </button>
                                    <small style="opacity: 0.85;">Authenticate with your Trakt.tv account using a secure device code</small>
                                </div>
                            </div>

                            <div id="traktConnected" style="display: none;">
                                <div style="margin-bottom: 1rem;">
                                    <span id="traktConnectedStatus" style="color: #198754; font-weight: 500;">
                                        <i class="fas fa-check-circle"></i> Connected as <span id="traktUsername">User</span>
                                    </span>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; margin-bottom: 1rem;">
                                    <button class="api-btn" id="traktViewWatchlist" style="background: #0d6efd; color: #fff;">
                                        <i class="fas fa-list"></i> View Watchlist
                                    </button>
                                    <button class="api-btn" id="traktViewHistory" style="background: #6f42c1; color: #fff;">
                                        <i class="fas fa-history"></i> View History
                                    </button>
                                    <button class="api-btn" id="traktViewStats" style="background: #17a2b8; color: #fff;">
                                        <i class="fas fa-chart-bar"></i> View Stats
                                    </button>
                                </div>
                                <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                                    <button class="api-btn api-btn-secondary" id="traktDisconnect">
                                        <i class="fas fa-sign-out-alt"></i> Disconnect
                                    </button>
                                </div>
                            </div>

                            <!-- Trakt Device Code Panel -->
                            <div id="traktCodePanel" style="display: none; margin-top: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
                                    <div>Device Code:</div>
                                    <div id="traktUserCode" style="font-family: monospace; font-weight: 800; background: rgba(255,255,255,0.1); padding: 0.25rem 0.5rem; border-radius: 6px;">----</div>
                                    <button class="api-btn" id="traktCopyCode" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                                        <i class="fas fa-copy"></i> Copy
                                    </button>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                                    <div>Authorize at:</div>
                                    <a id="traktVerifyUrl" href="#" target="_blank" style="color: #0d6efd; text-decoration: underline;">https://trakt.tv/activate</a>
                                    <button class="api-btn" id="traktOpenVerify" style="padding: 0.4rem 0.6rem; background: #0d6efd; color: #fff;">
                                        <i class="fas fa-external-link-alt"></i> Open
                                    </button>
                                    <span id="traktLoginStatus" style="margin-left: auto; font-size: 0.9rem; opacity: 0.9;">Waiting for authorization</span>
                                    <button class="api-btn api-btn-secondary" id="traktCancelLogin">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                </div>
                            </div>

                            <!-- Trakt Settings -->
                            <div id="traktSettings" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                <h4 style="margin-bottom: 0.75rem; color: var(--text-primary);">Scrobbling Settings</h4>
                                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                                        <input type="checkbox" id="traktAutoScrobble" checked />
                                        <span>Automatically track what I watch</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                                        <input type="checkbox" id="traktScrobbleProgress" checked />
                                        <span>Sync watch progress</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.6rem; cursor: pointer;">
                                        <input type="checkbox" id="traktSyncWatchlist" checked />
                                        <span>Show Trakt watchlist items in search</span>
                                    </label>
                                </div>
                                <div style="margin-top: 0.5rem; color: var(--secondary); font-size: 0.85rem;">
                                    <i class="fas fa-info-circle"></i> Your viewing activity will be automatically synchronized with Trakt.tv
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Save Button -->
            <div style="margin-top: 2rem; padding-top: 2rem; border-top: 2px solid rgba(168, 85, 247, 0.2); display: flex; gap: 1rem; justify-content: flex-end;">
                <button class="api-btn api-btn-secondary" id="cancelSettingsPage">
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button class="api-btn api-btn-primary" id="saveSettingsPage">
                    <i class="fas fa-save"></i> Save Changes
                </button>
            </div>
        </div>
    </div>

    <!-- Live TV Page -->
    <div id="livetv-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-broadcast-tower" style="color: #10b981;"></i> <span>Live TV</span>
                </h2>
                <p class="page-subtitle">Watch live sports from around the world</p>
            </div>
        </div>

        <div class="trakt-container">
            <!-- Category Selector and Search -->
            <div class="trakt-card">
                <div class="trakt-card-body">
                    <div class="livetv-category-section" style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
                        <div id="livetv-source-buttons" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button class="provider-btn active" data-source="kobra">Kobra</button>
                            <button class="provider-btn" data-source="phoenix">Phoenix</button>
                            <button class="provider-btn" data-source="titan">Titan</button>
                            <button class="provider-btn" data-source="raptor">Raptor</button>
                            <button class="provider-btn" data-source="scorpion">Scorpion</button>
                            <button class="provider-btn" data-source="viper">Viper</button>
                        </div>
                    </div>
                    <div class="livetv-category-section" style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                        <div>
                            <label for="livetv-category-select" class="livetv-category-label">
                                <i class="fas fa-filter"></i> Category
                            </label>
                            <select id="livetv-category-select" class="livetv-category-dropdown">
                                <option value="football"> Football</option>
                            </select>
                        </div>
                        <div id="livetv-match-count" style="display: none; align-items: center; gap: 0.75rem; padding: 0.5rem 1rem; background: rgba(17, 24, 39, 0.6); backdrop-filter: blur(10px); border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.85rem;"></div>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="position: relative;">
                            <i class="fas fa-search" style="position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: rgba(16,185,129,0.6); font-size: 0.9rem;"></i>
                            <input 
                                type="text" 
                                id="livetv-search-input" 
                                placeholder="Search matches (e.g., Barcelona, Real Madrid, Champions League)..." 
                                style="width: 100%; padding: 0.75rem 1rem 0.75rem 2.75rem; border: 2px solid rgba(16,185,129,0.3); border-radius: 8px; background: rgba(16,185,129,0.05); color: var(--light); font-size: 0.95rem; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);"
                                onfocus="this.style.borderColor='rgba(16,185,129,0.6)'; this.style.background='rgba(16,185,129,0.1)';"
                                onblur="this.style.borderColor='rgba(16,185,129,0.3)'; this.style.background='rgba(16,185,129,0.05)';"
                            >
                        </div>
                    </div>
                </div>
            </div>

            <!-- Matches Grid -->
            <div class="trakt-card">
                <div class="trakt-card-body">
                    <div id="livetv-grid" class="livetv-matches-grid"></div>
                    <div id="livetv-empty" class="livetv-empty" style="display: none;">
                        <i class="fas fa-tv" style="font-size: 3em; opacity: 0.3;"></i>
                        <p>No matches available for this category</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Streams List Modal -->
        <div id="livetv-streams-modal" class="livetv-streams-modal" style="display: none;">
            <div class="livetv-streams-content">
                <div class="livetv-streams-header">
                    <h3 id="livetv-streams-title"></h3>
                    <button id="livetv-streams-close" class="livetv-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="livetv-streams-list" class="livetv-streams-list"></div>
            </div>
        </div>
    </div>

    <!-- IPTV Page -->
    <div id="iptv-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-tv" style="color: #3b82f6;"></i> <span>IPTV</span>
                </h2>
                <p class="page-subtitle">Watch live TV channels from around the world</p>
            </div>
            <div class="page-actions" style="display:flex; gap:.5rem; align-items:center;">
                <button id="iptv-custom-btn" class="btn" style="background:linear-gradient(135deg,#3b82f6,#2563eb);color:#fff;border:none;padding:.6rem 1rem;border-radius:8px;font-weight:600;cursor:pointer;">
                    <i class="fas fa-user-lock"></i> Custom IPTV (Xtream Codes)
                </button>
            </div>
        </div>

        <div class="page-content" style="padding: 0; height: calc(100vh - 140px);">
            <iframe 
                id="iptv-iframe" 
                src="https://iptvplaytorrio.pages.dev/" 
                style="width: 100%; height: 100%; border: none; border-radius: 8px;"
                allowfullscreen>
            </iframe>
            <!-- Custom IPTV Inline Browser (replaces iframe when active) -->
            <div id="xtream-inline" style="display:none; width:100%; height:100%;">
                <div style="display:flex; justify-content:space-between; align-items:center; padding:.75rem 1rem; border-bottom:1px solid rgba(255,255,255,.08); background:rgba(0,0,0,.3);">
                    <div style="display:flex; gap:.5rem; align-items:center;">
                        <button class="xtream-tab-btn" data-tab="live" style="background:#1b1b1b;color:#fff;border:1px solid rgba(255,255,255,.15);padding:.45rem .8rem;border-radius:8px;cursor:pointer;">Live</button>
                        <button class="xtream-tab-btn" data-tab="vod" style="background:transparent;color:#ddd;border:1px solid rgba(255,255,255,.15);padding:.45rem .8rem;border-radius:8px;cursor:pointer;">Movies</button>
                        <button class="xtream-tab-btn" data-tab="series" style="background:transparent;color:#ddd;border:1px solid rgba(255,255,255,.15);padding:.45rem .8rem;border-radius:8px;cursor:pointer;">Series</button>
                    </div>
                    <div style="display:flex; gap:.6rem; align-items:center;">
                        <select id="xtream-category-select" size="1" style="background:#1b1b1b;color:#fff;border:1px solid rgba(255,255,255,.15);padding:.45rem .8rem;border-radius:8px;">
                            <option value="">All Categories</option>
                        </select>
                        <input id="xtream-search" placeholder="Search..." style="background:#1b1b1b;color:#fff;border:1px solid rgba(255,255,255,.15);padding:.5rem .8rem;border-radius:8px;min-width:220px;">
                    </div>
                </div>
                <div id="xtream-inline-content" style="width:100%; height:calc(100% - 58px); overflow:auto; padding:1rem;">
                    <div id="xtream-empty" style="display:flex; align-items:center; justify-content:center; height:100%; color:#9ca3af;">No data</div>
                    <div id="xtream-grid" style="display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:1rem;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Xtream Codes Login Modal -->
    <div id="xtream-login-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.65); z-index:12000; align-items:center; justify-content:center;">
        <div style="width: min(560px, 92vw); background: #121212; color: #fff; border-radius: 16px; border:1px solid rgba(255,255,255,.12); box-shadow:0 20px 50px rgba(0,0,0,.5); overflow:hidden;">
            <div style="display:flex; justify-content:space-between; align-items:center; padding:1rem 1.25rem; border-bottom:1px solid rgba(255,255,255,.08);">
                <h3 style="margin:0; font-size:1.1rem; display:flex; gap:.5rem; align-items:center;"><i class="fas fa-key"></i> Xtream Codes Login</h3>
                <button id="xtream-login-close" style="background:transparent;color:#fff;border:none;font-size:1.25rem;cursor:pointer;"></button>
            </div>
            <div style="padding:1rem 1.25rem; display:flex; flex-direction:column; gap:.75rem;">
                <label style="font-size:.9rem; color:#ddd;">Server Base URL (e.g. http://example.com:8080)</label>
                <input id="xtream-base-url" placeholder="http://host:port" style="padding:.7rem 1rem; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#1b1b1b; color:#fff; outline:none;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:.75rem;">
                    <div>
                        <label style="font-size:.9rem; color:#ddd;">Username</label>
                        <input id="xtream-username" placeholder="username" style="width:100%; padding:.7rem 1rem; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#1b1b1b; color:#fff; outline:none;">
                    </div>
                    <div>
                        <label style="font-size:.9rem; color:#ddd;">Password</label>
                        <input id="xtream-password" placeholder="password" type="password" style="width:100%; padding:.7rem 1rem; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#1b1b1b; color:#fff; outline:none;">
                    </div>
                </div>
                <div style="display:flex; align-items:center; gap:.5rem; margin-top:.25rem;">
                    <input id="xtream-remember" type="checkbox">
                    <label for="xtream-remember" style="color:#bbb;">Remember on this device</label>
                </div>
                <div style="display:flex; justify-content:flex-end; gap:.5rem; margin-top:.75rem;">
                    <button id="xtream-login-cancel" style="background:rgba(255,255,255,.1); color:#fff; border:1px solid rgba(255,255,255,.2); padding:.6rem 1rem; border-radius:8px; cursor:pointer;">Cancel</button>
                    <button id="xtream-login-submit" style="background:linear-gradient(135deg,#10b981,#059669); color:#fff; border:none; padding:.6rem 1rem; border-radius:8px; font-weight:600; cursor:pointer;">
                        <i class="fas fa-sign-in-alt"></i> Login
                    </button>
                </div>
                <div style="display:flex; align-items:center; gap:.5rem; opacity:.8; padding-top:.4rem; border-top:1px dashed rgba(255,255,255,.15); margin-top:.4rem;">
                    <span style="font-size:.85rem; color:#9ca3af;">OR</span>
                </div>
                <label style="font-size:.9rem; color:#ddd;">M3U/M3U8 Playlist URL</label>
                <input id="xtream-m3u-url" placeholder="http://example.com/playlist.m3u or .m3u8" style="padding:.7rem 1rem; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#1b1b1b; color:#fff; outline:none;">
                <div style="display:flex; justify-content:flex-end; gap:.5rem;">
                    <button id="xtream-m3u-submit" style="background:linear-gradient(135deg,#f59e0b,#b45309); color:#fff; border:none; padding:.6rem 1rem; border-radius:8px; font-weight:600; cursor:pointer;">
                        <i class="fas fa-list"></i> Load Playlist
                    </button>
                </div>
                <!-- Recommended M3U Playlists -->
                <div id="xtream-m3u-recommended" style="margin-top:.5rem;">
                    <div style="font-size:.85rem; color:#9ca3af; margin-bottom:.35rem;">Recommended playlists</div>
                    <div style="display:flex; flex-direction:column; gap:.35rem;">
                        <button class="m3u-preset" data-url="https://iptv-org.github.io/iptv/languages/eng.m3u" style="text-align:left; background:rgba(255,255,255,.06); color:#e5e7eb; border:1px solid rgba(255,255,255,.12); padding:.45rem .6rem; border-radius:6px; cursor:pointer;">
                            <i class="fas fa-bolt" style="color:#f59e0b;"></i> Load English (iptv-org)
                        </button>
                        <button class="m3u-preset" data-url="https://iptv-org.github.io/iptv/index.m3u" style="text-align:left; background:rgba(255,255,255,.06); color:#e5e7eb; border:1px solid rgba(255,255,255,.12); padding:.45rem .6rem; border-radius:6px; cursor:pointer;">
                            <i class="fas fa-bolt" style="color:#f59e0b;"></i> Load Global index (iptv-org)
                        </button>
                    </div>
                </div>
                <div id="xtream-login-status" style="font-size:.9rem; color:#9ca3af; min-height:1.2rem;"></div>
            </div>
        </div>
    </div>


    <!-- Xtream Player Modal (basic) -->
    <div id="xtream-player-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.8); z-index:16000; align-items:center; justify-content:center;">
        <div style="width:min(1000px,94vw); background:#000; border-radius:10px; overflow:hidden; border:1px solid rgba(255,255,255,.15);">
            <div style="display:flex; justify-content:space-between; align-items:center; padding:.5rem .75rem; background:#0f0f0f;">
                <div id="xtream-player-title" style="color:#fff; font-weight:600;">Playing</div>
                <div style="display:flex; gap:.5rem;">
                    <button id="xtream-open-mpv" style="display:none; background:linear-gradient(135deg,#10b981,#059669); color:#fff; border:none; padding:.4rem .7rem; border-radius:6px; cursor:pointer;">
                        <i class="fas fa-play"></i> Open in Player
                    </button>
                    <button id="xtream-open-iina" style="display:none; background:linear-gradient(135deg,#22c55e,#16a34a); color:#fff; border:none; padding:.4rem .7rem; border-radius:6px; cursor:pointer;">
                        <i class="fas fa-play-circle"></i> Open in IINA
                    </button>
                    <button id="xtream-open-vlc" style="background:linear-gradient(135deg,#f97316,#ea580c); color:#fff; border:none; padding:.4rem .7rem; border-radius:6px; cursor:pointer;">
                        <i class="fas fa-film"></i> Open in VLC
                    </button>
                    <button id="xtream-open-external" style="background:linear-gradient(135deg,#3b82f6,#2563eb); color:#fff; border:none; padding:.4rem .7rem; border-radius:6px; cursor:pointer;">
                        <i class="fas fa-external-link-alt"></i> Open in Browser
                    </button>
                    <button id="xtream-player-close" style="background:transparent;color:#fff;border:none;font-size:1.25rem;cursor:pointer;"></button>
                </div>
            </div>
            <div style="background:#000;">
                <video id="xtream-video" style="width:100%; height:65vh; background:#000;" controls playsinline></video>
            </div>
        </div>
    </div>

    <!-- Games Downloader Page -->
    <div id="games-downloader-page" class="page-wrapper" style="display: none;">
        <div class="page-header" style="text-align: center;">
            <h2><i class="fas fa-download" style="color:#8b5cf6"></i> Games Downloader</h2>
            <p style="color: var(--secondary); margin-top: 0.5rem; font-size: 0.95rem;">Search for PC games or browse downloadable games from SteamRip and FitGirl databases</p>
        </div>

        <div class="page-content">
            <!-- Tab Navigation -->
            <div style="display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem;">
                <button id="games-browse-tab" class="games-tab-btn active" style="padding: 0.75rem 2rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                    <i class="fas fa-search"></i> Browse Games
                </button>
                <button id="games-library-tab" class="games-tab-btn" style="padding: 0.75rem 2rem; background: rgba(139,92,246,0.2); border: 2px solid rgba(139,92,246,0.3); border-radius: 8px; color: #a78bfa; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                    <i class="fas fa-folder"></i> My Library <span id="games-library-count" style="background: #ef4444; color: white; padding: 0.1rem 0.5rem; border-radius: 10px; font-size: 0.75rem; margin-left: 0.3rem; display: none;">0</span>
                </button>
                <button id="games-open-folder-btn" style="padding: 0.75rem 1rem; background: rgba(16,185,129,0.2); border: 2px solid rgba(16,185,129,0.3); border-radius: 8px; color: #10b981; font-weight: 600; cursor: pointer; transition: all 0.3s;" title="Open Downloads Folder">
                    <i class="fas fa-folder-open"></i>
                </button>
            </div>
            
            <!-- TorBox Status Banner -->
            <div id="games-torbox-status" style="max-width: 800px; margin: 0 auto 1rem auto; padding: 0.75rem 1rem; border-radius: 8px; display: none;">
            </div>

            <!-- Browse Section -->
            <div id="games-browse-section">
                <!-- Search Section -->
                <div class="search-section" style="max-width: 800px; margin: 2rem auto; text-align: center;">
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                        <input 
                            type="text" 
                            id="games-search-input" 
                            placeholder="Search for PC games (e.g., Call of Duty, GTA, Cyberpunk)..." 
                            style="flex: 1; padding: 0.75rem 1rem; border: 2px solid rgba(139,92,246,0.3); border-radius: 8px; background: rgba(139,92,246,0.05); color: var(--light); font-size: 1rem;"
                        >
                        <button 
                            id="games-search-btn" 
                            style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);"
                            onmouseover="this.style.transform='scale(1.05)'" 
                            onmouseout="this.style.transform='scale(1)'"
                        >
                            <i class="fas fa-search"></i> Search
                        </button>
                    </div>
                    <button 
                        id="games-browse-all-btn" 
                        style="padding: 0.6rem 1.2rem; background: linear-gradient(135deg, #f97316, #ea580c); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); margin-bottom: 1rem;"
                        onmouseover="this.style.transform='scale(1.05)'" 
                        onmouseout="this.style.transform='scale(1)'"
                    >
                        <i class="fas fa-th"></i> Browse All Games
                    </button>
                    <div id="games-search-status" style="color: var(--secondary); font-size: 0.9rem; min-height: 1.5rem;"></div>
                </div>

                <!-- Categories Section -->
                <div id="games-categories-section" style="max-width: 1200px; margin: 0 auto 2rem auto; padding: 0 1rem;">
                    <h3 style="color: var(--light); margin-bottom: 1rem; text-align: center;"><i class="fas fa-tags" style="color:#8b5cf6"></i> Browse by Category</h3>
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 2rem;">
                        <select 
                            id="games-category-select" 
                            style="padding: 0.75rem 1rem; border: 2px solid rgba(139,92,246,0.3); border-radius: 8px; background: rgba(139,92,246,0.05); color: var(--light); font-size: 1rem; cursor: pointer; min-width: 250px;"
                        >
                            <option value="">Select a category...</option>
                        </select>
                        <button 
                            id="games-category-btn" 
                            style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);"
                            onmouseover="this.style.transform='scale(1.05)'" 
                            onmouseout="this.style.transform='scale(1)'"
                        >
                            <i class="fas fa-filter"></i> Filter
                        </button>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="games-results-section" style="display: none;">
                    <div class="books-results-header" style="align-items:center; gap:1rem; margin-bottom: 1rem;">
                        <h3><i class="fas fa-list" style="color:#8b5cf6"></i> Search Results</h3>
                        <div id="games-results-count" class="books-results-count"></div>
                    </div>
                    <div id="games-results-grid" class="books-results-grid"></div>
                </div>

                <!-- Empty State -->
                <div id="games-empty-state" class="books-empty" style="display: none;">
                </div>
            </div>

            <!-- Library Section -->
            <div id="games-library-section" style="display: none;">
                <div style="max-width: 1200px; margin: 0 auto; padding: 0 1rem;">
                    <div class="books-results-header" style="align-items:center; gap:1rem; margin-bottom: 1rem;">
                        <h3><i class="fas fa-folder" style="color:#8b5cf6"></i> My Downloads</h3>
                        <button id="games-refresh-library-btn" style="padding: 0.5rem 1rem; background: rgba(139,92,246,0.2); border: 1px solid rgba(139,92,246,0.3); border-radius: 6px; color: #a78bfa; cursor: pointer;">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                    
                    <!-- Library Grid -->
                    <div id="games-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 1rem;">
                        <!-- Downloads will be rendered here -->
                    </div>
                    
                    <!-- Empty Library State -->
                    <div id="games-library-empty" style="text-align: center; padding: 3rem; color: var(--secondary);">
                        <i class="fas fa-folder-open" style="font-size: 4rem; color: rgba(139,92,246,0.3); margin-bottom: 1rem;"></i>
                        <h3 style="color: var(--light); margin-bottom: 0.5rem;">No Downloads Yet</h3>
                        <p>Games you download will appear here. Browse games and click "Add to Library" to start downloading.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PlayTorrio MiniGames Page -->
    <div id="minigames-page" style="display: none;">
        <div class="page-content" style="padding: 0; height: 100vh; overflow: hidden;">
            <iframe 
                id="minigames-iframe" 
                src="https://playtorriogames.pages.dev/" 
                style="width: 100%; height: 100%; border: none;"
                allowfullscreen>
            </iframe>
        </div>
    </div>

    <!-- Books Page -->
    <div id="books-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-book" style="color: #f59e0b;"></i> <span>Books</span>
                </h2>
                <p class="page-subtitle">Search and read books from Z-Library</p>
            </div>
        </div>

        <div class="page-content">
            <!-- Search Section -->
            <div class="books-search-section">
                <div class="books-search-container">
                    <div class="books-search-bar">
                        <i class="fas fa-search books-search-icon"></i>
                        <input 
                            type="text" 
                            id="books-search-input" 
                            placeholder="Search for books, authors, or titles..."
                            autocomplete="off"
                        />
                        <button id="books-search-btn" class="books-search-button">
                            <i class="fas fa-search"></i>
                            Search
                        </button>
                        <button id="books-saved-btn" class="books-search-button" style="margin-left: 10px; background: #2ecc71;">
                            <i class="fas fa-bookmark"></i>
                            Saved
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div id="books-loading" class="books-loading" style="display: none;">
                <div class="books-loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                </div>
                <p>Searching Z-Library...</p>
            </div>

            <!-- Empty State -->
            <div id="books-empty" class="books-empty">
                <div class="books-empty-icon">
                    <i class="fas fa-book-open"></i>
                </div>
                <h3>Welcome to Z-Library Search</h3>
                <p>Search for any book, author, or topic to get started.</p>
            </div>

            <!-- Results Section -->
            <div id="books-results" class="books-results" style="display: none;">
                <div class="books-results-header">
                    <h3 id="books-results-title">Search Results</h3>
                    <div id="books-results-count" class="books-results-count"></div>
                </div>
                <div id="books-results-grid" class="books-results-grid">
                    <!-- Results will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Books Reader Modal -->
    <div id="books-reader-modal" class="books-reader-modal" style="display: none;">
        <div class="books-reader-content">
            <div class="books-reader-header">
                <button id="books-reader-back" class="books-reader-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3 id="books-reader-title">Reading...</h3>
            </div>
            <div class="books-reader-frame-container">
                <iframe id="books-reader-frame" class="books-reader-frame"></iframe>
            </div>
        </div>
    </div>

    <!-- Server Selection Modal -->
    <div id="server-selection-modal" class="server-selection-modal" style="display: none;">
        <div class="server-selection-content">
            <div class="server-selection-header">
                <button id="server-selection-back" class="server-selection-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
                <h3 id="server-selection-title">Select Streaming Server</h3>
            </div>
            <div class="server-selection-body">
                <div class="server-selection-info">
                    <div class="media-info">
                        <img id="server-media-poster" class="media-poster" src="" alt="Media Poster">
                        <div class="media-details">
                            <h4 id="server-media-title">Movie/Show Title</h4>
                            <p id="server-media-subtitle">Episode details</p>
                            <div class="media-meta">
                                <span id="server-media-year" class="media-year"></span>
                                <span id="server-media-rating" class="media-rating"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="server-dropdown-section">
                    <label for="server-dropdown" class="server-dropdown-label">
                        <i class="fas fa-server"></i>
                        Choose Streaming Server:
                    </label>
                    <div class="server-dropdown-container">
                        <select id="server-dropdown" class="server-dropdown">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                        <i class="fas fa-chevron-down server-dropdown-arrow"></i>
                    </div>
                </div>
                <div class="server-actions">
                    <button id="server-watch-btn" class="server-watch-btn">
                        <i class="fas fa-play"></i>
                        Start Watching
                    </button>
                    <button id="server-torrent-btn" class="server-torrent-btn">
                        <i class="fas fa-download"></i>
                        Use Torrent Instead
                    </button>
                </div>
                
                <!-- Embedded Video Player Section -->
                <div id="server-video-section" class="server-video-section" style="display: none;">
                    <div class="server-video-header">
                        <h4 id="server-video-title">Now Playing</h4>
                        <button id="server-video-close" class="server-video-close">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="server-video-container">
                        <iframe id="server-video-frame" class="server-video-iframe" 
                                src="" 
                                allowfullscreen>
                        </iframe>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Chromecast Device Selection Modal -->
    <div id="chromecast-device-modal" class="modal" style="display: none; z-index: 6000;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="chromecast-modal-header">
                <h3><i class="fas fa-tv"></i> Select Chromecast Device</h3>
                <button class="close-modal" id="close-chromecast-modal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div id="chromecast-device-list" class="chromecast-device-list">
                    <div class="loading-spinner">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Discovering devices...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Magnet Link Modal -->
    <div id="custom-magnet-modal" class="modal" style="display: none; z-index: 6000;">
        <div class="modal-content" style="width: 420px; max-width: 92vw; background: #0f172a; border-radius: 10px; box-shadow: 0 20px 40px rgba(0,0,0,0.5); border: 1px solid rgba(139,92,246,0.25); padding: 12px 12px 10px; position: relative;">
            <button id="close-custom-magnet-modal" style="position: absolute; top: 8px; right: 8px; background: rgba(255,255,255,0.12); color: #fff; border: none; width: 28px; height: 28px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                <i class="fas fa-times"></i>
            </button>
            <h3 style="margin: 0 36px 8px 0; display: flex; align-items: center; gap: 6px; color: #e2e8f0; font-size: 0.95rem; font-weight: 700;">
                <i class="fas fa-magnet" style="color: #a78bfa;"></i> Play Custom Magnet
            </h3>
            <div style="margin: 6px 0 8px;">
                <label for="custom-magnet-input" style="display: block; margin-bottom: 6px; color: #cbd5e1; font-weight: 600; font-size: 0.8rem;">
                    <i class="fas fa-link" style="color: #8b5cf6;"></i> Magnet Link
                </label>
                <input 
                    id="custom-magnet-input"
                    type="text"
                    placeholder="magnet:?xt=urn:btih:..."
                    style="width: 100%; height: 38px; padding: 8px 10px; border: 1.5px solid rgba(139,92,246,0.5); border-radius: 8px; background: #0b1220; color: #e2e8f0; font-size: 0.85rem; font-family: 'Consolas', 'Courier New', monospace; outline: none;"
                    onfocus="this.style.borderColor='#8b5cf6'; this.style.boxShadow='0 0 0 3px rgba(139,92,246,0.15)';"
                    onblur="this.style.borderColor='rgba(139,92,246,0.5)'; this.style.boxShadow='none';"
                />
            </div>
            <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px;">
                <button id="cancel-custom-magnet-btn" style="padding: 8px 14px; border-radius: 8px; font-weight: 600; background: rgba(71,85,105,0.3); border: 1.5px solid rgba(71,85,105,0.5); color: #cbd5e1; cursor: pointer; font-size: 0.85rem;">
                    Cancel
                </button>
                <button id="play-custom-magnet-btn" style="background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%); border: none; padding: 8px 14px; border-radius: 8px; font-weight: 700; display: flex; align-items: center; gap: 6px; color: #fff; cursor: pointer; font-size: 0.85rem;">
                    <i class="fas fa-play-circle"></i> Play
                </button>
            </div>
        </div>
    </div>

    <!-- Video Player Modal -->
    <div id="video-player-modal" class="video-player-modal" style="display: none;">
        <div class="video-player-content">
            <div class="video-player-header">
                <button id="video-player-back" class="video-player-back-btn">
                    <i class="fas fa-arrow-left"></i>
                    Back to Servers
                </button>
                <h3 id="video-player-title">Now Playing</h3>
                <div class="video-player-controls">
                    <button id="video-player-fullscreen" class="video-player-control-btn">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div>
            <div class="video-player-frame-container">
                <iframe id="video-player-frame" class="video-player-frame"></iframe>
            </div>
        </div>
    </div>

    <!-- AudioBooks Page -->
    <div id="audiobooks-page" style="display: none;">
        <!-- Books View -->
        <div id="audiobooks-books-view">
            <div class="page-header-enhanced">
                <div class="page-title-section">
                    <h2 class="section-title">
                        <i class="fas fa-headphones" style="color: #8b5cf6;"></i> <span>AudioBooks</span>
                    </h2>
                    <p class="page-subtitle">Search and stream audiobooks</p>
                </div>
            </div>

            <div class="page-content">
                <!-- Search Section -->
                <div class="search-section" style="margin-bottom: 2rem;">
                    <div class="search-container-books">
                        <input type="text" id="audiobookSearchInput" placeholder="Search for audiobooks..." class="search-input-books">
                        <button id="searchAudioBooksBtn" class="search-btn-books">
                            <i class="fas fa-search"></i> Search
                        </button>
                        <button id="clearAudioBookSearchBtn" class="search-btn-books" style="margin-left: 0.5rem; background: #e74c3c; display: none;">
                            <i class="fas fa-arrow-left"></i> Back to Home
                        </button>
                    </div>
                </div>

                <div id="audiobookSearchResults" class="books-grid">
                    <div class="search-placeholder">
                        <i class="fas fa-headphones" style="font-size: 3rem; color: #8b5cf6; margin-bottom: 1rem;"></i>
                        <h3>Discover AudioBooks</h3>
                        <p>Browse audiobooks or search for your favorites</p>
                    </div>
                </div>

                <!-- Loading indicator -->
                <div id="audiobookLoading" style="display: none; text-align: center; padding: 2rem;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: #8b5cf6;"></i>
                    <p style="margin-top: 1rem; color: #666;">Loading audiobooks...</p>
                </div>

                <!-- Load More Button -->
                <div id="audiobookLoadMoreContainer" style="display: none; text-align: center; margin: 2rem auto; width: 100%;">
                    <button id="audiobookLoadMoreBtn" class="action-btn" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed); padding: 1rem 2.5rem; font-size: 1rem;">
                        <i class="fas fa-plus-circle"></i> Load More
                    </button>
                </div>
            </div>
        </div>

        <!-- Chapters View -->
        <div id="audiobooks-chapters-view" style="display: none;">
            <div class="page-header-enhanced">
                <div class="page-title-section">
                    <button id="audiobooksBackToBooks" class="action-btn" style="margin-right: 1rem;">
                        <i class="fas fa-arrow-left"></i> Back to Books
                    </button>
                    <h2 class="section-title" id="audiobooksChapterBookTitle" style="color: #8b5cf6;">
                        <i class="fas fa-headphones"></i> <span></span>
                    </h2>
                </div>
            </div>

            <div class="page-content">
                <div id="audiobooksChapterLoading" style="display: none; text-align: center; padding: 2rem;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: #8b5cf6;"></i>
                    <p style="margin-top: 1rem; color: #666;">Loading chapters...</p>
                </div>

                <div id="audiobooksChaptersList" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Chapters will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Audio Player (Fixed at bottom within audiobooks page) -->
        <div id="audiobooksPlayer" style="display: none; position: fixed; bottom: 0; left: 240px; right: 0; background: linear-gradient(135deg, #8b5cf6, #7c3aed); padding: 20px; box-shadow: 0 -5px 20px rgba(0,0,0,0.3); z-index: 1000;">
            <button id="audiobooksClosePlayer" style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.2); border: none; color: white; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; transition: all 0.3s;"></button>
            
            <div style="max-width: 1200px; margin: 0 auto;">
                <div style="color: white; margin-bottom: 15px; text-align: center;">
                    <div id="audiobooksPlayerTitle" style="font-size: 18px; font-weight: 600; margin-bottom: 5px;">No Audio Selected</div>
                    <div id="audiobooksPlayerChapter" style="font-size: 14px; opacity: 0.9;"></div>
                    <div style="margin-top: 8px;">
                        <select id="audiobooksPlaybackSpeed" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 12px; padding: 2px 8px; font-size: 12px; cursor: pointer; outline: none;">
                            <option value="0.5" style="background: #7c3aed;">0.5x</option>
                            <option value="0.75" style="background: #7c3aed;">0.75x</option>
                            <option value="1" selected style="background: #7c3aed;">1x (Normal)</option>
                            <option value="1.25" style="background: #7c3aed;">1.25x</option>
                            <option value="1.5" style="background: #7c3aed;">1.5x</option>
                            <option value="1.75" style="background: #7c3aed;">1.75x</option>
                            <option value="2" style="background: #7c3aed;">2x</option>
                            <option value="2.25" style="background: #7c3aed;">2.25x</option>
                            <option value="2.5" style="background: #7c3aed;">2.5x</option>
                            <option value="2.75" style="background: #7c3aed;">2.75x</option>
                            <option value="3" style="background: #7c3aed;">3x</option>
                        </select>
                    </div>
                </div>
                
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                    <button id="audiobooksPrevBtn" class="action-btn" style="background: rgba(255,255,255,0.2); color: white; min-width: 45px; height: 45px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 18px; transition: all 0.3s;"><i class="fas fa-step-backward"></i></button>
                    <button id="audiobooksPlayPauseBtn" class="action-btn" style="background: white; color: #8b5cf6; font-size: 20px; min-width: 55px; height: 55px; padding: 0; display: flex; align-items: center; justify-content: center; transition: all 0.3s;"><i class="fas fa-play"></i></button>
                    <button id="audiobooksNextBtn" class="action-btn" style="background: rgba(255,255,255,0.2); color: white; min-width: 45px; height: 45px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 18px; transition: all 0.3s;"><i class="fas fa-step-forward"></i></button>
                    
                    <div style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <span id="audiobooksCurrentTime" style="color: white; font-size: 13px; min-width: 45px;">0:00</span>
                        <div id="audiobooksProgressBar" style="flex: 1; height: 6px; background: rgba(255,255,255,0.3); border-radius: 3px; cursor: pointer; position: relative;">
                            <div id="audiobooksProgressFilled" style="height: 100%; background: white; border-radius: 3px; width: 0%; position: relative;">
                                <div style="position: absolute; right: -6px; top: 50%; transform: translateY(-50%); width: 12px; height: 12px; background: white; border-radius: 50%; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>
                            </div>
                        </div>
                        <span id="audiobooksDuration" style="color: white; font-size: 13px; min-width: 45px;">0:00</span>
                    </div>

                    <button id="audiobooksVolumeBtn" class="action-btn" style="background: rgba(255,255,255,0.2); color: white; min-width: 45px; height: 45px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 18px; transition: all 0.3s;"><i class="fas fa-volume-up"></i></button>
                    <input type="range" id="audiobooksVolumeSlider" min="0" max="100" value="100" style="width: 80px;">
                </div>
            </div>
        </div>

        <audio id="audiobooksAudioElement" preload="metadata"></audio>
    </div>

    <!-- BookTorrio Page -->
    <div id="booktorrio-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-book-open" style="color: #06b6d4;"></i> <span>BookTorrio</span>
                </h2>
                <p class="page-subtitle">Search and download EPUB books</p>
            </div>
        </div>

        <div class="page-content">
            <!-- Navigation Buttons -->
            <div class="booktorrio-nav" style="margin-bottom: 2rem;">
                <button id="searchTabBtn" class="booktorrio-tab-btn active">
                    <i class="fas fa-search"></i> Search
                </button>
                <button id="libraryTabBtn" class="booktorrio-tab-btn">
                    <i class="fas fa-bookmark"></i> Library
                </button>
            </div>

            <!-- Search Tab -->
            <div id="searchTab" class="booktorrio-tab">
                <div class="search-section" style="margin-bottom: 2rem;">
                    <div class="search-container-books">
                        <input type="text" id="bookSearchInput" placeholder="Search for books..." class="search-input-books">
                        <button id="searchBooksBtn" class="search-btn-books">
                            <i class="fas fa-search"></i> Search
                        </button>
                    </div>
                </div>

                <div id="bookSearchResults" class="books-grid">
                    <div class="search-placeholder">
                        <i class="fas fa-book-open" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                        <h3>Search for Books</h3>
                        <p>Enter a book title above to find EPUB books</p>
                    </div>
                </div>

                <div id="bookSearchLoading" style="display: none; text-align: center; padding: 2rem;">
                    <div class="spinner"></div>
                    <p>Searching for books...</p>
                </div>
            </div>

            <!-- Library Tab (Empty for now) -->
            <div id="libraryTab" class="booktorrio-tab" style="display: none;">
                <div class="search-placeholder">
                    <i class="fas fa-bookmark" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                    <h3>Library</h3>
                    <p>Your saved books will appear here</p>
                </div>
            </div>
        </div>
    </div>

    <!-- EPUB Reader Overlay -->
    <div id="epubReaderOverlay" style="display:none;">
        <div class="reader-header">
            <div class="reader-esc-hint">PlayTorrio Reader</div>
            <div class="reader-title" id="readerTitle"></div>
            <div style="width: 120px;"></div> <!-- Spacer for symmetry -->
        </div>
        <div id="readerContainer"></div>
        <div id="focusRuler"></div>
        <div class="reader-footer">
            <button id="readerBackBtn" class="reader-back-btn" title="Exit reader">
                <i class="fas fa-arrow-left"></i>
                <span>Back</span>
            </button>
            <div class="reader-nav-controls">
                <button id="readerPrevBtn" class="reader-nav-btn" title="Previous page"><i class="fas fa-chevron-left"></i></button>
                <button id="readerNextBtn" class="reader-nav-btn" title="Next page"><i class="fas fa-chevron-right"></i></button>
            </div>
            <div id="readerChapterControls" class="reader-chapter-controls" style="display:none;">
                <span class="chapter-count-label">Chapters: <strong id="readerChapterCount">0</strong></span>
                <input id="readerChapterInput" type="number" min="1" step="1" placeholder="1" title="Enter chapter number" />
                <button id="readerChapterGo" class="reader-nav-btn" title="Go to chapter"><i class="fas fa-arrow-right"></i></button>
            </div>
            <button id="readerSettingsBtn" class="reader-gear" aria-label="Settings"><i class="fas fa-cog"></i></button>
        </div>
        <div id="readerSettingsPanel" class="reader-settings hidden">
            <div class="reader-settings-section">
                <label>Theme</label>
                <div class="settings-row">
                    <button class="theme-btn" data-theme="light">Light</button>
                    <button class="theme-btn" data-theme="dark">Dark</button>
                    <button class="theme-btn" data-theme="night">Night</button>
                </div>
            </div>
            <div class="reader-settings-section">
                <label>Focus Mode</label>
                <div class="settings-row">
                    <button id="focusModeBtn" class="align-btn" style="width:100%"><i class="fas fa-eye"></i> Enable Focus</button>
                </div>
                <div style="font-size: 0.8rem; color: #888; margin-top: 0.5rem; text-align: center;">
                    Use arrow keys to control the line
                </div>
                <div style="margin-top: 0.5rem; display: flex; align-items: center; justify-content: space-between;">
                    <label style="font-size: 0.9rem; color: #ccc;">Speed</label>
                    <input id="focusSpeedInput" type="range" min="1" max="20" value="2" style="width: 60%;">
                    <span id="focusSpeedVal" style="font-size: 0.9rem; width: 20px; text-align: right;">2</span>
                </div>
            </div>
            <div class="reader-settings-section">
                <label>Font</label>
                <select id="readerFont" class="modal-select" style="width:100%">
                    <option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif">System Default</option>
                    <option value="Georgia, Cambria, 'Times New Roman', Times, serif">Serif</option>
                    <option value="Arial, Helvetica, sans-serif">Sans-Serif</option>
                    <option value="'Courier New', Courier, monospace">Monospace</option>
                </select>
            </div>
            <div class="reader-settings-section">
                <div class="settings-row justify">
                    <label>Text Size</label>
                    <span id="readerFontSizeVal">16px</span>
                </div>
                <input id="readerFontSize" type="range" min="12" max="32" step="1" value="16" style="width:100%"/>
            </div>
            <div class="reader-settings-section">
                <div class="settings-row justify">
                    <label>Line Height</label>
                    <span id="readerLineHeightVal">1.5</span>
                </div>
                <input id="readerLineHeight" type="range" min="1.0" max="2.5" step="0.1" value="1.5" style="width:100%"/>
            </div>
            <div class="reader-settings-section">
                <div class="settings-row justify">
                    <label>Content Width</label>
                    <span id="readerWidthVal">80%</span>
                </div>
                <input id="readerWidth" type="range" min="40" max="100" step="5" value="80" style="width:100%"/>
            </div>
            <div class="reader-settings-section">
                <label>Alignment</label>
                <div class="settings-row">
                    <button class="align-btn" data-align="left"><i class="fas fa-align-left"></i></button>
                    <button class="align-btn" data-align="justify"><i class="fas fa-align-justify"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Anime Page -->
    <div id="anime-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-dragon" style="color: #3b82f6;"></i> <span>Anime</span>
                </h2>
                <p class="page-subtitle">Discover and watch anime with torrents</p>
            </div>
        </div>

        <!-- Search Section -->
        <div style="max-width: 900px; margin: 0 auto 2rem;">
            <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 1rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative;">
                <i class="fas fa-search" style="position: absolute; left: 1.5rem; top: 50%; transform: translateY(-50%); color: #3b82f6; font-size: 1.2rem; pointer-events: none;"></i>
                <input id="animeSearchInput" placeholder="Search for anime..." type="text" style="width: 100%; padding: 1rem 1rem 1rem 3rem; background: rgba(0,0,0,0.4); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 10px; color: var(--light); font-size: 1.1rem; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); box-sizing: border-box;" />
            </div>
        </div>

        <!-- Anime Grid -->
        <div id="animeGrid" class="movies-grid" style="margin-top: 2rem;">
            <!-- Anime cards will be loaded here -->
        </div>
        <div class="loading" id="animeLoadingIndicator" style="display: none;">
            <div class="spinner"></div>
            <p>Loading anime...</p>
        </div>
    </div>
<!-- Comics Page -->
<div id="comics-page" style="display: none;">

    <!-- HEADER -->
    <div class="page-header-enhanced" style="display:flex;justify-content:space-between;align-items:center;gap:1rem;flex-wrap:wrap;">
        <div class="page-title-section">
            <h2 class="section-title">
                <i class="fas fa-mask" style="color: #f97316;"></i>
                <span>Comics Library</span>
            </h2>
            <p class="page-subtitle">Read comics from ReadComicOnline (.ru)</p>
        </div>

        <!-- ACTION BUTTONS -->
        <div style="display:flex; gap:10px;">
            <button id="comics-saved-btn" 
                style="padding: 10px 25px; font-size: 15px; font-weight: bold;
                       background: rgba(249,115,22,0.25); color:#f97316;
                       border: 2px solid #f97316; border-radius: 10px; cursor:pointer;
                       transition:0.2s;">
                <i class="fas fa-heart"></i> Saved
            </button>
            <button id="comics-home-btn" 
                style="padding: 10px 25px; font-size: 15px; font-weight: bold;
                       background: rgba(249,115,22,0.25); color:#f97316;
                       border: 2px solid #f97316; border-radius: 10px; cursor:pointer;
                       transition:0.2s;">
                <i class="fas fa-home"></i> Home
            </button>
        </div>
    </div>

    <!-- SEARCH + GENRES -->
    <div id="comics-filter-container" style="max-width: 1000px; margin: 1.5rem auto 2rem; display:flex; flex-wrap:wrap; gap:15px; justify-content:center;">

        <!-- Search -->
        <div style="flex:1; min-width:260px; position:relative;">
            <i class="fas fa-search"
               style="position:absolute; left:1rem; top:50%; transform:translateY(-50%);
                      color:#f97316; font-size:1.1rem; pointer-events:none;"></i>

            <input id="comics-search-input"
                   placeholder="Search for comics (e.g., Batman, Spawn)"
                   type="text"
                   style="width:100%; padding:0.9rem 1rem 0.9rem 2.8rem; background:rgba(0,0,0,0.45);
                          border:2px solid rgba(249,115,22,0.35); border-radius:10px;
                          color:white; font-size:1rem; outline:none; box-sizing:border-box;">
        </div>

        <!-- Genres Dropdown -->
        <div style="min-width:220px;">
            <select id="comics-genres-dropdown"
                    style="width:100%; padding:0.9rem 1rem; background:rgba(0,0,0,0.45);
                           border:2px solid rgba(249,115,22,0.5); border-radius:10px;
                           color:#f97316; font-weight:600; cursor:pointer; font-size:0.95rem;">
                <option value="">Genres</option>
                <!-- JS will populate options -->
            </select>
        </div>

    </div>

    <!-- Action Buttons -->
    <div id="comics-search-container" 
         style="max-width: 1000px; margin: 0 auto 30px; display:flex; gap:10px;
                align-items:center; justify-content:center;">

        <button id="comics-browse-btn"
                style="padding:12px 30px; font-size:16px; font-weight:bold;
                       border:none; border-radius:10px; cursor:pointer;
                       background:linear-gradient(135deg, rgba(249,115,22,0.2),
                       rgba(234,88,12,0.2)); color:#f97316;
                       border:2px solid rgba(249,115,22,0.5);
                       display:none; transition:0.2s;">
            Browse All
        </button>

        <button id="comics-back-btn"
                style="padding:12px 30px; font-size:16px; font-weight:bold;
                       border:none; border-radius:10px; cursor:pointer;
                       background:linear-gradient(135deg, rgba(249,115,22,0.2),
                       rgba(234,88,12,0.2)); color:#f97316;
                       border:2px solid rgba(249,115,22,0.5);
                       display:none; transition:0.2s;">
             Back
        </button>
        
        <button id="comics-zoom-out-btn" style="display:none; padding:12px 15px; font-size:16px; border:none; border-radius:10px; cursor:pointer; background:rgba(255,255,255,0.1); color:white; border:1px solid rgba(255,255,255,0.2); transition:0.2s;">
            <i class="fas fa-search-minus"></i>
        </button>
        <button id="comics-zoom-in-btn" style="display:none; padding:12px 15px; font-size:16px; border:none; border-radius:10px; cursor:pointer; background:rgba(255,255,255,0.1); color:white; border:1px solid rgba(255,255,255,0.2); transition:0.2s;">
            <i class="fas fa-search-plus"></i>
        </button>
        <button id="comics-fullscreen-btn" style="display:none; padding:12px 15px; font-size:16px; border:none; border-radius:10px; cursor:pointer; background:rgba(255,255,255,0.1); color:white; border:1px solid rgba(255,255,255,0.2); transition:0.2s;">
            <i class="fas fa-expand"></i>
        </button>
    </div>

    <!-- COMICS GRID -->
    <div id="comics-container"
         class="movies-grid"
         style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px,1fr));
                gap:20px; max-width:1400px; margin:0 auto;">
        <!-- cards injected by JS -->
    </div>

    <!-- LOAD MORE -->
    <div id="comics-load-more-container"
         style="text-align:center; margin:2rem auto; max-width:1400px; display:none;">
        <button id="comics-load-more-btn"
                style="padding:15px 40px; font-size:18px; font-weight:bold;
                       border:none; border-radius:12px; cursor:pointer;
                       background:linear-gradient(135deg,#f97316,#ea580c); color:white;
                       transition:0.2s; box-shadow:0 4px 12px rgba(249,115,22,0.4);">
            <i class="fas fa-arrow-down"></i> Load More Comics
        </button>
    </div>

    <!-- ISSUES LIST -->
    <div id="comics-issues-container"
         style="max-width:1400px; margin:0 auto; display:none;">
        <!-- chapters injected by JS -->
    </div>

    <!-- READER -->
    <div id="comics-reader-container"
         style="max-width:1000px; margin:0 auto; display:none;">
         <div id="comics-page-loader"
              style="text-align:center; padding:20px; color:#888;">
              Loading pages...
         </div>
    </div>

    <!-- MAIN LOADING -->
    <div id="comics-loading"
         style="text-align:center; padding:20px; font-size:18px; color:#888;">
         Loading...
    </div>
</div>


    <!-- Manga Page -->
    <div id="manga-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section" style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                <h2 class="section-title" style="margin: 0;">
                    <i class="fas fa-book-reader" style="color: #ec4899;"></i> <span>Manga</span>
                </h2>
                <div id="manga-source-buttons" style="display: flex; gap: 1rem;">
                    <button id="weebcentral-btn" class="provider-btn active">WeebCentral</button>
                    <button id="comix-btn" class="provider-btn">Comix</button>
                    <button id="manga-saved-btn" class="provider-btn"><i class="fas fa-heart"></i> Saved</button>
                </div>
            </div>
            <p id="manga-source-subtitle" class="page-subtitle">Read manga from WeebCentral</p>
        </div>

        <!-- Search Section -->
        <div style="max-width: 900px; margin: 0 auto 2rem;">
            <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 1rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative; display: flex; gap: 1rem; align-items: center;">
                <div style="position: relative; flex-grow: 1;">
                    <i class="fas fa-search" style="position: absolute; top: 50%; left: 1rem; transform: translateY(-50%); color: #ec4899; font-size: 1.2rem; pointer-events: none;"></i>
                    <input id="mangaSearchInput" placeholder="Search for manga..." type="text" style="width: 100%; padding: 1rem 1rem 1rem 3rem; background: rgba(0,0,0,0.4); border: 2px solid rgba(236, 72, 153, 0.3); border-radius: 10px; color: var(--light); font-size: 1.1rem; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); box-sizing: border-box;" />
                </div>
                <div id="manga-categories-container" style="display: none;">
                    <select id="manga-categories-dropdown" class="livetv-category-dropdown" style="width: 200px; border-color: rgba(236, 72, 153, 0.3); background: linear-gradient(135deg, rgba(236, 72, 153, 0.12), rgba(236, 72, 153, 0.08));">
                        <option value="">All Categories</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Manga Grid -->
        <div id="mangaGrid" class="movies-grid" style="margin-top: 2rem;">
            <!-- Manga cards will be loaded here -->
        </div>
        <div class="loading" id="mangaLoadingIndicator" style="display: none;">
            <i class="fas fa-spinner"></i> Loading manga...
        </div>
    </div>

    <!-- Manga Reader Page -->
    <div id="manga-reader-page" style="display: none; background: #000; min-height: 100vh; position: relative;">
        <!-- Floating Controls -->
        <div id="mangaReaderControls" style="position: sticky; top: 1rem; left: 1rem; z-index: 1000; display: flex; gap: 10px; width: fit-content; margin-bottom: 1rem;">
            <button id="mangaReaderBack" style="background: var(--secondary); border: none; padding: 0.75rem 1.5rem; border-radius: 8px; color: white; font-size: 1rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); box-shadow: 0 4px 12px rgba(0,0,0,0.5);">
                <i class="fas fa-arrow-left"></i> Back
            </button>
            <button id="mangaZoomOut" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 0.75rem 1rem; border-radius: 8px; color: white; cursor: pointer; backdrop-filter: blur(5px); transition: background 0.2s;">
                <i class="fas fa-search-minus"></i>
            </button>
            <button id="mangaZoomIn" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 0.75rem 1rem; border-radius: 8px; color: white; cursor: pointer; backdrop-filter: blur(5px); transition: background 0.2s;">
                <i class="fas fa-search-plus"></i>
            </button>
            <button id="mangaFullscreenBtn" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 0.75rem 1rem; border-radius: 8px; color: white; cursor: pointer; backdrop-filter: blur(5px); transition: background 0.2s;">
                <i class="fas fa-expand"></i>
            </button>
        </div>
        
        <!-- Keyboard Navigation Hint -->
        <div style="position: fixed; right: 1.5rem; top: 50%; transform: translateY(-50%); z-index: 900; background: rgba(0,0,0,0.7); padding: 1rem; border-radius: 8px; color: white; font-size: 0.9rem; text-align: center; backdrop-filter: blur(10px); box-shadow: 0 4px 12px rgba(0,0,0,0.5); max-width: 120px;">
            <i class="fas fa-keyboard" style="font-size: 1.5rem; margin-bottom: 0.5rem; display: block;"></i>
            <p style="margin: 0; line-height: 1.4;">Use arrow keys to scroll</p>
            <div style="margin-top: 0.5rem; font-size: 1.2rem;">
                <div><i class="fas fa-arrow-up"></i></div>
                <div><i class="fas fa-arrow-down"></i></div>
            </div>
        </div>

        <div id="mangaReaderTitle" style="text-align: center; padding: 1rem; color: white; font-size: 1.5rem; font-weight: 600;">
            <!-- Chapter title will be here -->
        </div>
        <div id="mangaReaderPages" style="max-width: 1200px; margin: 0 auto; padding: 1rem;">
            <!-- Manga pages will be loaded here -->
        </div>
        <div id="mangaReaderLoading" style="text-align: center; padding: 3rem; color: white;">
            <i class="fas fa-spinner fa-spin" style="font-size: 3rem; margin-bottom: 1rem;"></i>
            <p style="font-size: 1.2rem;">Loading chapter...</p>
        </div>
    </div>

    <!-- Manga Details Modal -->
    <div id="mangaDetailsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 2rem auto; padding: 2rem; position: relative;">
            <button id="mangaDetailsClose" style="position: absolute; top: 1rem; right: 1rem; background: rgba(255,255,255,0.1); border: none; width: 40px; height: 40px; border-radius: 50%; color: white; font-size: 1.5rem; cursor: pointer; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);">
                <i class="fas fa-times"></i>
            </button>
            
            <div style="display: flex; gap: 2rem; margin-bottom: 2rem;">
                <img id="mangaDetailsCover" src="" alt="Manga Cover" style="width: 300px; height: 450px; object-fit: cover; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.5);">
                <div style="flex: 1; color: white;">
                    <h2 id="mangaDetailsTitle" style="font-size: 2.5rem; margin-bottom: 1rem; color: #ec4899;"></h2>
                    <p id="mangaDetailsAuthor" style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #9ca3af;"></p>
                    <p id="mangaDetailsStatus" style="font-size: 1rem; margin-bottom: 1rem; color: #9ca3af;"></p>
                    <div id="mangaDetailsTags" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1.5rem;">
                        <!-- Tags will be here -->
                    </div>
                    <p id="mangaDetailsDescription" style="line-height: 1.6; color: #d1d5db; font-size: 1rem;">
                        <!-- Description will be here -->
                    </p>
                </div>
            </div>
            
            <div>
                <h3 style="color: white; font-size: 1.5rem; margin-bottom: 1rem;">
                    <i class="fas fa-list"></i> Chapters
                </h3>
                <div id="mangaChaptersList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; max-height: 500px; overflow-y: auto;">
                    <!-- Chapters will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Downloader Page -->
    <div id="downloader-page" style="display: none;">
        <div class="page-header-enhanced">
            <div class="page-title-section">
                <h2 class="section-title">
                    <i class="fas fa-download" style="color: #a855f7;"></i> <span>Downloader</span>
                </h2>
                <p class="page-subtitle">Download and manage your media files</p>
            </div>
        </div>

        <div class="trakt-container">
            <div class="trakt-card">
                <div class="trakt-card-body">
                    <div class="downloader-type-toggle" style="justify-content: center; margin-left: 0; margin-bottom: 1rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 1rem; width: 100%;">
                        <button id="provider111477" class="filter-btn active">111477</button>
                        <button id="providerAcermovies" class="filter-btn">acermovies</button>
                    </div>

                    <div id="111477-content">
                        <div class="downloader-search">
                            <input id="downloaderQuery" type="text" placeholder="Search movies or shows (e.g., Superman)" />
                            <button id="downloaderSearchBtn"><i class="fas fa-search"></i></button>
                            <div class="downloader-type-toggle">
                                <button id="downloaderFilterMovies" class="filter-btn active">Movies</button>
                                <button id="downloaderFilterTV" class="filter-btn">TV Shows</button>
                            </div>
                        </div>
                    </div>
                    <div id="acermovies-content" style="display: none;">
                        <!-- acermovies content will be loaded here -->
                    </div>

                    <div id="downloaderResults" class="downloader-results"></div>
                    <div id="downloaderEmpty" class="downloader-empty" style="display:none;">Type a search above to see results.</div>
                </div>
            </div>
        </div>
    </div>
</main>
    </div> <!-- End app-main -->
</div> <!-- End app-container -->

<!-- Anime Details Modal -->
<div class="modal" id="animeDetailsModal">
<div class="modal-content">
<button class="modal-close" id="animeModalClose">
<i class="fas fa-times"></i>
</button>
<div class="modal-header">
<img alt="Backdrop" class="modal-backdrop" id="animeModalBackdrop" src=""/>
<div class="modal-header-content">
<img alt="Poster" class="modal-poster" id="animeModalPoster" src=""/>
<div>
<h1 class="modal-title" id="animeModalTitle">Anime Title</h1>
<div class="modal-info">
<div class="modal-rating">
<i class="fas fa-star"></i> <span id="animeModalRating">0.0</span>
</div>
<div class="modal-year" id="animeModalYear">2023</div>
<div class="modal-runtime" id="animeModalEpisodes">24 Episodes</div>
</div>
<p class="modal-tagline" id="animeModalGenres">Action, Adventure</p>
</div>
</div>
</div>
<div class="modal-body">
<h3 class="modal-section-title">
<i class="fas fa-book-open"></i> Synopsis
</h3>
<p class="modal-overview" id="animeModalOverview">Synopsis goes here...</p>

<!-- Season/Episode Selector (only for series, not movies) -->
<div id="animeSeasonEpisodeContainer" style="display: none; margin: 1.5rem 0;">
<h3 class="modal-section-title">
<i class="fas fa-film"></i> Select Season & Episode
</h3>
<div style="display: flex; gap: 1rem; flex-wrap: wrap;">
    <div style="flex: 1; min-width: 200px;">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--light); font-weight: 500; font-size: 0.95rem;">
            <i class="fas fa-layer-group"></i> Season
        </label>
        <select id="animeSeasonSelector" style="width: 100%; padding: 0.75rem; background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.15)); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; color: var(--light); font-size: 1rem; cursor: pointer; font-weight: 500; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);">
            <option value="" style="background: #1a1a2e; color: var(--light);">All Seasons</option>
        </select>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--light); font-weight: 500; font-size: 0.95rem;">
            <i class="fas fa-play-circle"></i> Episode
        </label>
        <select id="animeEpisodeSelector" style="width: 100%; padding: 0.75rem; background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.15)); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; color: var(--light); font-size: 1rem; cursor: pointer; font-weight: 500; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);">
            <option value="" style="background: #1a1a2e; color: var(--light);">All Episodes</option>
        </select>
    </div>
</div>
<div style="background: rgba(59, 130, 246, 0.1); border-left: 3px solid #3b82f6; padding: 0.75rem 1rem; margin-top: 1rem; border-radius: 6px; font-size: 0.9rem; color: var(--light);">
<i class="fas fa-info-circle" style="color: #3b82f6; margin-right: 0.5rem;"></i>
<strong>Tip:</strong> Select "All Seasons" or "All Episodes" to find complete packs, or choose a specific season/episode for targeted results.
</div>
</div>

<!-- Realm Streaming Sources Button (outside container so it shows for movies too) -->
<div style="margin: 1.5rem 0; display: flex; gap: 0.75rem; flex-wrap: wrap;">
    <button id="animeDirectStreamBtn" style="flex: 1; min-width: 150px; padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 8px; color: white; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; transition: all 0.3s ease;">
        <i class="fas fa-external-link-alt"></i> Direct Stream
    </button>
    <button id="animeRealmSourcesBtn" style="flex: 1; min-width: 150px; padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #8b5cf6, #6d28d9); border: none; border-radius: 8px; color: white; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; transition: all 0.3s ease;">
        <i class="fas fa-play-circle"></i> Stream from Realm
    </button>
    <button id="animeFindTorrentsBtn" style="flex: 1; min-width: 150px; padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; border-radius: 8px; color: white; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; transition: all 0.3s ease;">
        <i class="fas fa-magnet"></i> Find Torrents
    </button>
</div>

<!-- Realm Sources Container -->
<div class="torrents-container" id="animeRealmSourcesContainer" style="display: none; margin-top: 1.5rem;">
<div class="torrents-header">
<h3 class="modal-section-title">
<i class="fas fa-server"></i> Realm Streaming Sources
</h3>
<div class="torrent-actions">
<button class="btn btn-outline" id="animeRefreshRealmSources">
<i class="fas fa-sync"></i> Refresh
</button>
</div>
</div>

<div class="torrents-list" id="animeRealmSourcesList">
<!-- Realm sources will be loaded here -->
</div>
</div>

<!-- Torrents section -->
<div class="torrents-container" id="animeTorrentsContainer" style="display: none;">
<div class="torrents-header">
<h3 class="modal-section-title">
<i class="fas fa-magnet"></i> Available Torrents from Nyaa
</h3>
<div class="torrent-actions">
<button class="btn btn-outline" id="animeRefreshTorrents">
<i class="fas fa-sync"></i> Refresh
</button>
</div>
</div>

<!-- Custom Search Section -->
<div style="margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
<h4 style="color: var(--light); font-size: 0.95rem; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
<i class="fas fa-search" style="color: #3b82f6;"></i>
Can't find what you're looking for? Try a custom search
</h4>
<div style="display: flex; gap: 0.5rem; align-items: stretch;">
<input type="text" id="animeCustomSearchInput" placeholder="Enter your own search query (e.g., 'Dragon Ball S02E01 1080p')" style="flex: 1; padding: 0.75rem 1rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; color: var(--light); font-size: 0.95rem;">
<button id="animeCustomSearchBtn" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; border-radius: 8px; color: white; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);">
<i class="fas fa-search"></i> Search
</button>
</div>
</div>

<div style="margin-bottom: 1rem;">
<input type="text" id="animeTorrentKeywordFilter" placeholder="Filter torrents by keyword (e.g., 1080p, BluRay, SubsPlease)..." style="width: 100%; padding: 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--light); font-size: 0.95rem;">
</div>
<div class="torrents-list" id="animeTorrentsList">
<!-- Torrents will be loaded here -->
</div>
</div>
</div>
</div>
</div>

<!-- Movie/Show Details Modal -->
<div class="modal" id="detailsModal">
<div class="modal-content">
<button class="modal-close" id="modalClose">
<i class="fas fa-times"></i>
</button>
<div class="modal-header">
<img alt="Backdrop" class="modal-backdrop" id="modalBackdrop" src=""/>
<div class="modal-header-content">
<img alt="Poster" class="modal-poster" id="modalPoster" src=""/>
<div>
<h1 class="modal-title" id="modalTitle">Movie Title</h1>
<div class="modal-info">
<div class="modal-rating">
<i class="fas fa-star"></i> <span id="modalRating">0.0</span>
</div>
<div class="modal-year" id="modalYear">2023</div>
<div class="modal-runtime" id="modalRuntime">120 min</div>
</div>
<p class="modal-tagline" id="modalTagline">Tagline goes here</p>
<div class="modal-actions-container">
    <div class="primary-actions">
        <button class="btn-enhanced btn-enhanced-primary" id="watchNowBtn">
            <div class="btn-icon">
                <i class="fas fa-play-circle"></i>
            </div>
            <div class="btn-content">
                <span class="btn-title">Find Media</span>
                <span class="btn-subtitle">Search torrents & streams</span>
            </div>
        </button>
        <button class="btn-enhanced btn-enhanced-secondary" id="useStreamsBtn">
            <div class="btn-icon">
                <i class="fas fa-broadcast-tower"></i>
            </div>
            <div class="btn-content">
                <span class="btn-title">Direct Streams</span>
                <span class="btn-subtitle">No downloads needed</span>
            </div>
        </button>
    </div>
    <div class="secondary-actions">
        <button class="btn-icon-only" id="watchTrailerBtn" title="Watch Trailer">
            <i class="fas fa-film"></i>
        </button>
        <button class="btn-icon-only" id="traktWatchlistBtn" style="display: none;" title="Add to Watchlist">
            <i class="fas fa-plus"></i>
        </button>
        <button class="btn-icon-only done-watching-btn" id="modalDoneWatchingBtn" title="Done Watching">
            <i class="fas fa-check"></i>
        </button>
    </div>
    <div id="watchNowNote" class="action-note" style="display:none;">
        <i class="fas fa-info-circle"></i>
        Please select an episode first
    </div>
</div>
</div>
</div>
</div>
<div class="modal-body">
<h3 class="modal-section-title">
<i class="fas fa-book-open"></i> Overview
                </h3>
<p class="modal-overview" id="modalOverview">Overview goes here...</p>

<!-- Seasons selector for TV shows -->
<div class="seasons-container" id="seasonsContainer" style="display: none;">
<h3 class="modal-section-title">
<i class="fas fa-tv"></i> Seasons
                    </h3>
<div style="background: rgba(139, 92, 246, 0.1); border-left: 3px solid var(--secondary); padding: 0.75rem 1rem; margin-bottom: 1rem; border-radius: 6px; font-size: 0.9rem; color: var(--light);">
<i class="fas fa-info-circle" style="color: var(--secondary); margin-right: 0.5rem;"></i>
<strong>Tip:</strong> Click a <strong>Season</strong> button to find torrents for the entire season, or click a specific <strong>Episode</strong> to find torrents for just that episode.
</div>
<div class="season-selector" id="seasonSelector">
<!-- Seasons buttons will be loaded here -->
</div>
<h3 class="modal-section-title">
<i class="fas fa-list"></i> Episodes
                    </h3>
<div class="episodes-grid" id="episodesGrid">
<!-- Episodes will be loaded here -->
</div>
</div>

<h3 class="modal-section-title">
<i class="fas fa-users"></i> Cast
                </h3>
<div class="cast-grid" id="castGrid">
<!-- Cast members will be loaded here -->
</div>

<h3 class="modal-section-title">
<i class="fas fa-thumbs-up"></i> Similar Content
                </h3>
<div class="similar-grid" id="similarGrid">
<!-- Similar movies/shows will be loaded here -->
</div>

<!-- Torrents section -->
<div class="torrents-container" id="torrentsContainer">
<div class="torrents-header">
<h3 class="modal-section-title">
<i class="fas fa-magnet"></i> Available Torrents
                        </h3>
<div class="torrent-actions">
    <label for="torrentSortSelect" style="margin-right: 0.5rem; font-size:0.9rem; opacity:0.85;">Sort:</label>
    <select id="torrentSortSelect" class="modal-select" style="margin-right: 0.5rem;">
        <option value="seeders">Seeds (default)</option>
        <option value="size-desc">Size: High  Low</option>
        <option value="size-asc">Size: Low  High</option>
    </select>
    <label for="torrentSizeFilterSelect" style="margin: 0 0.5rem 0 0.25rem; font-size:0.9rem; opacity:0.85;">Size:</label>
    <select id="torrentSizeFilterSelect" class="modal-select" style="margin-right: 0.5rem;">
        <option value="all">All sizes</option>
        <option value="gte-1g"> 1 GB</option>
        <option value="gte-2g"> 2 GB</option>
        <option value="2-4g">24 GB</option>
        <option value="4-8g">48 GB</option>
        <option value="gte-8g"> 8 GB</option>
    </select>
<button class="btn btn-outline" id="refreshTorrents">
<i class="fas fa-sync"></i> Refresh
                            </button>
</div>
</div>
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-left: 4px solid #ffd700; padding: 1rem; margin-bottom: 1.5rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);">
<div style="display: flex; align-items: center; gap: 0.75rem;">
<i class="fas fa-volume-up" style="color: #ffd700; font-size: 1.5rem;"></i>
<div>
<strong style="color: #fff; font-size: 1.05rem;">Audio Issues?</strong>
<p style="margin: 0.25rem 0 0 0; color: rgba(255, 255, 255, 0.9); font-size: 0.95rem;">
If you experience audio problems or no audio at all, click <strong>"Open in MPV"</strong> for the best playback experience.
                        </p>
</div>
</div>
</div>
<div class="provider-buttons">
    <button class="provider-btn active" data-provider="jackett">
        <i class="fas fa-link"></i> Jackett
    </button>

    <button class="provider-btn" data-provider="torrentio">
        <i class="fas fa-rocket"></i> Torrentio
    </button>

    <button class="provider-btn" data-provider="torrentless">
        <i class="fas fa-tools"></i> PlayTorrio
    </button>

    <button class="provider-btn" data-provider="nuvio">
        <i class="fas fa-stream"></i> Nuvio <span style="font-size: 0.8em; opacity: 0.8;">(ShowBox)</span>
    </button>

    <button class="provider-btn" data-provider="comet">
        <i class="fas fa-meteor"></i> Comet
    </button>

    <button class="provider-btn" data-provider="111477">
        <i class="fas fa-play-circle"></i> 111477
    </button>

    <button class="provider-btn" data-provider="moviebox">
        <i class="fas fa-film"></i> Moviebox
    </button>

    <button class="provider-btn" data-provider="xdmovies">
        <i class="fas fa-film"></i> XDMovies
    </button>

    <button class="provider-btn" data-provider="aiostreams">
        <i class="fas fa-bolt"></i> AIOStreams
    </button>
</div>

</button>
</div>
<div style="margin-bottom: 1rem;">
<input type="text" id="torrentKeywordFilter" placeholder="Filter torrents by keyword..." style="width: 100%; padding: 0.6rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--light); font-size: 0.95rem;">
</div>
<div class="torrents-list" id="torrentsList">
<!-- Torrents will be loaded here -->
</div>
</div>
</div>
</div>
</div>

<!-- Trailer Modal -->
<div id="trailerModal" class="modal" style="z-index: 10001;">
    <div class="modal-content" style="max-width: 900px; background: #0a0a0f;">
        <button class="modal-close" id="trailerModalClose">
            <i class="fas fa-times"></i>
        </button>
        <div style="padding: 1rem;">
            <h2 style="margin-bottom: 1rem; font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
                <i class="fas fa-film" style="color: var(--secondary);"></i>
                <span id="trailerModalTitle">Trailer</span>
            </h2>
            <div id="trailerContainer" style="aspect-ratio: 16/9; background: #000; border-radius: 8px; overflow: hidden;">
                <div id="trailerPlaceholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; color: rgba(255,255,255,0.5);">
                    <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                    <p>Loading trailer...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Embedded Player Overlay (iframe) -->
<div id="player-overlay" class="fixed inset-0 z-[10000] bg-black hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; background: #000; display: none;">
    <iframe id="player-iframe" style="width: 100%; height: 100%; border: 0;" allowfullscreen></iframe>
</div>

<script>
    // Player overlay management for main app
    window.playerOverlay = {
        overlay: null,
        iframe: null,
        currentStreamHash: null,
        isAltEngine: false,
        
        init() {
            this.overlay = document.getElementById('player-overlay');
            this.iframe = document.getElementById('player-iframe');
            
            // Listen for messages from the player iframe
            window.addEventListener('message', (event) => {
                if (event.data?.type === 'player-close') {
                    this.close();
                } else if (event.data?.type === 'player-cleanup') {
                    // Player requests cleanup of specific hash
                    if (event.data.hash) {
                        this.currentStreamHash = event.data.hash;
                        this.isAltEngine = event.data.isAltEngine || false;
                    }
                }
            });
        },
        
        open(playerUrl, streamHash, isAltEngine = false) {
            if (!this.overlay || !this.iframe) this.init();
            this.currentStreamHash = streamHash || null;
            this.isAltEngine = isAltEngine;
            this.iframe.src = playerUrl;
            this.overlay.style.display = 'block';
            document.body.style.overflow = 'hidden';
        },
        
        close() {
            if (!this.overlay) return;
            
            // Cleanup stream if we have a hash (local torrent stream)
            if (this.currentStreamHash) {
                const endpoint = this.isAltEngine ? '/api/alt-stop-stream' : '/api/stop-stream';
                fetch(`http://localhost:6987${endpoint}?hash=${this.currentStreamHash}`).catch(() => {});
                this.currentStreamHash = null;
                this.isAltEngine = false;
            }
            
            this.overlay.style.display = 'none';
            this.iframe.src = 'about:blank';
            document.body.style.overflow = '';
        }
    };
    
    // Helper function to open player in iframe mode
    window.openPlayerInIframe = async function(options) {
        const {
            url,
            tmdbId,
            imdbId,
            seasonNum,
            episodeNum,
            type,
            isDebrid,
            isBasicMode,
            showName,
            provider,
            providerUrl,
            quality
        } = options;
        
        // Check if NodeMPV is enabled (Windows only) - use Electron IPC for that
        if (window.electronAPI?.spawnMpvjsPlayer) {
            try {
                const settingsRes = await fetch('/api/settings');
                const settings = await settingsRes.json();
                if (settings.useNodeMPV) {
                    console.log('[Player] Using NodeMPV player');
                    window.electronAPI.spawnMpvjsPlayer(options);
                    return { success: true };
                }
            } catch (e) {
                console.warn('[Player] Failed to check NodeMPV setting:', e);
            }
        }
        
        // Build player URL with query params for HTML5 player
        const params = new URLSearchParams();
        if (url) params.append('url', url);
        if (tmdbId) params.append('tmdbId', tmdbId);
        if (imdbId) params.append('imdbId', imdbId);
        if (seasonNum) params.append('season', seasonNum);
        if (episodeNum) params.append('episode', episodeNum);
        if (type) params.append('type', type);
        if (isDebrid) params.append('isDebrid', '1');
        if (isBasicMode) params.append('isBasicMode', '1');
        if (showName) params.append('showName', showName);
        if (provider) params.append('provider', provider);
        if (providerUrl) params.append('providerUrl', providerUrl);
        if (quality) params.append('quality', quality);
        
        const playerUrl = `http://localhost:6987/player.html?${params.toString()}`;
        
        // Extract stream hash for cleanup (if local WebTorrent stream)
        let streamHash = null;
        if (url && url.includes('/api/stream-file')) {
            try {
                const urlObj = new URL(url);
                streamHash = urlObj.searchParams.get('hash');
            } catch (e) {}
        }
        
        // Use the playerOverlay (HTML5 player)
        if (window.playerOverlay) {
            window.playerOverlay.open(playerUrl, streamHash);
            return { success: true };
        }
        
        return { success: false, message: 'Player overlay not available' };
    };
    
    // Initialize on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => window.playerOverlay.init());
    } else {
        window.playerOverlay.init();
    }
</script>

<!-- MPV Player -->
<div class="vlc-player-container" id="mpvPlayerContainer">
<div class="vlc-player-header">
<div class="vlc-player-title" id="mpvPlayerTitle">Player <span class="source-badge webtorrent" id="streamSourceBadge" title="Streaming source">by ayman</span></div>
</div>
<div class="vlc-player-content">
<div class="file-selector" id="fileSelector">
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
    <h3 style="margin: 0;"><i class="fas fa-folder-open"></i> Select File to Play</h3>
    <button class="close-player-btn" id="closePlayerBtn" title="Close Player (Esc)" style="padding: 0.5rem 1rem; background: var(--vlc-orange); border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.95rem;">
        <i class="fas fa-times"></i> Close
    </button>
</div>
<div class="file-list" id="fileList">
<!-- Files will be loaded here -->
</div>
</div>

<div class="subtitle-controls" id="subtitleControls" style="display: none;">
<h4><i class="fas fa-closed-captioning"></i> Available Subtitles:</h4>
<div id="subtitleList">
<!-- Subtitle files will be loaded here -->
</div>
</div>

<div class="vlc-player-area" id="mpvPlayerArea">
<div class="vlc-loading" id="mpvLoading">
<i class="fas fa-spinner"></i>
<span>Loading</span>
</div>
</div>

<div class="vlc-controls" id="mpvControls" style="display: none;">
    <button class="vlc-btn secondary" id="copyStreamBtn">
        <i class="fas fa-copy"></i> Copy Link
    </button>
    <button class="vlc-btn" id="playNowBtn">
        <i class="fas fa-play"></i> Play Now
    </button>
    <button class="vlc-btn" id="openMPVBtn">
        <i class="fas fa-external-link-alt"></i> Open in MPV
    </button>
    <button class="vlc-btn" id="openVLCBtn">
        <i class="fas fa-external-link-alt"></i> Open in VLC
    </button>
</div>
</div>
</div>

<!-- Custom Video Player -->
<div class="custom-player-container" id="customPlayerContainer">
<div class="player-header">
<div class="player-title" id="customPlayerTitle">
<i class="fas fa-play-circle"></i>
<span>Custom Player</span> <span class="source-badge webtorrent" id="customSourceBadge" title="Streaming source">WebTorrent</span>
</div>
<button class="close-player-btn" id="closeCustomPlayer" title="Close Player (Esc)">
    <i class="fas fa-times"></i> Close
</button>
</div>


<div class="video-container" id="videoContainer">
<video class="custom-video video-js" id="customVideo" preload="metadata">
<source id="videoSource" src="" type="video/mp4">
Your browser does not support the video tag.
</video>

<div class="loading-overlay" id="loadingOverlay">
<i class="fas fa-spinner"></i>
<span>Loading video...</span>
</div>

<div class="subtitle-display" id="subtitleDisplay"></div>

<div class="video-controls" id="videoControls">
<div class="progress-container">
<div class="progress-bar" id="progressBar">
<div class="progress-filled" id="progressFilled"></div>
</div>
<div class="progress-time">
<span id="currentTime">0:00</span>
<span id="totalTime">0:00</span>
</div>
</div>

<div class="control-bar">
    <div class="control-left">
        <button class="control-btn" id="rewindBtn" title="Rewind 10s"><i class="fas fa-backward"></i></button>
        <button class="control-btn play-pause" id="playPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
        <button class="control-btn" id="forwardBtn" title="Forward 10s"><i class="fas fa-forward"></i></button>
    </div>
    <div class="control-right">
        <div class="volume-group">
                <button class="control-btn" id="htmlMuteBtn" title="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
                <input type="range" id="htmlVolume" class="volume-slider" min="0" max="100" value="80" />
        </div>
        <button class="control-btn" id="htmlSubsBtn" title="Subtitles"><i class="fas fa-closed-captioning"></i></button>
        
        <button class="control-btn" id="fullscreenBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
    </div>
</div>
</div>
</div>
<div class="subs-panel" id="htmlSubsPanel" style="right: 1rem; bottom: 6rem;">
    <div class="subs-header">
        <div>Subtitles</div>
        <div class="menu-actions">
            <button class="menu-refresh" id="htmlSubsClose">Close</button>
        </div>
    </div>
    
    <!-- Upload Section -->
    <div class="subs-upload">
        <input type="file" id="subtitleFile" accept=".srt,.vtt,.ass,.ssa" style="display:none;" />
        <button class="subs-upload-btn" id="htmlSubsUploadBtn">
            <i class="fas fa-upload"></i> Upload Subtitle File
        </button>
    </div>
    
    <!-- Customization Section -->
    <div class="subs-divider"></div>
    <div class="subs-settings">
        <div class="subs-setting-row">
            <label for="subsSize">Size</label>
            <input type="range" id="subsSize" min="12" max="48" value="22">
            <span class="subs-setting-value" id="subsSizeValue">22px</span>
        </div>
        <div class="subs-setting-row">
            <label for="subsColor">Color</label>
            <input type="color" id="subsColor" value="#ffffff">
        </div>
        <div class="subs-setting-row">
            <label for="subsBackground">Background</label>
            <input type="color" id="subsBackground" value="#000000">
        </div>
        <div class="subs-setting-row">
            <label for="subsBackgroundOpacity">BG Opacity</label>
            <input type="range" id="subsBackgroundOpacity" min="0" max="100" value="75">
            <span class="subs-setting-value" id="subsOpacityValue">75%</span>
        </div>
        <div class="subs-setting-row">
            <label for="subsFont">Font</label>
            <select id="subsFont">
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Courier New', monospace">Courier New</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="'Times New Roman', serif">Times New Roman</option>
                <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                <option value="Impact, fantasy">Impact</option>
            </select>
        </div>
    </div>
    
    <div class="subs-divider"></div>
    <div class="subs-help">Choose a subtitle. Sources: OpenSubtitles, Wyzie</div>
    <div id="htmlSubsList"></div>
</div>
</div>

<!-- WCJS (WebChimera) Player -->
<div class="wcjs-player-container" id="wcjsPlayerContainer" style="opacity:0;pointer-events:none;">
    <div class="player-header">
        <div class="player-title" id="wcjsPlayerTitle">
            <i class="fas fa-vial"></i>
            <span>WebChimera Player</span>
        </div>
        <div class="player-actions">
            <div class="subtitle-upload">
                <input type="file" id="wcjsSubtitleFile" accept=".srt,.vtt,.ass,.ssa" />
                <label for="wcjsSubtitleFile" class="upload-btn">
                    <i class="fas fa-upload"></i> Upload Subtitles
                </label>
            </div>
            <button class="close-player-btn" id="closeWcjsPlayer">
                <i class="fas fa-times"></i> Close
            </button>
        </div>
    </div>

    <style>
        .wcjs-player-container { position: fixed; inset: 0; background:#000; z-index: 3500; display:flex; flex-direction:column; overflow: hidden; }
        .wcjs-canvas-container { flex: 1; position: relative; background:#000; display:flex; align-items:center; justify-content:center; min-height: 0; min-width: 0; overflow: hidden; }
        #wcjsCanvas { width: 100%; height: 100%; display:block; }
        .wcjs-loading { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color: var(--vlc-orange); background: rgba(0,0,0,0.8); font-size:1.2rem; }
        .volume-group { display:flex; align-items:center; gap:0.5rem; margin-left: 1rem; }
        .volume-slider { width: 120px; }
    </style>

    <div class="wcjs-canvas-container">
        <canvas id="wcjsCanvas"></canvas>
        <div class="wcjs-loading" id="wcjsLoading" style="display:none;">
            <i class="fas fa-spinner" style="animation: spin 1.4s cubic-bezier(0.65, 0, 0.35, 1) infinite;"></i>
            <span style="margin-left:0.75rem;">Loading stream...</span>
        </div>
        <div class="video-controls" id="wcjsControls" style="display:block;">
            <div class="progress-container">
                <div class="progress-bar" id="wcjsProgressBar">
                    <div class="progress-filled" id="wcjsProgressFilled"></div>
                </div>
                <div class="progress-time">
                    <span id="wcjsCurrentTime">0:00</span>
                    <span id="wcjsTotalTime">0:00</span>
                </div>
            </div>

            <div class="control-buttons">
                <button class="control-btn" id="wcjsRewindBtn" title="Rewind 10s"><i class="fas fa-backward"></i></button>
                <button class="control-btn play-pause" id="wcjsPlayPauseBtn" title="Play/Pause"><i class="fas fa-play"></i></button>
                <button class="control-btn" id="wcjsForwardBtn" title="Forward 10s"><i class="fas fa-forward"></i></button>
                <div class="volume-group">
                    <button class="control-btn" id="wcjsMuteBtn" title="Mute/Unmute"><i class="fas fa-volume-up"></i></button>
                    <input type="range" id="wcjsVolume" class="volume-slider" min="0" max="100" value="80" />
                </div>
                <button class="control-btn" id="wcjsSubsBtn" title="Subtitles"><i class="fas fa-closed-captioning"></i></button>
                <button class="control-btn" id="wcjsAudioBtn" title="Audio Tracks"><i class="fas fa-headphones"></i></button>
                <button class="control-btn fullscreen-btn" id="wcjsFullscreenBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
            </div>
        </div>
    </div>
    <div class="subs-panel" id="wcjsSubsPanel">
        <div class="subs-header">
            <div>Subtitles</div>
            <div class="menu-actions">
                <button class="menu-refresh" id="wcjsSubsRefresh">Refresh</button>
                <button class="menu-refresh" id="wcjsSubsClose">Close</button>
            </div>
        </div>
        <div class="subs-help">Choose a subtitle. Sources: OpenSubtitles, Wyzie</div>
        <div id="wcjsSubsList"></div>
    </div>
    <div class="subs-panel" id="wcjsAudioPanel" style="right: 360px;">
        <div class="subs-header">
            <div>Audio Tracks</div>
            <div class="menu-actions">
                <button class="menu-refresh" id="wcjsAudioClose">Close</button>
            </div>
        </div>
        <div id="wcjsAudioList"></div>
    </div>
</div>

<!-- Notification -->
<div class="notification" id="notification">Action completed!</div>

<!-- EPUB Download Modal -->
<div id="epubDownloadModal" class="epub-download-modal" style="display: none;">
    <div class="epub-modal-content">
        <div class="epub-modal-header">
            <h3><i class="fas fa-download"></i> Download EPUB Book</h3>
            <button class="epub-modal-close" onclick="closeEpubDownloadModal()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="epub-modal-body">
            <div class="epub-download-instruction">
                <p><strong>Please download the EPUB file to this exact location:</strong></p>
                <div class="epub-path-container">
                    <code id="epubDownloadPath"></code>
                    <button class="copy-path-btn" onclick="copyEpubPath()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <p class="epub-note">After downloading, the book will automatically appear in your Library tab.</p>
            </div>
            <div class="epub-modal-actions">
                <button class="epub-download-btn" onclick="openDownloadLink()">
                    <i class="fas fa-external-link-alt"></i>
                    Download from Browser
                </button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<!-- Video.js JavaScript -->
<script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
<script>
        // UI Mode Management
        let currentUIMode = localStorage.getItem('uiMode') || 'new';
        
        // Apply UI mode on page load
        function applyUIMode(mode) {
            currentUIMode = mode;
            document.body.classList.remove('ui-old', 'ui-new');
            document.body.classList.add(`ui-${mode}`);
            localStorage.setItem('uiMode', mode);
        }
        
        // Initialize UI mode immediately (before DOM loads)
        applyUIMode(currentUIMode);
        
        // Theme Management
        const themes = {
            'default': {
                primary: '#2a1847',
                secondary: '#8b5cf6',
                tertiary: '#c084fc',
                dark: '#120a1f',
                light: '#f8f9fa',
                gray: '#6c757d',
                accent: '#a855f7',
                cardBg: '#2a1847',
                modalBg: 'linear-gradient(135deg, #2a1847, #120a1f)',
                headerBg: '#2a1847',
                inputBg: 'rgba(255, 255, 255, 0.1)',
                hoverBg: 'rgba(168, 85, 247, 0.2)'
            },
            'green-forest': {
                primary: '#1a3a2e',
                secondary: '#4caf50',
                tertiary: '#81c784',
                dark: '#0f1e17',
                light: '#f1f8f4',
                gray: '#6c8073',
                accent: '#66bb6a',
                cardBg: '#1e4d3a',
                modalBg: 'linear-gradient(135deg, #1a3a2e, #0f1e17)',
                headerBg: '#1a3a2e',
                inputBg: 'rgba(76, 175, 80, 0.15)',
                hoverBg: 'rgba(76, 175, 80, 0.25)'
            },
            'cyberpunk-neon': {
                primary: '#1a1a2e',
                secondary: '#ff00ff',
                tertiary: '#00ffff',
                dark: '#0f0f1e',
                light: '#f0f0ff',
                gray: '#7070a0',
                accent: '#ff00aa',
                cardBg: '#252540',
                modalBg: 'linear-gradient(135deg, #1a1a2e, #0f0f1e)',
                headerBg: '#1a1a2e',
                inputBg: 'rgba(255, 0, 255, 0.15)',
                hoverBg: 'rgba(255, 0, 255, 0.3)'
            },
            'ocean-breeze': {
                primary: '#1e3a5f',
                secondary: '#2196f3',
                tertiary: '#64b5f6',
                dark: '#0d1f36',
                light: '#e3f2fd',
                gray: '#607d8b',
                accent: '#42a5f5',
                cardBg: '#2a4a6f',
                modalBg: 'linear-gradient(135deg, #1e3a5f, #0d1f36)',
                headerBg: '#1e3a5f',
                inputBg: 'rgba(33, 150, 243, 0.15)',
                hoverBg: 'rgba(33, 150, 243, 0.25)'
            },
            'cherry-blossom': {
                primary: '#4a2545',
                secondary: '#ff4081',
                tertiary: '#ff80ab',
                dark: '#1a0e1a',
                light: '#fff0f5',
                gray: '#8e7a8b',
                accent: '#f48fb1',
                cardBg: '#5a3555',
                modalBg: 'linear-gradient(135deg, #4a2545, #1a0e1a)',
                headerBg: '#4a2545',
                inputBg: 'rgba(255, 64, 129, 0.15)',
                hoverBg: 'rgba(255, 64, 129, 0.25)'
            },
            'midnight-dark': {
                primary: '#1c1c2e',
                secondary: '#6366f1',
                tertiary: '#818cf8',
                dark: '#0a0a14',
                light: '#e0e7ff',
                gray: '#64748b',
                accent: '#7c3aed',
                cardBg: '#2a2a40',
                modalBg: 'linear-gradient(135deg, #1c1c2e, #0a0a14)',
                headerBg: '#1c1c2e',
                inputBg: 'rgba(99, 102, 241, 0.15)',
                hoverBg: 'rgba(99, 102, 241, 0.25)'
            },
            'sunset-orange': {
                primary: '#3d2a1f',
                secondary: '#ff9800',
                tertiary: '#ffb74d',
                dark: '#1a0f0a',
                light: '#fff3e0',
                gray: '#8d6e63',
                accent: '#fb8c00',
                cardBg: '#4d3a2f',
                modalBg: 'linear-gradient(135deg, #3d2a1f, #1a0f0a)',
                headerBg: '#3d2a1f',
                inputBg: 'rgba(255, 152, 0, 0.15)',
                hoverBg: 'rgba(255, 152, 0, 0.25)'
            }
        };
        
        let currentTheme = localStorage.getItem('appTheme') || 'default';
        
        function applyTheme(themeName) {
            const theme = themes[themeName] || themes['default'];
            const root = document.documentElement;
            
            // Base colors
            root.style.setProperty('--primary', theme.primary);
            root.style.setProperty('--secondary', theme.secondary);
            root.style.setProperty('--tertiary', theme.tertiary);
            root.style.setProperty('--dark', theme.dark);
            root.style.setProperty('--light', theme.light);
            root.style.setProperty('--gray', theme.gray);
            root.style.setProperty('--vlc-orange', theme.accent);
            
            // Extended colors for comprehensive theming
            root.style.setProperty('--card-bg', theme.cardBg);
            root.style.setProperty('--modal-bg', theme.modalBg);
            root.style.setProperty('--header-bg', theme.headerBg);
            root.style.setProperty('--input-bg', theme.inputBg);
            root.style.setProperty('--hover-bg', theme.hoverBg);
            
            currentTheme = themeName;
            localStorage.setItem('appTheme', themeName);
        }
        
        // Initialize theme immediately
        applyTheme(currentTheme);
        
        // API configuration
        const TMDB_API_KEY = 'b3556f3b206e16f82df4d1f6fd4545e6';
        const API_BASE_URL = 'http://localhost:6987/api';
        
        // Streaming Settings (Global)
        let useStreamingServers = localStorage.getItem('useStreamingServers') === 'true';
        let selectedServer = localStorage.getItem('selectedServer') || 'Videasy';
        
        console.log('[DEBUG] JavaScript loaded, useStreamingServers:', useStreamingServers);
        
        // DOM elements - Home
        const moviesGrid = document.getElementById('moviesGrid');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const homePageEl = document.getElementById('homePage');

        // DOM elements - Genres
        const genresBtn = document.getElementById('genresBtn');
        const genresPageEl = document.getElementById('genresPage');
        const genresGrid = document.getElementById('genresGrid');
        const genresLoading = document.getElementById('genresLoading');

        // DOM elements - Genre Details
        const genreDetailsPageEl = document.getElementById('genreDetailsPage');
        const genreTitleEl = document.getElementById('genreTitle');
        const toggleMoviesBtn = document.getElementById('toggleMovies');
        const toggleTVBtn = document.getElementById('toggleTV');
        const genreResultsGrid = document.getElementById('genreResultsGrid');
        const genreLoadingIndicator = document.getElementById('genreLoadingIndicator');
        const genreEmptyMessage = document.getElementById('genreEmptyMessage');

        // DOM elements - Modal and others
        const detailsModal = document.getElementById('detailsModal');
        const modalClose = document.getElementById('modalClose');
        const modalBackdrop = document.getElementById('modalBackdrop');
        const modalPoster = document.getElementById('modalPoster');
        const modalTitle = document.getElementById('modalTitle');
        const modalRating = document.getElementById('modalRating');
        const modalYear = document.getElementById('modalYear');
        const modalRuntime = document.getElementById('modalRuntime');
        const modalTagline = document.getElementById('modalTagline');
        const modalOverview = document.getElementById('modalOverview');
        const castGrid = document.getElementById('castGrid');
        const similarGrid = document.getElementById('similarGrid');
        const torrentsList = document.getElementById('torrentsList');
        const notification = document.getElementById('notification');
        const watchNowBtn = document.getElementById('watchNowBtn');
    const modalDoneWatchingBtn = document.getElementById('modalDoneWatchingBtn');
        const traktWatchlistBtn = document.getElementById('traktWatchlistBtn');
        const seasonsContainer = document.getElementById('seasonsContainer');
        const seasonSelector = document.getElementById('seasonSelector');
        const episodesGrid = document.getElementById('episodesGrid');
        const refreshTorrents = document.getElementById('refreshTorrents');
        const torrentsContainer = document.getElementById('torrentsContainer');
        const torrentKeywordFilter = document.getElementById('torrentKeywordFilter');
        
        // DOM elements - Trailer Modal
        const trailerModal = document.getElementById('trailerModal');
        const trailerModalClose = document.getElementById('trailerModalClose');
        const trailerModalTitle = document.getElementById('trailerModalTitle');
        const trailerContainer = document.getElementById('trailerContainer');
        const trailerPlaceholder = document.getElementById('trailerPlaceholder');
        const watchTrailerBtn = document.getElementById('watchTrailerBtn');
        
        // API Setup Modal elements - REMOVED (modal disabled)
        const apiSetupModal = null; // Modal removed
        const firstTimeApiKey = null;
        const saveFirstTimeApiKey = null;
    const openJackettLinkBtn = null;
        
    // Donate modal removed - no DOM elements
        
        // Discord Modal elements
    const discordModal = document.getElementById('discordModal');
    const discordClose = document.getElementById('discordClose');
    const discordJoinBtn = document.getElementById('discordJoinBtn');
    const discordDontShowBtn = document.getElementById('discordDontShowBtn');
        const discordBtn = document.getElementById('discordBtn');
        
        // Settings Modal elements
        const settingsModal = document.getElementById('settingsModal');
    const clearCacheBtn = document.getElementById('clearCacheBtn');
        const settingsClose = document.getElementById('settingsClose');
        const currentApiKey = document.getElementById('currentApiKey');
        const newApiKey = document.getElementById('newApiKey');
        const saveSettings = document.getElementById('saveSettings');
        const cancelSettings = document.getElementById('cancelSettings');
        const useTorrentlessToggle = document.getElementById('useTorrentlessToggle');
    const jackettUrlInput = document.getElementById('jackettUrl');
    const cacheLocationInput = document.getElementById('cacheLocation');
    const selectCacheBtn = document.getElementById('selectCacheBtn');
    // Debrid controls
    const useDebridToggle = document.getElementById('useDebridToggle');
    const debridProviderSel = document.getElementById('debridProvider');
    const debridStatus = document.getElementById('debridStatus');
    const debridTokenInput = document.getElementById('debridToken');
    const saveDebridTokenBtn = document.getElementById('saveDebridToken');
    const clearDebridTokenBtn = document.getElementById('clearDebridToken');
    const rdClientIdInput = document.getElementById('rdClientId');
    const rdDeviceLoginBtn = document.getElementById('rdDeviceLogin');
    const rdClientIdGroup = document.getElementById('rdClientIdGroup');
    const rdButtons = document.getElementById('rdButtons');
    const rdTokenGroup = document.getElementById('rdTokenGroup');
    const rdTokenButtons = document.getElementById('rdTokenButtons');
    const rdCodePanel = document.getElementById('rdCodePanel');
    const rdUserCodeEl = document.getElementById('rdUserCode');
    const rdVerifyUrlEl = document.getElementById('rdVerifyUrl');
    const rdOpenVerifyBtn = document.getElementById('rdOpenVerify');
    const rdCopyCodeBtn = document.getElementById('rdCopyCode');
    const rdCancelLoginBtn = document.getElementById('rdCancelLogin');
    const rdLoginStatusEl = document.getElementById('rdLoginStatus');
    // AllDebrid controls
    const adSection = document.getElementById('adSection');
    const adStartPinBtn = document.getElementById('adStartPin');
    const adPinPanel = document.getElementById('adPinPanel');
    const adPinCodeEl = document.getElementById('adPinCode');
    const adUserUrlEl = document.getElementById('adUserUrl');
    const adOpenUserUrlBtn = document.getElementById('adOpenUserUrl');
    const adCopyPinBtn = document.getElementById('adCopyPin');
    const adCancelPinBtn = document.getElementById('adCancelPin');
    const adLoginStatusEl = document.getElementById('adLoginStatus');
    const adApiKeyInput = document.getElementById('adApiKey');
    const adSaveApiKeyBtn = document.getElementById('adSaveApiKey');
    const adClearApiKeyBtn = document.getElementById('adClearApiKey');
    // TorBox controls
    const tbSection = document.getElementById('tbSection');
    const tbTokenInput = document.getElementById('tbToken');
    const tbSaveTokenBtn = document.getElementById('tbSaveToken');
    const tbClearTokenBtn = document.getElementById('tbClearToken');
    // Premiumize controls
    const pmSection = document.getElementById('pmSection');
    const pmApiKeyInput = document.getElementById('pmApiKey');
    const pmSaveApiKeyBtn = document.getElementById('pmSaveApiKey');
    const pmClearApiKeyBtn = document.getElementById('pmClearApiKey');
        
    // Trakt controls
    const traktNotConnected = document.getElementById('traktNotConnected');
    const traktConnected = document.getElementById('traktConnected');
    const traktStatus = document.getElementById('traktStatus');
    const traktConnectedStatus = document.getElementById('traktConnectedStatus');
    const traktUsername = document.getElementById('traktUsername');
    const traktLoginBtn = document.getElementById('traktLogin');
    const traktViewWatchlistBtn = document.getElementById('traktViewWatchlist');
    const traktViewHistoryBtn = document.getElementById('traktViewHistory');
    const traktViewStatsBtn = document.getElementById('traktViewStats');
    const traktDisconnectBtn = document.getElementById('traktDisconnect');
    const traktCodePanel = document.getElementById('traktCodePanel');
    const traktUserCodeEl = document.getElementById('traktUserCode');
    const traktVerifyUrlEl = document.getElementById('traktVerifyUrl');
    const traktOpenVerifyBtn = document.getElementById('traktOpenVerify');
    const traktCopyCodeBtn = document.getElementById('traktCopyCode');
    const traktCancelLoginBtn = document.getElementById('traktCancelLogin');
    const traktLoginStatusEl = document.getElementById('traktLoginStatus');
    const traktAutoScrobbleToggle = document.getElementById('traktAutoScrobble');
    const traktScrobbleProgressToggle = document.getElementById('traktScrobbleProgress');
    const traktSyncWatchlistToggle = document.getElementById('traktSyncWatchlist');

        // MPV Player elements
        const mpvPlayerContainer = document.getElementById('mpvPlayerContainer');
        const playerTitle = document.getElementById('mpvPlayerTitle');
        const closePlayerBtn = document.getElementById('closePlayerBtn');
        const fileSelector = document.getElementById('fileSelector');
        const fileList = document.getElementById('fileList');
        const subtitleControls = document.getElementById('subtitleControls');
        const subtitleList = document.getElementById('subtitleList');
        const mpvPlayerArea = document.getElementById('mpvPlayerArea');
        const mpvLoading = document.getElementById('mpvLoading');
    const mpvControls = document.getElementById('mpvControls');
        // Helper: get base filename from a path
        function baseName(p) {
            try { return String(p || '').split(/[\\\/]/).pop(); } catch(_) { return p || ''; }
        }
        const openMPVBtn = document.getElementById('openMPVBtn');
        const openVLCBtn = document.getElementById('openVLCBtn');
        
        // On macOS, change MPV button to IINA
        if (window.electronAPI && window.electronAPI.platform === 'darwin') {
            if (openMPVBtn) {
                openMPVBtn.innerHTML = '<i class="fas fa-external-link-alt"></i> Open in IINA';
                openMPVBtn.id = 'openIINABtn'; // Change ID for clarity
            }
        }
        
        const copyStreamBtn = document.getElementById('copyStreamBtn');
    const playNowBtn = document.getElementById('playNowBtn');
    const streamSourceBadge = document.getElementById('streamSourceBadge');

        // Custom Player elements
        const customPlayerContainer = document.getElementById('customPlayerContainer');
        const customPlayerTitle = document.getElementById('customPlayerTitle');
    const customSourceBadge = document.getElementById('customSourceBadge');
        const closeCustomPlayer = document.getElementById('closeCustomPlayer');
        const customVideo = document.getElementById('customVideo');
        const videoSource = document.getElementById('videoSource');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const subtitleDisplay = document.getElementById('subtitleDisplay');
        const videoControls = document.getElementById('videoControls');
        const progressBar = document.getElementById('progressBar');
        const progressFilled = document.getElementById('progressFilled');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const subtitleFile = document.getElementById('subtitleFile');
    const htmlMuteBtn = document.getElementById('htmlMuteBtn');
    const htmlVolume = document.getElementById('htmlVolume');
    const htmlSubsBtn = document.getElementById('htmlSubsBtn');
    const htmlSubsPanel = document.getElementById('htmlSubsPanel');
    const htmlSubsList = document.getElementById('htmlSubsList');
    const htmlSubsClose = document.getElementById('htmlSubsClose');
    
    // Subtitle customization elements
    const htmlSubsUploadBtn = document.getElementById('htmlSubsUploadBtn');
    const subsSizeInput = document.getElementById('subsSize');
    const subsSizeValue = document.getElementById('subsSizeValue');
    const subsColorInput = document.getElementById('subsColor');
    const subsBackgroundInput = document.getElementById('subsBackground');
    const subsBackgroundOpacityInput = document.getElementById('subsBackgroundOpacity');
    const subsOpacityValue = document.getElementById('subsOpacityValue');
    const subsFontSelect = document.getElementById('subsFont');
    
    // Subtitle settings
    let subtitleSettings = {
        size: 22,
        color: '#ffffff',
        background: '#000000',
        backgroundOpacity: 75,
        font: 'Arial, sans-serif'
    };

    // WCJS Player elements
    const wcjsPlayerContainer = document.getElementById('wcjsPlayerContainer');
    const wcjsPlayerTitle = document.getElementById('wcjsPlayerTitle');
    const wcjsCanvas = document.getElementById('wcjsCanvas');
    const wcjsLoading = document.getElementById('wcjsLoading');
    const closeWcjsPlayer = document.getElementById('closeWcjsPlayer');
    const wcjsControls = document.getElementById('wcjsControls');
    const wcjsProgressBar = document.getElementById('wcjsProgressBar');
    const wcjsProgressFilled = document.getElementById('wcjsProgressFilled');
    const wcjsCurrentTime = document.getElementById('wcjsCurrentTime');
    const wcjsTotalTime = document.getElementById('wcjsTotalTime');
    const wcjsPlayPauseBtn = document.getElementById('wcjsPlayPauseBtn');
    const wcjsRewindBtn = document.getElementById('wcjsRewindBtn');
    const wcjsForwardBtn = document.getElementById('wcjsForwardBtn');
    const wcjsFullscreenBtn = document.getElementById('wcjsFullscreenBtn');
    const wcjsMuteBtn = document.getElementById('wcjsMuteBtn');
    const wcjsVolume = document.getElementById('wcjsVolume');
    const wcjsSubtitleFile = document.getElementById('wcjsSubtitleFile');
    const wcjsSubsBtn = document.getElementById('wcjsSubsBtn');
    const wcjsAudioBtn = document.getElementById('wcjsAudioBtn');
    const wcjsSubsPanel = document.getElementById('wcjsSubsPanel');
    const wcjsAudioPanel = document.getElementById('wcjsAudioPanel');
    const wcjsSubsList = document.getElementById('wcjsSubsList');
    const wcjsAudioList = document.getElementById('wcjsAudioList');
    const wcjsSubsRefresh = document.getElementById('wcjsSubsRefresh');
    const wcjsSubsClose = document.getElementById('wcjsSubsClose');
    const wcjsAudioClose = document.getElementById('wcjsAudioClose');
        
        // Global variables
    let currentPage = 1; // home page pagination
        let isLoading = false; // route-scoped loading flag
        let currentContent = null;
        let currentMediaType = 'movie';
        let currentMovie = null; // Store current movie/show data for Trakt
        let currentSeason = 1;
        let torrentsLoaded = false;
        let currentTorrentData = null;
        let currentStreamUrl = null;
    let currentSelectedVideoName = null; // track selected torrent file name
    let currentDebridTorrentId = null; // track active debrid torrent ID for cleanup
    // Guard to cancel debrid polling when user exits or starts a new debrid flow
    let debridFlowSession = 0;
        let currentSubtitleUrl = null;
        let currentSubtitles = [];
    let subtitleTrack = null;
    let currentSubtitleFile = null; // filename served under /subtitles to delete on switch
    let selectedProvider = 'jackett'; // Default provider: jackett, torrentio, torrentless, nuvio, comet, 111477, xdmovies, aiostreams
    let lastSearchedSeason = null; // Track last searched season for provider switching
    let lastSearchedEpisode = null; // Track last searched episode for provider switching
    
    // Sort and Filter state
    let currentSort = 'popularity'; // popularity, rating, date
    let currentFilter = 'all'; // all, hd, 4k
    let allMoviesCache = []; // Cache for sorting/filtering
    
    // Resume state
    let resumeKey = null; // stable key per item (provider/hash/file or direct link)
    let resumeInfo = null; // { position, duration, updatedAt }
    let resumeTimer = null;
    let lastResumeSend = 0;
    let hasApiKey = false;
    let useTorrentless = false; // global toggle for Torrentless mode
    let useDebrid = false; // global toggle for Debrid
    let debridAuth = false; // token presence depending on provider
    let debridProvider = 'realdebrid';
    let rdAvailabilityDisabled = false; // flag when RD instant availability endpoint is disabled
        let currentCategory = 'all';
        let allTorrents = [];
        let torrentsPage = 1;
        const torrentsPerPage = 20;
        let torrentSortMode = 'seeders'; // 'seeders' | 'size-asc' | 'size-desc'
        let torrentSizeFilter = 'all'; // 'all' | 'gte-1g' | 'gte-2g' | '2-4g' | '4-8g' | 'gte-8g'
        let allNuvioStreams = []; // Cache for Nuvio streams to enable sorting
        
        // Search state tracking
        let isSearchMode = false;
        let lastSearchResults = [];
        let lastSearchQuery = '';

        // Discord Rich Presence tracking
        let discordStreamingActive = false;
        let discordMusicActive = false;
        let discordActivityEnabled = true; // Cached value, updated when settings change

        // Sponsor visibility functions
        function updateSponsorVisibility(show) {
            const aceBetNavBtn = document.getElementById('acebet-nav-btn');
            const aceBetFloatingBtn = document.getElementById('acebet-floating-btn');
            
            if (aceBetNavBtn) {
                aceBetNavBtn.style.display = show ? '' : 'none';
            }
            if (aceBetFloatingBtn) {
                aceBetFloatingBtn.style.display = show ? '' : 'none';
            }
        }
        
        // Load sponsor visibility setting on app startup
        async function loadSponsorVisibility() {
            try {
                const res = await fetch(`${API_BASE_URL}/settings`);
                if (res.ok) {
                    const settings = await res.json();
                    const showSponsor = settings.showSponsor === undefined ? true : settings.showSponsor;
                    updateSponsorVisibility(showSponsor);
                }
            } catch (e) {
                console.error('[Sponsor] Failed to load setting:', e);
            }
        }
        
        async function hideSponsor() {
            // Update toggle state
            const showSponsorToggles = document.querySelectorAll('#showSponsorToggle');
            showSponsorToggles.forEach(t => { t.checked = false; });
            
            // Hide sponsor buttons immediately
            updateSponsorVisibility(false);
            
            // Save to server
            try {
                await fetch(`${API_BASE_URL}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ showSponsor: false })
                });
            } catch (e) {
                console.error('[Sponsor] Failed to save setting:', e);
            }
        }

        // Check if Discord activity is enabled
        async function isDiscordActivityEnabled() {
            try {
                const res = await fetch(`${API_BASE_URL}/settings`);
                if (res.ok) {
                    const settings = await res.json();
                    // Default ON if missing (undefined), but respect explicit false
                    discordActivityEnabled = settings.discordActivity === undefined ? true : settings.discordActivity;
                    return discordActivityEnabled;
                }
            } catch (e) {
                console.error('[Discord] Failed to check activity setting:', e);
            }
            return discordActivityEnabled; // Return cached value if error
        }

        // Update Discord presence for streaming
        async function updateDiscordForStreaming(contentTitle, provider = 'PlayTorrio', season = null) {
            if (!window.electronAPI?.updateDiscordPresence) return;
            
            // Check if Discord activity is enabled
            const activityEnabled = await isDiscordActivityEnabled();
            if (!activityEnabled) {
                // Clear Discord presence if disabled
                if (discordStreamingActive) {
                    try {
                        await window.electronAPI.updateDiscordPresence(null);
                        discordStreamingActive = false;
                    } catch (e) {
                        console.error('[Discord] Failed to clear presence:', e);
                    }
                }
                return;
            }
            
            try {
                discordStreamingActive = true;
                
                // For TV shows, append season info (no episode number)
                let displayTitle = contentTitle;
                if (season !== null && season !== undefined) {
                    displayTitle = `${contentTitle} - Season ${season}`;
                }
                
                const details = `Watching: ${displayTitle}`;
                const state = `via ${provider}`;
                
                await window.electronAPI.updateDiscordPresence({
                    details,
                    state,
                    startTimestamp: new Date(),
                    largeImageKey: 'icon',
                    largeImageText: 'PlayTorrio App',
                    smallImageKey: 'play',
                    smallImageText: 'Streaming',
                    buttons: [
                        { label: 'Download App', url: 'https://github.com/ayman708-UX/PlayTorrio' }
                    ]
                });
            } catch (e) {
                console.error('[Discord] Failed to update streaming presence:', e);
            }
        }
//trigger
        // Update Discord presence for music
        async function updateDiscordForMusic(songTitle, artist, album) {
            if (!window.electronAPI?.updateDiscordPresence) return;
            
            // Check if Discord activity is enabled
            const activityEnabled = await isDiscordActivityEnabled();
            if (!activityEnabled) {
                // Clear Discord presence if disabled
                if (discordMusicActive) {
                    try {
                        await window.electronAPI.updateDiscordPresence(null);
                        discordMusicActive = false;
                    } catch (e) {
                        console.error('[Discord] Failed to clear presence:', e);
                    }
                }
                return;
            }
            
            try {
                discordMusicActive = true;
                const details = ` ${songTitle}`;
                const state = artist ? `by ${artist}${album ? ` - ${album}` : ''}` : (album || 'Music');
                
                await window.electronAPI.updateDiscordPresence({
                    details,
                    state,
                    startTimestamp: new Date(),
                    largeImageKey: 'icon',
                    largeImageText: 'PlayTorrio App',
                    smallImageKey: 'music',
                    smallImageText: 'Listening',
                    buttons: [
                        { label: 'Download App', url: 'https://github.com/ayman708-UX/PlayTorrio' }
                    ]
                });
            } catch (e) {
                console.error('[Discord] Failed to update music presence:', e);
            }
        }

        // Clear Discord presence
        async function clearDiscordPresence() {
            if (!window.electronAPI?.clearDiscordPresence) return;
            
            try {
                discordStreamingActive = false;
                discordMusicActive = false;
                await window.electronAPI.clearDiscordPresence();
            } catch (e) {
                console.error('[Discord] Failed to clear presence:', e);
            }
        }

        // Cache for filename -> TMDB lookup
        const filenameTmdbCache = new Map();

        // Parse title/season/episode from a torrent filename
        function parseFromFilename(name = '') {
            try {
                const base = String(name).replace(/\.[^.]+$/,'');
                const cleaned = base
                    .replace(/[\[\(].*?[\)\]]/g, ' ')
                    .replace(/[_]+/g,' ')
                    .replace(/\s{2,}/g,' ')
                    .trim();
                const patterns = [
                    { re: /(s)(\d{1,2})[ ._-]*e(\d{1,3})/i, season: 2, episode: 3 },
                    { re: /\b(\d{1,2})[xX](\d{1,3})\b/, season: 1, episode: 2 },
                    { re: /\b(\d{1,2})[ ._-]+(\d{1,2})\b/, season: 1, episode: 2 },
                ];
                let season = null, episode = null, title = cleaned, m = null, idx = -1;
                for (const p of patterns) {
                    const mm = cleaned.match(p.re);
                    if (mm) {
                        const sVal = parseInt(mm[p.season], 10);
                        const eVal = parseInt(mm[p.episode], 10);
                        if (!isNaN(sVal) && !isNaN(eVal) && sVal <= 99 && eVal <= 999) {
                            season = sVal; episode = eVal; m = mm; idx = mm.index; break;
                        }
                    }
                }
                if (m && idx >= 0) title = cleaned.slice(0, idx).replace(/[-_.]+$/,'').trim();
                title = title
                    .replace(/\b(\d{3,4}p|4k|bluray|web[- ]?dl|webrip|bdrip|hdr|dv|x264|x265|hevc|h264)\b/ig, '')
                    .replace(/\s{2,}/g,' ')
                    .trim();
                const type = season && episode ? 'tv' : 'movie';
                return { title, season, episode, type };
            } catch { return { title: '', season: null, episode: null, type: 'movie' }; }
        }

        async function getTmdbFromFilename(filename) {
            if (!filename) return null;
            if (filenameTmdbCache.has(filename)) return filenameTmdbCache.get(filename);
            const parsed = parseFromFilename(filename);
            const result = { id: null, type: parsed.type, season: parsed.season, episode: parsed.episode, title: parsed.title };
            if (!parsed.title) { filenameTmdbCache.set(filename, result); return result; }
            try {
                const endpoint = parsed.type === 'tv' ? 'search/tv' : 'search/movie';
                const url = `https://api.themoviedb.org/3/${endpoint}?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(parsed.title)}`;
                const resp = await fetch(url);
                if (resp.ok) {
                    const data = await resp.json();
                    const items = Array.isArray(data.results) ? data.results : [];
                    if (items.length) {
                        result.id = items[0].id;
                    }
                }
            } catch {}
            filenameTmdbCache.set(filename, result);
            return result;
        }

        // Routing and genres state
        let activeRoute = 'home';
        let genresMap = new Map(); // nameLower -> { name, movieId?, tvId? }
        let genresLoaded = false;
        let currentGenre = null; // {name, movieId?, tvId?}
        let currentGenreType = 'movie'; // 'movie' | 'tv'
        let genreCurrentPage = 1;

        // Initialize the app
        function initializeCast() {
            // Wait for Cast SDK to load
            window['__onGCastApiAvailable'] = function(isAvailable) {
                if (isAvailable) {
                    try {
                        const castContext = window.cast.framework.CastContext.getInstance();
                        castContext.setOptions({
                            receiverApplicationId: window.chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                            autoJoinPolicy: window.chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                        });
                        console.log('Google Cast initialized successfully');
                    } catch (error) {
                        console.error('Error initializing Cast:', error);
                    }
                }
            };
        }

        async function init() {
            await checkApiKeyStatus();
            await ensureDebridState();
            await loadSponsorVisibility(); // Load sponsor visibility on startup
            setupEventListeners();
            initIptvSourceSelector(); // Initialize IPTV dropdown
            initializeBookTorrio(); // Initialize BookTorrio functionality
            initializeAudioBooks(); // Initialize AudioBooks functionality
            initializeAnime(); // Initialize Anime functionality
            // Comics initialization moved to showSection when page is shown
            initializeManga(); // Initialize Manga functionality
            initializeSettingsTabs(); // Initialize settings page tab switching
            setWindowsUsername(); // Set Windows username in sidebar
            handleRoute(); // route-aware initial load
            // Update announcement modals removed
            checkDiscordPrompt(); // Show Discord modal if user hasn't joined
            initializeCast(); // Initialize Google Cast SDK
            
            // Initialize new UI components if enabled
            if (document.body.classList.contains('ui-new')) {
                await initializeNewUI();
            }
        }
        
        // Set Windows username from temp directory path
        function setWindowsUsername() {
            const usernameEl = document.getElementById('windowsUsername');
            if (usernameEl) {
                try {
                    // Try to get username from electron API first
                    if (window.electronAPI && window.electronAPI.getUsername) {
                        window.electronAPI.getUsername().then(result => {
                            if (result.success && result.username) {
                                usernameEl.textContent = result.username;
                            }
                        }).catch(() => {
                            // Fallback to extracting from temp path
                            fallbackUsernameExtraction(usernameEl);
                        });
                    } else {
                        // Fallback to extracting from temp path
                        fallbackUsernameExtraction(usernameEl);
                    }
                } catch (error) {
                    console.error('Error getting username:', error);
                }
            }
        }
        
        // Fallback method to extract username from localStorage or other sources
        function fallbackUsernameExtraction(usernameEl) {
            // Try to extract from previously stored cache location or temp directory
            const cacheLocation = localStorage.getItem('cacheLocation');
            if (cacheLocation && cacheLocation.includes('Users\\')) {
                const match = cacheLocation.match(/Users\\([^\\]+)/);
                if (match && match[1]) {
                    usernameEl.textContent = match[1];
                    return;
                }
            }
            // If no cache location, try to get it from API
            fetch(`${API_BASE_URL}/settings`).then(res => res.json()).then(settings => {
                if (settings.cacheLocation && settings.cacheLocation.includes('Users\\')) {
                    const match = settings.cacheLocation.match(/Users\\([^\\]+)/);
                    if (match && match[1]) {
                        usernameEl.textContent = match[1];
                    }
                }
            }).catch(() => {});
        }
        
        // Check if user has joined Discord and show modal if not
        async function checkDiscordPrompt() {
            try {
                // Use file-based preference for reliability on Linux
                const result = await window.electronAPI?.getUserPref?.('discord_dismissed');
                const dismissed = result?.success ? result.value : localStorage.getItem('pt_discord_dismissed_v1');
                
                if (!dismissed) {
                    // Wait a bit for the page to fully load before showing the discord modal
                    setTimeout(() => {
                        showDiscordModal();
                    }, 1000);
                }
            } catch (err) {
                console.error('[Discord] Failed to check preference:', err);
                // Fallback to localStorage
                const hasJoinedDiscord = localStorage.getItem('pt_discord_dismissed_v1');
                if (!hasJoinedDiscord) {
                    setTimeout(() => {
                        showDiscordModal();
                    }, 1000);
                }
            }
        }

        // Show Discord modal
        function showDiscordModal() {
            if (discordModal) {
                discordModal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        
        // Hide Discord modal
        function hideDiscordModal() {
            if (discordModal) {
                discordModal.classList.remove('active');
                document.body.style.overflow = 'auto';
            }
        }
        
        // Show Update modal
        function showUpdateModal() {
            const updateModal = document.getElementById('updateModal');
            if (updateModal) {
                updateModal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        
        // Hide Update modal
        function hideUpdateModal() {
            const updateModal = document.getElementById('updateModal');
            if (updateModal) {
                updateModal.classList.remove('active');
                document.body.style.overflow = 'auto';
            }
        }
        
        // Check if user has seen the update announcement
        function checkUpdateAnnouncement() {
            // Update key for v1.5.3 so existing users see the new notes
            const hasSeenUpdate = localStorage.getItem('hasSeenUpdate_v153');
            if (!hasSeenUpdate) {
                // Wait a bit for the page to fully load before showing the update modal
                setTimeout(() => {
                    showUpdateModal();
                    localStorage.setItem('hasSeenUpdate_v153', 'true');
                }, 1500);
            }
        }
        
        // Check if this is the first launch and show donate modal
        function checkFirstLaunch() {
            const hasSeenDonateModal = localStorage.getItem('hasSeenDonateModal');
            if (!hasSeenDonateModal) {
                // Wait a bit for the page to fully load before showing the donate modal
                setTimeout(() => {
                    showDonateModal();
                    localStorage.setItem('hasSeenDonateModal', 'true');
                }, 500);
            }
        }

        // v1.6.3 modal controls
        function showVersion163Modal() {
            const modal = document.getElementById('version163Modal');
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        function hideVersion163Modal() {
            const modal = document.getElementById('version163Modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = 'auto';
            }
        }

        // Get provider display name for notifications and UI
        function getProviderDisplayName(provider) {
            switch(provider) {
                case 'alldebrid': return 'AllDebrid';
                case 'torbox': return 'TorBox';
                case 'premiumize': return 'Premiumize';
                case 'realdebrid':
                default: return 'RealDebrid';
            }
        }

        // Ensure debrid flags are loaded at startup and before streaming
        async function ensureDebridState() {
            try {
                const r = await fetch(`${API_BASE_URL}/settings`);
                if (r.ok) {
                    const s = await r.json();
                    useDebrid = !!s.useDebrid;
                    debridAuth = !!s.debridAuth;
                    debridProvider = s.debridProvider || 'realdebrid';
                    console.log('[UI][Debrid] state', { useDebrid, debridAuth, debridProvider });
                }
            } catch (e) { console.warn('[UI][Debrid] state load failed', e?.message); }
        }
        
        // Check API key status
        async function checkApiKeyStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/check-api-key`);
                const data = await response.json();
                hasApiKey = data.hasApiKey;
                useTorrentless = !!data.useTorrentless;
                // Modal removed - no longer showing setup prompt
                if (hasApiKey || useTorrentless) {
                    await loadCurrentApiKey();
                }
            } catch (error) {
                console.error('Error checking API key status:', error);
                // Modal removed - silently continue
            }
        }
        
        // Load current API key for display
        async function loadCurrentApiKey() {
            try {
                const response = await fetch(`${API_BASE_URL}/get-api-key`);
                const data = await response.json();
                
                const text = data.hasApiKey ? `Current: ${data.apiKey}` : 'No API key configured';
                // Update ALL elements with id currentApiKey (there are duplicates)
                document.querySelectorAll('#currentApiKey').forEach(el => {
                    el.textContent = text;
                });
            } catch (error) {
                console.error('Error loading current API key:', error);
                // Also fetch debrid settings for global flags
                try {
                    const sres = await fetch(`${API_BASE_URL}/settings`);
                    if (sres.ok) {
                        const s = await sres.json();
                        useDebrid = !!s.useDebrid;
                        debridAuth = !!s.debridAuth;
                    }
                } catch(_) {}
                document.querySelectorAll('#currentApiKey').forEach(el => {
                    el.textContent = 'Error loading API key';
                });
            }
        }
        
        // Show API setup modal - DISABLED (modal removed)
        function showApiSetupModal() {
            // Modal removed - do nothing
        }
        
        // Hide API setup modal - DISABLED (modal removed)
        function hideApiSetupModal() {
            // Modal removed - do nothing
        }
        
        // Donate modal functionality removed
        
        // Show settings modal
        async function showSettingsModal() {
            // Navigate to settings page instead of showing modal
            window.location.hash = '#/settings';
        }
        
        // Load all settings data
        async function loadSettingsData() {
            await loadCurrentApiKey();
            
            // Clear API key input for ALL instances
            const newApiKeyElements = document.querySelectorAll('#newApiKey');
            newApiKeyElements.forEach(input => {
                input.value = '';
            });
            
            // Load UI mode setting for ALL instances
            const uiModeNewElements = document.querySelectorAll('#uiModeNew');
            const uiModeOldElements = document.querySelectorAll('#uiModeOld');
            
            uiModeNewElements.forEach(el => {
                if (currentUIMode === 'new') {
                    el.checked = true;
                }
            });
            uiModeOldElements.forEach(el => {
                if (currentUIMode === 'old') {
                    el.checked = true;
                }
            });
            
            // Load theme setting for ALL instances
            const themeSelectors = document.querySelectorAll('#themeSelector');
            themeSelectors.forEach(themeSelector => {
                if (themeSelector) {
                    themeSelector.value = currentTheme;
                }
            });
            
            // Load fullscreen setting for ALL instances
            const fullscreenToggles = document.querySelectorAll('#fullscreenToggle');
            
            // Check Trakt authentication status
            await checkTraktStatus();
            if (fullscreenToggles.length > 0 && window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success) {
                        fullscreenToggles.forEach(toggle => {
                            toggle.checked = result.isFullscreen;
                        });
                    }
                } catch (error) {
                    console.error('Error loading fullscreen state:', error);
                }
            }
            
                    // Load useTorrentless setting state for ALL instances
            try {
                const res = await fetch(`${API_BASE_URL}/settings`);
                if (res.ok) {
                    const s = await res.json();
                    console.log('[Settings] Loaded settings:', s);
                    useTorrentless = !!s.useTorrentless;
                            // AutoUpdater toggle (default ON if missing)
                            const autoUpdate = s.autoUpdate !== false; // treat undefined as true
                            const autoUpdateToggles = document.querySelectorAll('#autoUpdateToggle');
                            autoUpdateToggles.forEach(t => { t.checked = !!autoUpdate; });
                    
                            // Discord Activity toggle (default ON if missing)
                            const discordActivity = s.discordActivity === undefined ? true : s.discordActivity;
                            discordActivityEnabled = discordActivity; // Update cached value
                            const discordActivityToggles = document.querySelectorAll('#discordActivityToggle');
                            discordActivityToggles.forEach(t => { t.checked = !!discordActivity; });
                            
                            // Show Sponsor toggle (default ON if missing)
                            const showSponsor = s.showSponsor === undefined ? true : s.showSponsor;
                            const showSponsorToggles = document.querySelectorAll('#showSponsorToggle');
                            showSponsorToggles.forEach(t => { t.checked = !!showSponsor; });
                            updateSponsorVisibility(showSponsor);
                    
                    const useTorrentlessToggles = document.querySelectorAll('#useTorrentlessToggle');
                    useTorrentlessToggles.forEach(toggle => {
                        toggle.checked = useTorrentless;
                    });
                    // Load torrent source preference (default to 'torrentio')
                    const currentSource = s.torrentSource || 'torrentio';
                    console.log('[Settings] Set torrent source to:', currentSource);
                    
                    // Update button states for ALL instances
                    const torrentioBtns = document.querySelectorAll('#torrentioBtn');
                    const inAppScraperBtns = document.querySelectorAll('#inAppScraperBtn');
                    if (torrentioBtns.length > 0 && inAppScraperBtns.length > 0) {
                        if (currentSource === 'torrentio') {
                            torrentioBtns.forEach(btn => btn.classList.add('active'));
                            inAppScraperBtns.forEach(btn => btn.classList.remove('active'));
                        } else {
                            torrentioBtns.forEach(btn => btn.classList.remove('active'));
                            inAppScraperBtns.forEach(btn => btn.classList.add('active'));
                        }
                    }
                    // Load Jackett URL for ALL instances
                    const jackettUrlElements = document.querySelectorAll('#jackettUrl');
                    if (jackettUrlElements.length > 0 && s.jackettUrl) {
                        jackettUrlElements.forEach(input => {
                            input.value = s.jackettUrl;
                        });
                    }
                    // Load cache location for ALL instances
                    const cacheLocationElements = document.querySelectorAll('#cacheLocation');
                    if (cacheLocationElements.length > 0 && s.cacheLocation) {
                        cacheLocationElements.forEach(input => {
                            input.value = s.cacheLocation;
                        });
                    }
                    // Debrid: populate form for ALL instances
                    const useDebridToggles = document.querySelectorAll('#useDebridToggle');
                    if (useDebridToggles.length > 0 && s.useDebrid !== undefined) {
                        useDebridToggles.forEach(toggle => {
                            toggle.checked = !!s.useDebrid;
                        });
                    }
                    
                    const prov = s.debridProvider || 'realdebrid';
                    const debridProviders = document.querySelectorAll('#debridProvider');
                    debridProviders.forEach(select => {
                        select.value = prov;
                    });
                    
                    const debridStatuses = document.querySelectorAll('#debridStatus');
                    debridStatuses.forEach(status => {
                        status.textContent = s.debridAuth ? 'Logged in' : 'Not logged in';
                    });
                    
                    // Load rdClientId for ALL instances
                    const rdClientIdInputs = document.querySelectorAll('#rdClientId');
                    if (rdClientIdInputs.length > 0 && s.rdClientId) {
                        rdClientIdInputs.forEach(input => {
                            input.value = s.rdClientId;
                        });
                    }
                    
                    useDebrid = !!s.useDebrid; debridAuth = !!s.debridAuth;
                    // Toggle provider-specific UI for ALL instances
                    const isRD = prov === 'realdebrid';
                    const isAD = prov === 'alldebrid';
                    const isTB = prov === 'torbox';
                    const isPM = prov === 'premiumize';
                    
                    document.querySelectorAll('#rdClientIdGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdTokenGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdTokenButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                    document.querySelectorAll('#rdCodePanel').forEach(el => el.style.display = 'none');
                    document.querySelectorAll('#adSection').forEach(el => el.style.display = isAD ? '' : 'none');
                    document.querySelectorAll('#tbSection').forEach(el => el.style.display = isTB ? '' : 'none');
                    document.querySelectorAll('#pmSection').forEach(el => el.style.display = isPM ? '' : 'none');
                    
                    // NodeMPV Player (Windows Only)
                    try {
                        const platformRes = await fetch('/api/platform');
                        const platformData = await platformRes.json();
                        const isWindows = platformData.platform === 'win32';
                        
                        // Show/hide NodeMPV sections based on platform
                        document.querySelectorAll('#nodempvContent').forEach(el => {
                            el.style.display = isWindows ? '' : 'none';
                        });
                        // Show/hide the Player tab
                        const nodempvTab = document.getElementById('nodempvTab');
                        if (nodempvTab) {
                            nodempvTab.style.display = isWindows ? '' : 'none';
                        }
                        // Show the main toggle in Nuvio section
                        const nodempvSectionMain = document.getElementById('nodempvSectionMain');
                        if (nodempvSectionMain) {
                            nodempvSectionMain.style.display = isWindows ? '' : 'none';
                        }
                        
                        // Load NodeMPV toggle state for all toggles
                        if (isWindows) {
                            document.querySelectorAll('#useNodeMPVToggle, #useNodeMPVToggleMain').forEach(toggle => {
                                toggle.checked = !!s.useNodeMPV;
                            });
                        }
                    } catch(e) {
                        console.warn('[Settings] Failed to check platform for NodeMPV:', e);
                    }
                }
            } catch(_) {}
        }
        
        // Hide settings modal
        function hideSettingsModal() {
            settingsModal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }
        
        // Settings Page Tab Switching
        function initializeSettingsTabs() {
            const settingsTabs = document.querySelectorAll('.settings-tab');
            const settingsSections = document.querySelectorAll('.settings-section');
            
            settingsTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetSection = tab.getAttribute('data-section');
                    
                    // Remove active class from all tabs and sections
                    settingsTabs.forEach(t => t.classList.remove('active'));
                    settingsSections.forEach(s => s.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding section
                    tab.classList.add('active');
                    const targetElement = document.getElementById(`${targetSection}Content`);
                    if (targetElement) {
                        targetElement.classList.add('active');
                    }
                });
            });
        }
        
        // Save API key (first time setup)
        async function saveFirstTimeApiKey_() {
            const apiKey = firstTimeApiKey.value.trim();
            
            if (!apiKey) {
                showNotification('Please enter an API key');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/set-api-key`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ apiKey })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    hasApiKey = true;
                    hideApiSetupModal();
                    showNotification('API key saved successfully!');
                    await loadCurrentApiKey();
                } else {
                    showNotification(data.error || 'Failed to save API key');
                }
            } catch (error) {
                console.error('Error saving API key:', error);
                showNotification('Error saving API key');
            }
        }

        // ===== TRAKT FUNCTIONS =====

        let traktPollingInterval = null;
        let traktCurrentScrobble = null;

        // Parse media title to extract info for Trakt
        function parseMediaTitle(title) {
            if (!title) return { title: 'Unknown', type: 'movie', year: null };

            // Clean up the title
            let cleanTitle = title
                .replace(/\.(mkv|mp4|avi|mov|wmv|flv|webm)$/i, '') // Remove file extensions
                .replace(/\.(720p|1080p|4k|2160p|480p|hdtv|bdrip|webrip|dvdrip|cam|ts|hdrip)/gi, '') // Remove quality tags
                .replace(/\.(x264|x265|h264|h265|xvid|divx)/gi, '') // Remove codec tags
                .replace(/\.(aac|ac3|dts|mp3|flac)/gi, '') // Remove audio tags
                .replace(/[\[\]()]/g, ' ') // Remove brackets
                .replace(/\b(repack|proper|real|retail|uncut|unrated|extended|directors?\.cut)\b/gi, '') // Remove release tags
                .trim();

            // Check if it's a TV show (contains S##E## or Season/Episode patterns)
            const tvPatterns = [
                /(.+?)[\s\.]S(\d{1,2})E(\d{1,2})/i, // Title S01E01
                /(.+?)[\s\.]Season[\s\.](\d{1,2})[\s\.]Episode[\s\.](\d{1,2})/i, // Title Season 1 Episode 1
                /(.+?)[\s\.](\d{1,2})x(\d{1,2})/i, // Title 1x01
            ];

            for (const pattern of tvPatterns) {
                const match = cleanTitle.match(pattern);
                if (match) {
                    const showTitle = match[1].trim().replace(/[.\-_]/g, ' ');
                    const season = parseInt(match[2]);
                    const episode = parseInt(match[3]);
                    
                    // Extract year if present
                    const yearMatch = showTitle.match(/\b(19\d{2}|20\d{2})\b/);
                    const year = yearMatch ? parseInt(yearMatch[1]) : null;
                    const titleWithoutYear = showTitle.replace(/\b(19\d{2}|20\d{2})\b/, '').trim();

                    return {
                        title: titleWithoutYear || showTitle,
                        type: 'show',
                        year: year,
                        season: season,
                        episode: episode
                    };
                }
            }

            // If not a TV show, treat as movie
            const yearMatch = cleanTitle.match(/\b(19\d{2}|20\d{2})\b/);
            const year = yearMatch ? parseInt(yearMatch[1]) : null;
            const titleWithoutYear = cleanTitle.replace(/\b(19\d{2}|20\d{2})\b/, '').trim();

            return {
                title: titleWithoutYear || cleanTitle,
                type: 'movie',
                year: year
            };
        }

        // Check Trakt authentication status
        async function checkTraktStatus() {
            try {
                const response = await fetch(`/api/trakt/status?ts=${Date.now()}`, { cache: 'no-store' });
                const data = await response.json();
                
                if (data.authenticated && data.user) {
                    showTraktConnected(data.user);
                } else {
                    showTraktDisconnected();
                }
            } catch (error) {
                console.error('[TRAKT] Status check failed:', error);
                showTraktDisconnected();
            }
        }

        function showTraktConnected(user) {
            // Update ALL instances of Trakt status elements
            const traktNotConnectedEls = document.querySelectorAll('#traktNotConnected');
            const traktConnectedEls = document.querySelectorAll('#traktConnected');
            const traktUsernameEls = document.querySelectorAll('#traktUsername');
            const traktStatusEls = document.querySelectorAll('#traktStatus');
            
            traktNotConnectedEls.forEach(el => el.style.display = 'none');
            traktConnectedEls.forEach(el => el.style.display = 'block');
            traktUsernameEls.forEach(el => el.textContent = user.username || user.name || 'User');
            traktStatusEls.forEach(el => {
                el.innerHTML = '<i class="fas fa-check-circle"></i> Connected';
                el.style.color = '#198754';
            });
        }

        function showTraktDisconnected() {
            // Update ALL instances of Trakt status elements
            const traktNotConnectedEls = document.querySelectorAll('#traktNotConnected');
            const traktConnectedEls = document.querySelectorAll('#traktConnected');
            const traktStatusEls = document.querySelectorAll('#traktStatus');
            
            traktNotConnectedEls.forEach(el => el.style.display = 'block');
            traktConnectedEls.forEach(el => el.style.display = 'none');
            traktStatusEls.forEach(el => {
                el.innerHTML = '<i class="fas fa-times-circle"></i> Not connected';
                el.style.color = '#dc3545';
            });
        }

        // Start Trakt authentication flow (unified to new device/code + verify endpoints)
        async function startTraktLogin() {
            try {
                // Update ALL login buttons
                const traktLoginBtns = document.querySelectorAll('#traktLogin');
                traktLoginBtns.forEach(btn => {
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';
                });

                // Get device code
                const response = await fetch('/api/trakt/device/code', { method: 'POST' });
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to get device code');
                }

                // Show the code panel on ALL instances
                const traktCodePanels = document.querySelectorAll('#traktCodePanel');
                const traktUserCodeEls = document.querySelectorAll('#traktUserCode');
                traktCodePanels.forEach(panel => panel.style.display = 'block');
                traktUserCodeEls.forEach(el => el.textContent = data.user_code);
                
                const traktVerifyUrlEls = document.querySelectorAll('#traktVerifyUrl');
                const traktLoginStatusEls = document.querySelectorAll('#traktLoginStatus');
                traktVerifyUrlEls.forEach(el => el.href = data.verification_url);
                traktLoginStatusEls.forEach(el => el.textContent = 'Waiting for authorization');

                // Start polling verification (server reads stored device_code)
                startTraktPolling(data.device_code, data.interval || 5);

            } catch (error) {
                console.error('[TRAKT] Login error:', error);
                showNotification('Failed to start Trakt login: ' + error.message, 'error');
                resetTraktLogin();
            }
        }

        function startTraktPolling(deviceCode, interval) {
            if (traktPollingInterval) {
                clearInterval(traktPollingInterval);
            }

            traktPollingInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/trakt/device/verify', { method: 'POST' });
                    const data = await response.json();

                    if (data.success) {
                        // Authentication successful
                        clearInterval(traktPollingInterval);
                        traktPollingInterval = null;
                        if (traktCodePanel) traktCodePanel.style.display = 'none';
                        showNotification('Successfully connected to Trakt!', 'success');
                        await checkTraktStatus();
                        resetTraktLogin();
                    } else if (data.error === 'pending') {
                        // Still waiting for user authorization
                        if (traktLoginStatusEl) traktLoginStatusEl.textContent = 'Waiting for authorization';
                    } else {
                        // Other verification error
                        throw new Error(data.error || 'Verification failed');
                    }
                } catch (error) {
                    console.error('[TRAKT] Polling error:', error);
                    clearInterval(traktPollingInterval);
                    traktPollingInterval = null;
                    showNotification('Authentication failed: ' + error.message, 'error');
                    resetTraktLogin();
                }
            }, interval * 1000);
        }

        function resetTraktLogin() {
            const traktLoginBtns = document.querySelectorAll('#traktLogin');
            const traktCodePanels = document.querySelectorAll('#traktCodePanel');
            
            traktLoginBtns.forEach(btn => {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-sign-in-alt"></i> Connect to Trakt';
            });
            traktCodePanels.forEach(panel => panel.style.display = 'none');
            
            if (traktPollingInterval) {
                clearInterval(traktPollingInterval);
                traktPollingInterval = null;
            }
        }

        function cancelTraktLogin() {
            resetTraktLogin();
            showNotification('Trakt login cancelled', 'info');
        }

        async function disconnectTrakt() {
            try {
                const response = await fetch('/api/trakt/logout', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    // Hide any device code panels in Settings
                    document.querySelectorAll('#traktCodePanel').forEach(p => p.style.display = 'none');
                    showTraktDisconnected();
                    // Re-check status to sync all UI instances
                    try { await checkTraktStatus(); } catch(_) {}
                    // If Trakt page is loaded, refresh its status too
                    try { if (typeof updateTraktPageStatus === 'function') await updateTraktPageStatus(); } catch(_) {}
                    showNotification('Disconnected from Trakt', 'success');
                } else {
                    throw new Error(data.error || 'Failed to logout');
                }
            } catch (error) {
                console.error('[TRAKT] Logout error:', error);
                showNotification('Failed to disconnect: ' + error.message, 'error');
            }
        }

        // Scrobbling functions
        async function scrobbleStart(title, type, year, season, episode, progress = 0) {
            if (!traktAutoScrobbleToggle.checked) return;

            try {
                const response = await fetch('/api/trakt/scrobble/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year, season, episode, progress })
                });

                const data = await response.json();
                if (data.success) {
                    traktCurrentScrobble = { title, type, year, season, episode };
                    console.log('[TRAKT] Started scrobbling:', title);
                } else {
                    console.error('[TRAKT] Scrobble start failed:', data.error);
                }
            } catch (error) {
                console.error('[TRAKT] Scrobble start error:', error);
            }
        }

        async function scrobblePause(progress) {
            if (!traktCurrentScrobble || !traktScrobbleProgressToggle.checked) return;

            try {
                const response = await fetch('/api/trakt/scrobble/pause', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ...traktCurrentScrobble, progress })
                });

                if (response.ok) {
                    console.log('[TRAKT] Paused scrobbling at', progress + '%');
                }
            } catch (error) {
                console.error('[TRAKT] Scrobble pause error:', error);
            }
        }

        async function scrobbleStop(progress) {
            if (!traktCurrentScrobble) return;

            try {
                const response = await fetch('/api/trakt/scrobble/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ...traktCurrentScrobble, progress })
                });

                if (response.ok) {
                    console.log('[TRAKT] Stopped scrobbling at', progress + '%');
                    traktCurrentScrobble = null;
                }
            } catch (error) {
                console.error('[TRAKT] Scrobble stop error:', error);
            }
        }

        // Utility functions
        function copyTraktCode() {
            const code = traktUserCodeEl.textContent;
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Code copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy code', 'error');
            });
        }

        function openTraktVerify() {
            const url = traktVerifyUrlEl.href;
            if (window.electronAPI && window.electronAPI.openExternal) {
                window.electronAPI.openExternal(url);
            } else {
                window.open(url, '_blank');
            }
        }

        // Watchlist management
        async function setupTraktWatchlistButton() {
            if (!traktWatchlistBtn || !currentMovie) return;

            // Check if user is authenticated with Trakt
            try {
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                
                if (!statusData.authenticated) {
                    traktWatchlistBtn.style.display = 'none';
                    return;
                }

                traktWatchlistBtn.style.display = 'block';
                
                // Check if item is already in watchlist
                const title = currentMovie.title || currentMovie.name;
                const year = parseInt((currentMovie.release_date || currentMovie.first_air_date || '').substring(0, 4));
                
                // For now, assume it's not in watchlist - could check against API in the future
                updateWatchlistButton(false);
                
            } catch (error) {
                console.error('[TRAKT] Error setting up watchlist button:', error);
                traktWatchlistBtn.style.display = 'none';
            }
        }

        function updateWatchlistButton(isInWatchlist) {
            if (!traktWatchlistBtn) return;

            if (isInWatchlist) {
                traktWatchlistBtn.innerHTML = '<i class="fas fa-check"></i> In Watchlist';
                traktWatchlistBtn.classList.remove('btn-secondary');
                traktWatchlistBtn.classList.add('btn-success');
                traktWatchlistBtn.onclick = removeFromTraktWatchlist;
            } else {
                traktWatchlistBtn.innerHTML = '<i class="fas fa-plus"></i> Add to Watchlist';
                traktWatchlistBtn.classList.remove('btn-success');
                traktWatchlistBtn.classList.add('btn-secondary');
                traktWatchlistBtn.onclick = addToTraktWatchlist;
            }
        }

        async function addToTraktWatchlist() {
            if (!currentMovie) return;

            try {
                traktWatchlistBtn.disabled = true;
                traktWatchlistBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';

                const title = currentMovie.title || currentMovie.name;
                const year = parseInt((currentMovie.release_date || currentMovie.first_air_date || '').substring(0, 4));
                const type = currentMediaType === 'tv' ? 'show' : 'movie';

                const response = await fetch('/api/trakt/watchlist/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year })
                });

                const data = await response.json();
                
                if (data.success) {
                    updateWatchlistButton(true);
                    showNotification(`Added "${title}" to your Trakt watchlist!`, 'success');
                } else {
                    throw new Error(data.error || 'Failed to add to watchlist');
                }
                
            } catch (error) {
                console.error('[TRAKT] Add to watchlist error:', error);
                showNotification('Failed to add to watchlist: ' + error.message, 'error');
                updateWatchlistButton(false);
            } finally {
                traktWatchlistBtn.disabled = false;
            }
        }

        async function removeFromTraktWatchlist() {
            if (!currentMovie) return;

            try {
                traktWatchlistBtn.disabled = true;
                traktWatchlistBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Removing...';

                const title = currentMovie.title || currentMovie.name;
                const year = parseInt((currentMovie.release_date || currentMovie.first_air_date || '').substring(0, 4));
                const type = currentMediaType === 'tv' ? 'show' : 'movie';

                const response = await fetch('/api/trakt/watchlist/remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year })
                });

                const data = await response.json();
                
                if (data.success) {
                    updateWatchlistButton(false);
                    showNotification(`Removed "${title}" from your Trakt watchlist`, 'success');
                } else {
                    throw new Error(data.error || 'Failed to remove from watchlist');
                }
                
            } catch (error) {
                console.error('[TRAKT] Remove from watchlist error:', error);
                showNotification('Failed to remove from watchlist: ' + error.message, 'error');
                updateWatchlistButton(true);
            } finally {
                traktWatchlistBtn.disabled = false;
            }
        }

        // ===== END TRAKT FUNCTIONS =====

        // ===== TRAKT PAGE FUNCTIONS =====
        
        // Global Trakt page state
        let traktPageInitialized = false;
        let traktDeviceCodeInterval = null;
        let traktStats = null;

        async function initializeTraktPage() {
            if (traktPageInitialized) return;
            
            try {
                await updateTraktPageStatus();
                setupTraktPageEventListeners();
                traktPageInitialized = true;
                console.log('[TRAKT PAGE] Initialized successfully');
            } catch (error) {
                console.error('[TRAKT PAGE] Initialization error:', error);
            }
        }

        function setupTraktPageEventListeners() {
            // Helper to avoid duplicate listeners when DOM is re-rendered
            function bindById(id, handler) {
                const el = document.getElementById(id);
                if (!el) return;
                const fresh = el.cloneNode(true);
                el.parentNode.replaceChild(fresh, el);
                fresh.addEventListener('click', handler);
            }

            // Authenticate button
            bindById('traktAuthenticateBtn', startTraktPageAuth);

            // Disconnect buttons (both variants)
            bindById('traktPageDisconnect', disconnectTraktFromPage);
            bindById('traktDisconnectBtn', disconnectTraktFromPage);

            // Refresh status button
            bindById('traktPageRefresh', () => { updateTraktPageStatus(); });

            // Re-sync Library button
            bindById('traktPageResyncLibrary', manualResyncTraktLibrary);

            // View statistics button
            bindById('traktPageStats', () => { try { showDetailedTraktStatistics(); } catch(_) {} });

            // Verify Device Code button
            bindById('traktVerifyDeviceBtn', verifyTraktDeviceCode);

            // Open Trakt URL button
            bindById('traktOpenUrlBtn', () => {
                const url = document.getElementById('traktPageVerificationUrl')?.textContent;
                if (url) {
                    window.electronAPI?.openExternal(url);
                }
            });

            // Copy device code button
            bindById('traktCopyCodeBtn', copyTraktDeviceCode);

            // Action cards (rebinding safely)
            document.querySelectorAll('.trakt-action-card').forEach(card => {
                const fresh = card.cloneNode(true);
                card.parentNode.replaceChild(fresh, card);
                fresh.addEventListener('click', handleTraktActionClick);
            });

            // Settings toggles
            const autoScrobbleToggle = document.getElementById('traktPageAutoScrobble');
            const progressToggle = document.getElementById('traktPageScrobbleProgress');
            const watchlistToggle = document.getElementById('traktPageWatchlistSync');

            if (autoScrobbleToggle) {
                autoScrobbleToggle.addEventListener('change', () => {
                    if (traktAutoScrobbleToggle) {
                        traktAutoScrobbleToggle.checked = autoScrobbleToggle.checked;
                    }
                });
            }

            if (progressToggle) {
                progressToggle.addEventListener('change', () => {
                    if (traktScrobbleProgressToggle) {
                        traktScrobbleProgressToggle.checked = progressToggle.checked;
                    }
                });
            }

            if (watchlistToggle) {
                watchlistToggle.addEventListener('change', () => {
                    if (traktSyncWatchlistToggle) {
                        traktSyncWatchlistToggle.checked = watchlistToggle.checked;
                    }
                });
            }
        }

        async function updateTraktPageStatus() {
            try {
                const response = await fetch(`/api/trakt/status?ts=${Date.now()}`, { cache: 'no-store' });
                const data = await response.json();

                const statusIndicator = document.getElementById('traktStatusIndicator');
                const statusDescription = document.getElementById('traktStatusDescription');
                const statusActions = document.getElementById('traktStatusActions');
                const deviceCodePanel = document.getElementById('traktDeviceCodePanel');
                const traktPageNotConnected = document.getElementById('traktPageNotConnected');
                const traktPageConnected = document.getElementById('traktPageConnected');
                const traktPageUsername = document.getElementById('traktPageUsername');

                if (data.authenticated) {
                    // Connected state: show connected card, set username
                    if (traktPageNotConnected) traktPageNotConnected.style.display = 'none';
                    if (traktPageConnected) traktPageConnected.style.display = '';
                    if (traktPageUsername) traktPageUsername.textContent = (data.user?.username || data.user?.name || 'User');

                    if (deviceCodePanel) {
                        deviceCodePanel.style.display = 'none';
                        delete deviceCodePanel.dataset.manual;
                    }
                    // Update action grid with stats
                    await loadTraktStats();
                    // One-time import from Trakt into local caches
                    importTraktDataOnceIfNeeded();
                    
                } else {
                    // Disconnected state: show not-connected card with connect action
                    if (traktPageConnected) traktPageConnected.style.display = 'none';
                    if (traktPageNotConnected) traktPageNotConnected.style.display = '';
                    if (statusIndicator) {
                        statusIndicator.className = 'trakt-status-indicator disconnected';
                        statusIndicator.innerHTML = '<i class="fas fa-times-circle"></i><span>Not Connected</span>';
                    }
                    if (statusDescription) {
                        statusDescription.textContent = 'Connect your Trakt account to automatically track what you watch, sync your watchlist, and get personalized recommendations.';
                    }
                    if (statusActions) {
                        statusActions.innerHTML = `
                            <button id="traktAuthenticateBtn" class="trakt-btn trakt-btn-primary">
                                <i class="fas fa-link"></i>Connect to Trakt
                            </button>
                        `;
                    }

                    // Only hide code panel if not manually shown during an active auth flow
                    if (deviceCodePanel && deviceCodePanel.dataset.manual !== 'true') {
                        deviceCodePanel.style.display = 'none';
                    }

                    // Clear action grid
                    clearTraktActionGrid();
                }

                // Sync settings toggles
                syncTraktPageSettings();
                
                // Re-setup event listeners after DOM update
                setupTraktPageEventListeners();

            } catch (error) {
                console.error('[TRAKT PAGE] Status update error:', error);
                // Surface the actual error for clarity
                const msg = (error && error.message) ? error.message : 'Unknown error';
                showNotification('Trakt status error: ' + msg, 'error');
            }
        }

        async function startTraktPageAuth() {
            try {
                const response = await fetch('/api/trakt/device/code', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    showTraktDeviceCode(data.device_code, data.user_code, data.verification_url, data.expires_in);
                    
                    // Start polling for verification
                    traktDeviceCodeInterval = setInterval(async () => {
                        await verifyTraktDeviceCode();
                    }, data.interval * 1000 || 5000);
                    
                } else {
                    throw new Error(data.error || 'Failed to get device code');
                }
            } catch (error) {
                console.error('[TRAKT PAGE] Auth start error:', error);
                showNotification('Failed to start authentication: ' + error.message, 'error');
            }
        }

        function showTraktDeviceCode(deviceCode, userCode, verificationUrl, expiresIn) {
            const deviceCodePanel = document.getElementById('traktDeviceCodePanel');
            const userCodeSpan = document.getElementById('traktPageUserCode');
            const verificationUrlSpan = document.getElementById('traktPageVerificationUrl');
            const statusMessage = document.getElementById('traktDeviceCodeStatus');

            if (deviceCodePanel) {
                deviceCodePanel.style.display = 'block';
                deviceCodePanel.dataset.manual = 'true';
            }
            if (userCodeSpan) userCodeSpan.textContent = userCode;
            if (verificationUrlSpan) verificationUrlSpan.textContent = verificationUrl;
            if (statusMessage) {
                statusMessage.innerHTML = '<span>Waiting for authorization... Please enter the code above on Trakt.tv</span>';
            }

            // Set timeout to hide panel after expiration
            setTimeout(() => {
                if (traktDeviceCodeInterval) {
                    clearInterval(traktDeviceCodeInterval);
                    traktDeviceCodeInterval = null;
                    if (deviceCodePanel) {
                        deviceCodePanel.style.display = 'none';
                        delete deviceCodePanel.dataset.manual;
                    }
                    showNotification('Device code expired. Please try again.', 'error');
                }
            }, expiresIn * 1000);
        }

        async function verifyTraktDeviceCode() {
            try {
                const response = await fetch('/api/trakt/device/verify', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    // Success! Clear interval and update page
                    if (traktDeviceCodeInterval) {
                        clearInterval(traktDeviceCodeInterval);
                        traktDeviceCodeInterval = null;
                    }
                    
                    const deviceCodePanel = document.getElementById('traktDeviceCodePanel');
                    if (deviceCodePanel) deviceCodePanel.style.display = 'none';
                    
                    showNotification('Successfully connected to Trakt!', 'success');
                    await updateTraktPageStatus();
                    
                } else if (data.error === 'pending') {
                    // Still waiting, update status
                    const statusMessage = document.getElementById('traktDeviceCodeStatus');
                    if (statusMessage) {
                        statusMessage.innerHTML = '<span>Waiting for authorization... Please enter the code above on Trakt.tv</span>';
                    }
                } else {
                    throw new Error(data.error || 'Verification failed');
                }
            } catch (error) {
                console.error('[TRAKT PAGE] Verify error:', error);
                if (error.message !== 'pending') {
                    showNotification('Verification failed: ' + error.message, 'error');
                }
            }
        }

        async function disconnectTraktFromPage() {
            try {
                const response = await fetch('/api/trakt/logout', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    // Hide device code panel if visible
                    const deviceCodePanel = document.getElementById('traktDeviceCodePanel');
                    if (deviceCodePanel) deviceCodePanel.style.display = 'none';
                    // Refresh both Trakt page and Settings page status
                    try { await updateTraktPageStatus(); } catch(_) {}
                    try { await checkTraktStatus(); } catch(_) {}
                    showNotification('Successfully disconnected from Trakt', 'success');
                } else {
                    throw new Error(data.error || 'Failed to disconnect');
                }
            } catch (error) {
                console.error('[TRAKT PAGE] Disconnect error:', error);
                showNotification('Failed to disconnect: ' + error.message, 'error');
            }
        }

        function copyTraktDeviceCode() {
            // Prefer Trakt page code span, fallback to Settings panel span
            const userCode = (document.getElementById('traktPageUserCode')?.textContent)
                || (document.querySelector('#traktCodePanel #traktUserCode')?.textContent)
                || (document.getElementById('traktUserCode')?.textContent);
            if (userCode && navigator.clipboard) {
                navigator.clipboard.writeText(userCode).then(() => {
                    showNotification('Device code copied to clipboard!', 'success');
                }).catch(() => {
                    showNotification('Failed to copy code', 'error');
                });
            }
        }

        async function showDetailedTraktStatistics() {
            try {
                showNotification('Loading your statistics...', 'info', 2000);
                
                const response = await fetch('/api/trakt/user/stats');
                const data = await response.json();
                
                if (data.success && data.stats) {
                    displayTraktStatisticsModal(data.stats);
                    showNotification('Statistics loaded successfully!', 'success', 2000);
                } else {
                    throw new Error(data.error || 'Failed to load statistics');
                }
            } catch (error) {
                console.error('[TRAKT] Detailed statistics error:', error);
                showNotification('Unable to load detailed statistics. Please ensure you\'re connected to Trakt and try again.', 'error', 4000);
            }
        }

        function displayTraktStatisticsModal(stats) {
            // Create statistics modal
            const modal = document.createElement('div');
            modal.id = 'traktStatisticsModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(8px);
                z-index: 20000;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 2rem;
                animation: fadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, rgba(30, 30, 30, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
                border-radius: 16px;
                padding: 2rem;
                max-width: 800px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            `;

            // Calculate totals
            const movieStats = stats.movies || { watched: 0, collected: 0, ratings: 0, plays: 0, minutes: 0 };
            const showStats = stats.shows || { watched: 0, collected: 0, ratings: 0, plays: 0, minutes: 0 };
            const episodeStats = stats.episodes || { watched: 0, collected: 0, ratings: 0, plays: 0, minutes: 0 };
            
            const totalWatched = movieStats.watched + showStats.watched;
            const totalMinutes = movieStats.minutes + episodeStats.minutes;
            const totalHours = Math.round(totalMinutes / 60);
            const totalDays = Math.round(totalHours / 24);
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                    <h2 style="margin: 0; color: #ed1c24; font-size: 1.8rem;">
                        <i class="fas fa-chart-bar"></i> Your Trakt Statistics
                    </h2>
                    <button onclick="closeTraktStatisticsModal()" style="
                        background: rgba(255, 255, 255, 0.1);
                        border: none;
                        color: white;
                        padding: 0.5rem;
                        border-radius: 50%;
                        cursor: pointer;
                        font-size: 1.2rem;
                        width: 40px;
                        height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    "></button>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
                    <div style="background: rgba(237, 28, 36, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #ed1c24;">
                        <div style="font-size: 2rem; font-weight: bold; color: #ed1c24;">${totalWatched}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Total Content Watched</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">Movies + Shows</div>
                    </div>
                    
                    <div style="background: rgba(34, 197, 94, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #22c55e;">
                        <div style="font-size: 2rem; font-weight: bold; color: #22c55e;">${totalDays}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Days Watched</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">${totalHours} hours total</div>
                    </div>
                    
                    <div style="background: rgba(59, 130, 246, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #3b82f6;">
                        <div style="font-size: 2rem; font-weight: bold; color: #3b82f6;">${stats.watchlist?.length || 0}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Watchlist Items</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">Pending to watch</div>
                    </div>
                    
                    <div style="background: rgba(245, 158, 11, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #f59e0b;">
                        <div style="font-size: 2rem; font-weight: bold; color: #f59e0b;">${stats.ratings?.length || 0}</div>
                        <div style="color: #ccc; margin-top: 0.5rem;">Items Rated</div>
                        <div style="font-size: 0.9rem; color: #999; margin-top: 0.25rem;">Your taste profile</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px;">
                        <h3 style="margin: 0 0 1rem 0; color: #ed1c24;">
                            <i class="fas fa-film"></i> Movies
                        </h3>
                        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Watched:</span>
                                <span style="color: white; font-weight: bold;">${movieStats.watched || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Collected:</span>
                                <span style="color: white; font-weight: bold;">${movieStats.collected || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Rated:</span>
                                <span style="color: white; font-weight: bold;">${movieStats.ratings || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Watch Time:</span>
                                <span style="color: white; font-weight: bold;">${Math.round((movieStats.minutes || 0) / 60)}h</span>
                            </div>
                        </div>
                    </div>

                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px;">
                        <h3 style="margin: 0 0 1rem 0; color: #ed1c24;">
                            <i class="fas fa-tv"></i> TV Shows
                        </h3>
                        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Shows Watched:</span>
                                <span style="color: white; font-weight: bold;">${showStats.watched || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Episodes:</span>
                                <span style="color: white; font-weight: bold;">${episodeStats.watched || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Shows Rated:</span>
                                <span style="color: white; font-weight: bold;">${showStats.ratings || 0}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #ccc;">Watch Time:</span>
                                <span style="color: white; font-weight: bold;">${Math.round((episodeStats.minutes || 0) / 60)}h</span>
                            </div>
                        </div>
                    </div>
                </div>

                ${stats.network ? `
                <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px; margin-bottom: 1rem;">
                    <h3 style="margin: 0 0 1rem 0; color: #ed1c24;">
                        <i class="fas fa-users"></i> Social Network
                    </h3>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #3b82f6;">${stats.network.friends || 0}</div>
                            <div style="color: #ccc; font-size: 0.9rem;">Friends</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #22c55e;">${stats.network.followers || 0}</div>
                            <div style="color: #ccc; font-size: 0.9rem;">Followers</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #f59e0b;">${stats.network.following || 0}</div>
                            <div style="color: #ccc; font-size: 0.9rem;">Following</div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <div style="text-align: center; margin-top: 2rem;">
                    <button onclick="window.electronAPI?.openExternal('https://trakt.tv/users/me')" style="
                        background: linear-gradient(135deg, #ed1c24 0%, #d41920 100%);
                        color: white;
                        border: none;
                        padding: 0.75rem 1.5rem;
                        border-radius: 8px;
                        font-weight: 600;
                        cursor: pointer;
                        margin-right: 1rem;
                    ">
                        <i class="fas fa-external-link-alt"></i> View Profile on Trakt
                    </button>
                    <button onclick="closeTraktStatisticsModal()" style="
                        background: rgba(255, 255, 255, 0.1);
                        color: white;
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        padding: 0.75rem 1.5rem;
                        border-radius: 8px;
                        font-weight: 600;
                        cursor: pointer;
                    ">
                        Close
                    </button>
                </div>
            `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Add click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeTraktStatisticsModal();
                }
            });

            showNotification('Statistics loaded successfully!', 'success');
        }

        function closeTraktStatisticsModal() {
            const modal = document.getElementById('traktStatisticsModal');
            if (modal) {
                modal.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => {
                    modal.remove();
                }, 300);
            }
        }

        // Add fade animations
        const fadeStyle = document.createElement('style');
        fadeStyle.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: scale(0.9); }
                to { opacity: 1; transform: scale(1); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: scale(1); }
                to { opacity: 0; transform: scale(0.9); }
            }
        `;
        document.head.appendChild(fadeStyle);

        async function loadTraktStats() {
            try {
                const response = await fetch('/api/trakt/user/stats');
                const data = await response.json();

                if (data.success) {
                    traktStats = data.stats;
                    updateTraktActionGrid(data.stats);
                    console.log('[TRAKT PAGE] Stats loaded successfully');
                } else {
                    // Silently use placeholder stats - don't show error notifications
                    console.log('[TRAKT PAGE] Using placeholder stats:', data.error);
                    const placeholderStats = {
                        watchlist: [],
                        collection: { movies: [], shows: [] },
                        ratings: [],
                        movies: { watched: 0, collected: 0, ratings: 0 },
                        shows: { watched: 0, collected: 0, ratings: 0 }
                    };
                    updateTraktActionGrid(placeholderStats);
                }
            } catch (error) {
                // Don't show error notifications for stats loading - just use placeholders
                console.log('[TRAKT PAGE] Stats loading failed, using placeholders:', error);
                const placeholderStats = {
                    watchlist: [],
                    collection: { movies: [], shows: [] },
                    ratings: [],
                    movies: { watched: 0, collected: 0, ratings: 0 },
                    shows: { watched: 0, collected: 0, ratings: 0 }
                };
                updateTraktActionGrid(placeholderStats);
            }
        }

        function updateTraktActionGrid(stats) {
            const actionCards = document.querySelectorAll('.trakt-action-card');
            
            actionCards.forEach(card => {
                const action = card.dataset.action;
                const countEl = card.querySelector('.trakt-action-count');
                
                switch (action) {
                    case 'watchlist':
                        if (countEl) {
                            const count = stats.watchlist?.length || 0;
                            countEl.textContent = count;
                            countEl.style.display = count > 0 ? 'inline-block' : 'none';
                        }
                        break;
                    case 'history':
                        if (countEl) {
                            const movieCount = stats.movies?.watched || 0;
                            const showCount = stats.shows?.watched || 0;
                            const totalCount = movieCount + showCount;
                            countEl.textContent = totalCount;
                            countEl.style.display = totalCount > 0 ? 'inline-block' : 'none';
                        }
                        break;
                    case 'collection':
                        if (countEl) {
                            const movieCount = stats.collection?.movies?.length || 0;
                            const showCount = stats.collection?.shows?.length || 0;
                            const totalCount = movieCount + showCount;
                            countEl.textContent = totalCount;
                            countEl.style.display = totalCount > 0 ? 'inline-block' : 'none';
                        }
                        break;
                    case 'ratings':
                        if (countEl) {
                            const count = stats.ratings?.length || 0;
                            countEl.textContent = count;
                            countEl.style.display = count > 0 ? 'inline-block' : 'none';
                        }
                        break;
                }
            });
            
            console.log('[TRAKT PAGE] Action grid updated with stats');
        }

        function clearTraktActionGrid() {
            const actionCards = document.querySelectorAll('.trakt-action-card');
            actionCards.forEach(card => {
                const countEl = card.querySelector('.trakt-action-count');
                if (countEl) countEl.textContent = '0';
            });
        }

        async function handleTraktActionClick(event) {
            const card = event.currentTarget;
            const action = card.dataset.action;
            
            // Show detailed information for each action
            switch (action) {
                case 'watchlist':
                    await showTraktWatchlistDetails();
                    break;
                case 'history':
                    await showTraktHistoryDetails();
                    break;
                case 'collection':
                    await showTraktCollectionDetails();
                    break;
                case 'ratings':
                    await showTraktRatingsDetails();
                    break;
                default:
                    showNotification('Feature coming soon!', 'info');
            }
        }

        async function showTraktWatchlistDetails() {
            try {
                const response = await fetch('/api/trakt/watchlist');
                const data = await response.json();
                
                if (data.success && data.watchlist) {
                    const count = data.watchlist.length;
                    if (count > 0) {
                        showNotification(`Your watchlist has ${count} items. They will appear automatically when browsing!`, 'success');
                    } else {
                        showNotification('Your watchlist is empty. Add items by clicking the + button on movies and shows!', 'info');
                    }
                } else {
                    showNotification('Could not load watchlist. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] Watchlist details error:', error);
                showNotification('Failed to load watchlist details', 'error');
            }
        }

        async function showTraktHistoryDetails() {
            try {
                const response = await fetch('/api/trakt/history');
                const data = await response.json();
                
                if (data.success && data.history) {
                    const count = data.history.length;
                    if (count > 0) {
                        showNotification(`You've watched ${count} items. Your watch history is automatically tracked!`, 'success');
                    } else {
                        showNotification('No watch history yet. Start watching content and it will be tracked automatically!', 'info');
                    }
                } else {
                    showNotification('Could not load watch history. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] History details error:', error);
                showNotification('Failed to load watch history', 'error');
            }
        }

        async function showTraktCollectionDetails() {
            try {
                const response = await fetch('/api/trakt/collection');
                const data = await response.json();
                
                if (data.success && data.collection) {
                    const movieCount = data.collection.movies?.length || 0;
                    const showCount = data.collection.shows?.length || 0;
                    const total = movieCount + showCount;
                    
                    if (total > 0) {
                        showNotification(`Your collection has ${movieCount} movies and ${showCount} shows (${total} total)`, 'success');
                    } else {
                        showNotification('Your collection is empty. Items are added automatically when you finish watching!', 'info');
                    }
                } else {
                    showNotification('Could not load collection. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] Collection details error:', error);
                showNotification('Failed to load collection details', 'error');
            }
        }

        async function showTraktRatingsDetails() {
            try {
                const response = await fetch('/api/trakt/ratings');
                const data = await response.json();
                
                if (data.success && data.ratings) {
                    const count = data.ratings.length;
                    if (count > 0) {
                        showNotification(`You've rated ${count} items on Trakt. Visit trakt.tv to rate more content!`, 'success');
                    } else {
                        showNotification('You haven\'t rated anything yet. Visit trakt.tv to start rating movies and shows!', 'info');
                    }
                } else {
                    showNotification('Could not load ratings. Make sure you\'re connected to Trakt.', 'error');
                }
            } catch (error) {
                console.error('[TRAKT] Ratings details error:', error);
                showNotification('Failed to load ratings details', 'error');
            }
        }

        function syncTraktPageSettings() {
            // Sync main settings with page settings
            const autoScrobbleToggle = document.getElementById('traktPageAutoScrobble');
            const progressToggle = document.getElementById('traktPageScrobbleProgress');
            const watchlistToggle = document.getElementById('traktPageWatchlistSync');

            if (autoScrobbleToggle && traktAutoScrobbleToggle) {
                autoScrobbleToggle.checked = traktAutoScrobbleToggle.checked;
            }

            if (progressToggle && traktScrobbleProgressToggle) {
                progressToggle.checked = traktScrobbleProgressToggle.checked;
            }

            if (watchlistToggle && traktSyncWatchlistToggle) {
                watchlistToggle.checked = traktSyncWatchlistToggle.checked;
            }
        }

        // ===== TRAKT IMPORT (My List + Done Watching) =====
        let traktImportedOnce = false;

        async function fetchTmdbDetailsById(type, tmdbId) {
            try {
                if (!tmdbId) return null;
                const base = 'https://api.themoviedb.org/3';
                const endpoint = type === 'tv' ? `/tv/${tmdbId}` : `/movie/${tmdbId}`;
                const url = `${base}${endpoint}?api_key=${TMDB_API_KEY}`;
                const resp = await fetch(url);
                if (!resp.ok) return null;
                const j = await resp.json();
                return j;
            } catch(_) { return null; }
        }

        function normalizeYear(from) {
            try { return (from || '').substring(0, 4) || ''; } catch { return ''; }
        }

        async function importTraktWatchlistToMyList(maxPages = 50, pageSize = 100) {
            try {
                // Ensure current list loaded
                await loadMyList();

                let totalAdded = 0;
                for (let page = 1; page <= maxPages; page++) {
                    const res = await fetch(`/api/trakt/watchlist?type=mixed&page=${page}&limit=${pageSize}`);
                    const data = await res.json();
                    if (!data.success || !Array.isArray(data.watchlist) || data.watchlist.length === 0) break;

                    let addedThisPage = 0;
                    for (const entry of data.watchlist) {
                        const isMovie = !!entry.movie;
                        const isShow = !!entry.show;
                        const type = isMovie ? 'movie' : (isShow ? 'tv' : null);
                        const ids = (entry.movie?.ids || entry.show?.ids || {});
                        const tmdbId = ids.tmdb || null;
                        if (!type || !tmdbId) continue;

                        // Skip if already present
                        if (myListCache.some(it => it.id === tmdbId && it.media_type === type)) continue;

                        // Fetch TMDB details to enrich poster/year/rating/title
                        const details = await fetchTmdbDetailsById(type, tmdbId);
                        const title = type === 'tv' ? (details?.name || entry.show?.title || '') : (details?.title || entry.movie?.title || '');
                        const poster_path = details?.poster_path || '';
                        const year = type === 'tv' ? normalizeYear(details?.first_air_date || entry.show?.year) : normalizeYear(details?.release_date || entry.movie?.year);
                        const vote_average = Number(details?.vote_average || 0);
                        const listItem = {
                            id: tmdbId,
                            media_type: type,
                            title,
                            poster_path,
                            year,
                            vote_average,
                            added_date: entry.listed_at || new Date().toISOString()
                        };
                        myListCache.unshift(listItem);
                        addedThisPage++;
                    }
                    totalAdded += addedThisPage;

                    // If we got less than pageSize items, we've reached the end
                    if (data.watchlist.length < pageSize) break;
                }

                if (totalAdded > 0) {
                    await saveMyList();
                    // Refresh page if open
                    if (document.getElementById('myListPage')?.style.display !== 'none') {
                        await displayMyList();
                    }
                }
                return totalAdded;
            } catch (e) {
                console.log('[TRAKT IMPORT] My List failed:', e?.message);
                return 0;
            }
        }

        async function importTraktHistoryToDoneWatching(maxPages = 50, pageSize = 100) {
            try {
                await loadDoneWatching();
                let totalAdded = 0;
                for (let page = 1; page <= maxPages; page++) {
                    const res = await fetch(`/api/trakt/history?type=mixed&page=${page}&limit=${pageSize}`);
                    const data = await res.json();
                    if (!data.success || !Array.isArray(data.history) || data.history.length === 0) break;

                    for (const h of data.history) {
                        const watchedAt = h.watched_at || new Date().toISOString();
                        if (h.movie) {
                            const ids = h.movie.ids || {};
                            const tmdbId = ids.tmdb || null;
                            if (!tmdbId) continue;
                            // Skip if already have movie marked done (whole title)
                            if (doneWatchingCache.some(it => it.id === tmdbId && it.media_type === 'movie' && !it.season && !it.episode)) continue;
                            const details = await fetchTmdbDetailsById('movie', tmdbId);
                            const item = {
                                id: tmdbId,
                                media_type: 'movie',
                                title: details?.title || h.movie.title || '',
                                poster_path: details?.poster_path || '',
                                year: normalizeYear(details?.release_date || h.movie.year),
                                vote_average: Number(details?.vote_average || 0),
                                completed_date: watchedAt
                            };
                            doneWatchingCache.unshift(item);
                            totalAdded++;
                        } else if (h.episode && h.show) {
                            const ids = h.show.ids || {};
                            const tmdbId = ids.tmdb || null;
                            if (!tmdbId) continue;
                            const season = h.episode.season;
                            const episode = h.episode.number;
                            // Skip if this exact episode already present
                            if (doneWatchingCache.some(it => it.id === tmdbId && it.media_type === 'tv' && it.season === season && it.episode === episode)) continue;
                            const details = await fetchTmdbDetailsById('tv', tmdbId);
                            const item = {
                                id: tmdbId,
                                media_type: 'tv',
                                title: details?.name || h.show.title || '',
                                poster_path: details?.poster_path || '',
                                year: normalizeYear(details?.first_air_date || h.show.year),
                                vote_average: Number(details?.vote_average || 0),
                                completed_date: watchedAt,
                                season,
                                episode,
                                episode_title: h.episode.title || `S${season}E${episode}`
                            };
                            doneWatchingCache.unshift(item);
                            totalAdded++;
                        }
                    }

                    // If we received less than requested, we reached the end
                    if (data.history.length < pageSize) break;
                }

                if (totalAdded > 0) {
                    await saveDoneWatching();
                    if (document.getElementById('doneWatchingPage')?.style.display !== 'none') {
                        await displayDoneWatching();
                    }
                }
                return totalAdded;
            } catch (e) {
                console.log('[TRAKT IMPORT] Done Watching failed:', e?.message);
                return 0;
            }
        }

        async function importTraktDataOnceIfNeeded() {
            try {
                if (traktImportedOnce) return;
                // Check if we've imported in the last 24 hours (not just once ever)
                const lastImport = localStorage.getItem('traktLastImport');
                if (lastImport) {
                    const hoursSinceImport = (Date.now() - parseInt(lastImport)) / (1000 * 60 * 60);
                    if (hoursSinceImport < 24) {
                        traktImportedOnce = true;
                        return;
                    }
                }
                
                showNotification('Importing your Trakt data (watchlist & history)...', 'info');
                const [addedList, addedDone] = await Promise.all([
                    importTraktWatchlistToMyList(),
                    importTraktHistoryToDoneWatching(),
                ]);
                traktImportedOnce = true;
                localStorage.setItem('traktLastImport', Date.now().toString());
                const msg = `Imported ${addedList} to My List and ${addedDone} to Done Watching from Trakt`;
                showNotification(msg, 'success');
                // Optionally update visible cards' buttons state
                try {
                    document.querySelectorAll('.movie-card').forEach(card => {
                        // Attempt to extract id/mediaType from onclick attributes
                        const addBtn = card.querySelector('.add-to-list-btn');
                        const doneBtn = card.querySelector('.done-watching-btn');
                        const attr = (addBtn?.getAttribute('onclick') || doneBtn?.getAttribute('onclick') || '') + '';
                        const idMatch = attr.match(/,(\s*)(\d+)(\s*),\s*'(movie|tv)'/);
                        if (idMatch) {
                            const id = parseInt(idMatch[2], 10);
                            const mediaType = idMatch[4];
                            updateCardListStatus(card, id, mediaType);
                            updateCardDoneStatus(card, id, mediaType);
                        }
                    });
                } catch(_) {}
            } catch (e) {
                console.log('[TRAKT IMPORT] unexpected error:', e?.message);
            }
        }

        async function manualResyncTraktLibrary() {
            try {
                const btn = document.getElementById('traktPageResyncLibrary');
                if (!btn) return;

                // Disable button and show loading state
                const originalHTML = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Syncing...';

                showNotification('Starting full Trakt library sync...', 'info');

                // Force re-sync by resetting the import flag
                traktImportedOnce = false;
                localStorage.removeItem('traktLastImport');

                // Import with higher page limits (50 pages  100 = 5000 items max)
                const [addedList, addedDone] = await Promise.all([
                    importTraktWatchlistToMyList(50, 100),
                    importTraktHistoryToDoneWatching(50, 100),
                ]);

                // Update timestamp
                traktImportedOnce = true;
                localStorage.setItem('traktLastImport', Date.now().toString());

                const msg = `Sync complete! Imported ${addedList} to My List and ${addedDone} to Done Watching from Trakt`;
                showNotification(msg, 'success');

                // Update all visible cards
                try {
                    document.querySelectorAll('.movie-card').forEach(card => {
                        const addBtn = card.querySelector('.add-to-list-btn');
                        const doneBtn = card.querySelector('.done-watching-btn');
                        const attr = (addBtn?.getAttribute('onclick') || doneBtn?.getAttribute('onclick') || '') + '';
                        const idMatch = attr.match(/,(\s*)(\d+)(\s*),\s*'(movie|tv)'/);
                        if (idMatch) {
                            const id = parseInt(idMatch[2], 10);
                            const mediaType = idMatch[4];
                            updateCardListStatus(card, id, mediaType);
                            updateCardDoneStatus(card, id, mediaType);
                        }
                    });
                } catch(_) {}

                // Re-enable button
                btn.disabled = false;
                btn.innerHTML = originalHTML;
            } catch (e) {
                console.log('[TRAKT RESYNC] Error:', e?.message);
                showNotification('Trakt sync failed: ' + e?.message, 'error');
                // Re-enable button
                const btn = document.getElementById('traktPageResyncLibrary');
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-cloud-download-alt"></i> Re-sync Library';
                }
            }
        }

        // ===== END TRAKT PAGE FUNCTIONS =====

        // ===== TRAKT SYNC FUNCTIONS FOR IN-APP LISTS =====
        
        async function syncWithTraktWatchlist(action, title, mediaType, year) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping watchlist sync');
                    return;
                }

                const endpoint = action === 'add' ? '/api/trakt/watchlist/add' : '/api/trakt/watchlist/remove';
                const type = mediaType === 'movie' ? 'movie' : 'show';
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year: parseInt(year) })
                });

                const data = await response.json();
                
                if (data.success) {
                    const actionText = action === 'add' ? 'Added to' : 'Removed from';
                    showNotification(`${actionText} Trakt watchlist: "${title}"`, 'success');
                    console.log(`[TRAKT SYNC] ${actionText} watchlist:`, title);
                } else {
                    console.log(`[TRAKT SYNC] Watchlist ${action} failed:`, data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Watchlist sync error:', error);
            }
        }

        async function syncWithTraktWatched(mediaType, title, year) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping watched sync');
                    return;
                }

                // Use scrobble/stop to mark as watched (100% progress)
                const response = await fetch('/api/trakt/scrobble/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        title, 
                        type: mediaType, 
                        year: parseInt(year),
                        progress: 100 
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    showNotification(`Marked "${title}" as watched on Trakt`, 'success');
                    console.log('[TRAKT SYNC] Marked as watched:', title);
                } else {
                    console.log('[TRAKT SYNC] Watched sync failed:', data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Watched sync error:', error);
            }
        }

        async function syncWithTraktWatchedEpisode(showTitle, year, season, episode) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping episode sync');
                    return;
                }

                // Use scrobble/stop to mark episode as watched
                const response = await fetch('/api/trakt/scrobble/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        title: showTitle, 
                        type: 'show', 
                        year: parseInt(year),
                        season: parseInt(season),
                        episode: parseInt(episode),
                        progress: 100 
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    showNotification(`Marked S${season}E${episode} of "${showTitle}" as watched on Trakt`, 'success');
                    console.log('[TRAKT SYNC] Marked episode as watched:', showTitle, `S${season}E${episode}`);
                } else {
                    console.log('[TRAKT SYNC] Episode watched sync failed:', data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Episode watched sync error:', error);
            }
        }

        async function syncWithTraktCollection(action, title, mediaType, year) {
            try {
                // Check if user is authenticated
                const statusResponse = await fetch('/api/trakt/status');
                const statusData = await statusResponse.json();
                if (!statusData.authenticated) {
                    console.log('[TRAKT SYNC] User not authenticated, skipping collection sync');
                    return;
                }

                const endpoint = action === 'add' ? '/api/trakt/collection/add' : '/api/trakt/collection/remove';
                const type = mediaType === 'movie' ? 'movie' : 'show';
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, type, year: parseInt(year) })
                });

                const data = await response.json();
                
                if (data.success) {
                    const actionText = action === 'add' ? 'Added to' : 'Removed from';
                    console.log(`[TRAKT SYNC] ${actionText} collection:`, title);
                } else {
                    console.log(`[TRAKT SYNC] Collection ${action} failed:`, data.error);
                }
            } catch (error) {
                console.log('[TRAKT SYNC] Collection sync error:', error);
            }
        }

        // Function to add episode-specific done watching
        function addEpisodeToDoneWatching(showId, showTitle, season, episode, episodeTitle, year, poster) {
            const episodeItem = {
                id: showId,
                media_type: 'tv',
                title: showTitle,
                episode_title: episodeTitle,
                season: season,
                episode: episode,
                poster_path: poster,
                year: year,
                vote_average: 0,
                completed_date: new Date().toISOString()
            };
            
            // Check if this episode is already in done watching
            const existingIndex = doneWatchingCache.findIndex(item => 
                item.id === showId && item.media_type === 'tv' && 
                item.season === season && item.episode === episode
            );
            
            if (existingIndex === -1) {
                doneWatchingCache.unshift(episodeItem);
                saveDoneWatching();
                
                // Sync with Trakt
                syncWithTraktWatchedEpisode(showTitle, year, season, episode);
                
                showNotification(`Added S${season}E${episode} "${episodeTitle}" to done watching`, 'success');
            } else {
                showNotification(`S${season}E${episode} is already in done watching`, 'info');
            }
        }

        // Toggle episode-specific done watching
        async function toggleEpisodeDoneWatching(event, showId, showTitle, season, episode, episodeTitle, year, poster) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.episode-done-btn');
            if (!button) return;

            const existingIndex = doneWatchingCache.findIndex(item => 
                item.id === showId && item.media_type === 'tv' && 
                item.season === season && item.episode === episode
            );
            
            if (existingIndex >= 0) {
                // Remove episode from done watching
                doneWatchingCache.splice(existingIndex, 1);
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark Episode as Done Watching';
                
                showNotification(`Removed S${season}E${episode} from done watching`, 'info');
            } else {
                // Add episode to done watching
                const episodeItem = {
                    id: showId,
                    media_type: 'tv',
                    title: showTitle,
                    episode_title: episodeTitle,
                    season: season,
                    episode: episode,
                    poster_path: poster,
                    year: year,
                    vote_average: 0,
                    completed_date: new Date().toISOString()
                };
                
                doneWatchingCache.unshift(episodeItem);
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
                
                // Sync with Trakt
                await syncWithTraktWatchedEpisode(showTitle, year, season, episode);
                
                showNotification(`Marked S${season}E${episode} "${episodeTitle}" as watched`, 'success');
            }

            await saveDoneWatching();
            
            // Refresh Done Watching page if it's currently open
            if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                displayDoneWatching();
            }
            // Also update any other cards for the same show immediately
            updateAllDoneButtons(showId, 'tv');
        }

        // Update all .done-watching-btn in DOM for a given id/mediaType
        function updateAllDoneButtons(id, mediaType) {
            document.querySelectorAll('.done-watching-btn').forEach(btn => {
                const onClick = btn.getAttribute('onclick') || '';
                if (onClick.includes('toggleDoneWatching') && onClick.includes(`, ${id},`) && onClick.includes(`'${mediaType}'`)) {
                    const card = btn.closest('.movie-card');
                    if (card) updateCardDoneStatus(card, id, mediaType);
                }
            });
        }

        // ===== END TRAKT SYNC FUNCTIONS =====
        
        // Save Settings: persist useTorrentless and optionally API key, then close modal
        async function saveSettings_() {
            // Get API key from any instance (prefer visible, else any non-empty)
            const apiKeyElements = document.querySelectorAll('#newApiKey');
            let apiKey = '';
            for (const el of apiKeyElements) {
                const val = (el.value || '').trim();
                if (val) {
                    apiKey = val;
                    // Prefer the visible one but accept hidden if that's the only filled one
                    if (el.offsetParent !== null) break;
                }
            }
            
            // Get the toggle that is actually checked (either modal or settings page)
            const toggleElements = document.querySelectorAll('#useTorrentlessToggle');
            let toggleEl = null;
            for (const el of toggleElements) {
                if (el.offsetParent !== null) { // Check if element is visible
                    toggleEl = el;
                    break;
                }
            }
            const desiredTorrentless = toggleEl ? !!toggleEl.checked : useTorrentless;
            
            // Get Jackett URL (prefer visible, else any non-empty)
            const jackettUrlElements = document.querySelectorAll('#jackettUrl');
            let jackettUrl = '';
            for (const el of jackettUrlElements) {
                const val = (el.value || '').trim();
                if (val) {
                    jackettUrl = val;
                    if (el.offsetParent !== null) break;
                }
            }
            
            // Get cache location (prefer visible, else any non-empty)
            const cacheLocationElements = document.querySelectorAll('#cacheLocation');
            let cacheLocation = '';
            for (const el of cacheLocationElements) {
                const val = (el.value || '').trim();
                if (val) {
                    cacheLocation = val;
                    if (el.offsetParent !== null) break;
                }
            }

            // Get AutoUpdater setting (prefer visible)
            const autoUpdateToggles = document.querySelectorAll('#autoUpdateToggle');
            let autoUpdateEnabled = true; // default ON
            for (const el of autoUpdateToggles) {
                if (el.offsetParent !== null) {
                    autoUpdateEnabled = !!el.checked;
                    break;
                }
            }
            
            // Get Discord Activity setting (prefer visible)
            const discordActivityToggles = document.querySelectorAll('#discordActivityToggle');
            let newDiscordActivityEnabled = true; // default ON
            for (const el of discordActivityToggles) {
                if (el.offsetParent !== null) {
                    newDiscordActivityEnabled = !!el.checked;
                    break;
                }
            }
            
            // Get Show Sponsor setting (prefer visible, fallback to any)
            const showSponsorToggles = document.querySelectorAll('#showSponsorToggle');
            let showSponsorEnabled = null;
            // First try to find a visible toggle
            for (const el of showSponsorToggles) {
                if (el.offsetParent !== null) {
                    showSponsorEnabled = !!el.checked;
                    break;
                }
            }
            // Fallback to any toggle if none visible
            if (showSponsorEnabled === null && showSponsorToggles.length > 0) {
                showSponsorEnabled = !!showSponsorToggles[0].checked;
            }
            // Default to true only if no toggles exist
            if (showSponsorEnabled === null) {
                showSponsorEnabled = true;
            }
            
            // Handle fullscreen toggle - get the visible one
            const fullscreenToggles = document.querySelectorAll('#fullscreenToggle');
            let fullscreenToggle = null;
            for (const el of fullscreenToggles) {
                if (el.offsetParent !== null) {
                    fullscreenToggle = el;
                    break;
                }
            }
            
            if (fullscreenToggle && window.electronAPI && window.electronAPI.setFullscreen) {
                try {
                    const result = await window.electronAPI.setFullscreen(fullscreenToggle.checked);
                    if (!result.success) {
                        console.error('Failed to set fullscreen:', result.message);
                        showNotification('Failed to change fullscreen mode');
                    }
                } catch (error) {
                    console.error('Error setting fullscreen:', error);
                    showNotification('Error changing fullscreen mode');
                }
            }
            
            // Handle UI mode change - get the visible radios
            const uiModeNewElements = document.querySelectorAll('#uiModeNew');
            const uiModeOldElements = document.querySelectorAll('#uiModeOld');
            let uiModeNew = null;
            let uiModeOld = null;
            
            for (const el of uiModeNewElements) {
                if (el.offsetParent !== null) {
                    uiModeNew = el;
                    break;
                }
            }
            for (const el of uiModeOldElements) {
                if (el.offsetParent !== null) {
                    uiModeOld = el;
                    break;
                }
            }
            
            let selectedUIMode = 'new';
            if (uiModeOld && uiModeOld.checked) {
                selectedUIMode = 'old';
            }
            
            // Apply UI mode change immediately
            if (selectedUIMode !== currentUIMode) {
                applyUIMode(selectedUIMode);
            }

            let apiResult = null;
            try {
                // Build settings object
                const settings = { 
                    useTorrentless: desiredTorrentless, 
                    autoUpdate: !!autoUpdateEnabled,
                    discordActivity: !!newDiscordActivityEnabled,
                    showSponsor: !!showSponsorEnabled
                };
                if (jackettUrl) settings.jackettUrl = jackettUrl;
                if (cacheLocation) settings.cacheLocation = cacheLocation;
                
                // Update sponsor visibility immediately
                updateSponsorVisibility(showSponsorEnabled);
                
                // Persist all settings including Jackett URL and cache location
                await fetch(`${API_BASE_URL}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                useTorrentless = desiredTorrentless;

                // Update the global cached Discord activity flag
                discordActivityEnabled = !!newDiscordActivityEnabled;
                
                // If Discord activity was disabled, clear the presence immediately
                if (!discordActivityEnabled) {
                    console.log('[Settings] Discord activity disabled, clearing presence');
                    await clearDiscordPresence();
                }

                // If an API key was provided, attempt to save it; otherwise skip quietly
                if (apiKey) {
                    const response = await fetch(`${API_BASE_URL}/set-api-key`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ apiKey })
                    });
                    let keyLoc = null;
                    try {
                        apiResult = await response.json();
                    } catch(_) { apiResult = null; }
                    if (response.ok) {
                        hasApiKey = true;
                        // Confirm and show where it was saved
                        try {
                            const locRes = await fetch(`${API_BASE_URL}/key-location`);
                            if (locRes.ok) keyLoc = await locRes.json();
                        } catch(_) {}
                        await loadCurrentApiKey();
                        if (keyLoc?.hasApiKey && keyLoc?.path) {
                            showNotification(`Settings saved. API key updated at ${keyLoc.path}`);
                        } else {
                            showNotification('Settings saved. API key updated.');
                        }
                        // Clear ALL API key inputs after success
                        document.querySelectorAll('#newApiKey').forEach(el => { el.value = ''; });
                    } else {
                        showNotification(apiResult?.error || 'Failed to update API key');
                    }
                } else {
                    showNotification('Settings saved.');
                }
            } catch (error) {
                console.error('Error saving settings:', error);
                // Even if API key call fails, close the modal when toggling Torrentless is desired
            } finally {
                // Check if we're on settings page or in modal
                if (window.location.hash === '#/settings') {
                    // Stay on settings page, just show notification
                    // Navigation will be handled by cancel button if needed
                } else {
                    hideSettingsModal();
                }
            }
        }
        
        // Helper functions for page navigation (used by sidebar)
        function showHomePage() {
            window.location.hash = '#/';
        }
        
        function showGenresPage() {
            window.location.hash = '#/genres';
        }
        
        function showCustomMagnetModal() {
            const modal = document.getElementById('custom-magnet-modal');
            const input = document.getElementById('custom-magnet-input');
            if (modal) {
                modal.style.display = 'flex';
                modal.classList.add('active');
                modal.style.opacity = '1';
                modal.style.pointerEvents = 'auto';
                if (input) {
                    input.value = '';
                    setTimeout(() => input.focus(), 100);
                }
            }
        }
        
        function showMyListPage() {
            window.location.hash = '#/my-list';
        }
        
        function showDoneWatchingPage() {
            window.location.hash = '#/done-watching';
        }
        
        function showTraktPage() {
            window.location.hash = '#/trakt';
        }
        
        function showLiveTvPage() {
            window.location.hash = '#/livetv';
        }
        
        function showIptvPage() {
            window.location.hash = '#/iptv';
            try { updateIptvActionButton(); } catch(_) {}
        }
        
        function reloadIptvPage() {
            const iptvIframe = document.getElementById('iptv-iframe');
            const iptvSelector = document.getElementById('iptv-source-select');
            if (iptvIframe) {
                // Get current selected source URL
                const currentSrc = iptvSelector ? iptvSelector.value : 'https://iptvplaytorrio.pages.dev/';
                // Clear the src first to force a complete reload
                iptvIframe.src = 'about:blank';
                // Use a timeout to ensure the blank page loads before setting the new src
                setTimeout(() => {
                    iptvIframe.src = currentSrc;
                    // Auto-scroll the IPTV page itself (not the iframe content) to show the iframe
                    setTimeout(() => {
                        const iptvPageEl = document.getElementById('iptv-page');
                        if (iptvPageEl) {
                            // Scroll the main page to focus on the iframe area
                            iptvIframe.scrollIntoView({ 
                                behavior: 'smooth',
                                block: 'start'
                            });
                            console.log('[IPTV] Auto-scrolled IPTV page to show iframe');
                        }
                    }, 300); // Quick scroll after iframe starts loading
                }, 100);
                console.log('[IPTV] Page reloaded fresh with source:', currentSrc);
            }
        }

        // IPTV source selector handler
        function initIptvSourceSelector() {
            const iptvSelector = document.getElementById('iptv-source-select');
            const iptvIframe = document.getElementById('iptv-iframe');
            
            if (iptvSelector && iptvIframe) {
                iptvSelector.addEventListener('change', (event) => {
                    const selectedUrl = event.target.value;
                    const selectedOption = event.target.selectedOptions[0];
                    const isExternal = selectedOption.hasAttribute('data-external');
                    
                    console.log('[IPTV] Switching to source:', selectedUrl, 'external:', isExternal);
                    
                    if (isExternal) {
                        // Open in external browser for sites that don't allow embedding
                        if (window.electronAPI?.openExternal) {
                            window.electronAPI.openExternal(selectedUrl);
                            showNotification('Opening IPTV Web App in browser...', 'info');
                            // Reset dropdown to previous working option
                            setTimeout(() => {
                                iptvSelector.value = 'https://iptvplaytorrio.pages.dev/';
                            }, 100);
                        }
                    } else {
                        // Show loading indication
                        iptvIframe.style.opacity = '0.5';
                        
                        // Clear and load new source
                        iptvIframe.src = 'about:blank';
                        setTimeout(() => {
                            iptvIframe.src = selectedUrl;
                            iptvIframe.style.opacity = '1';
                            showNotification('Loading IPTV source...', 'info');
                        }, 100);
                    }
                });

                // Add error handling for iframe loading
                iptvIframe.addEventListener('load', () => {
                    console.log('[IPTV] Iframe loaded successfully');
                    iptvIframe.style.opacity = '1';
                });

                iptvIframe.addEventListener('error', (e) => {
                    console.error('[IPTV] Iframe failed to load:', e);
                    showNotification('Failed to load IPTV source. Site may block embedding.', 'error');
                    iptvIframe.style.opacity = '1';
                });
                
                console.log('[IPTV] Source selector initialized');
            }
        }
        
        function clearIptvPage() {
            const iptvIframe = document.getElementById('iptv-iframe');
            if (iptvIframe) {
                // Clear the iframe to stop any ongoing streams
                iptvIframe.src = 'about:blank';
                console.log('[IPTV] Page cleared - stopping all streams');
            }
        }

        // ===== Custom IPTV (Xtream Codes) =====
        function disableIptvIframe() {
            try {
                const iptvIframe = document.getElementById('iptv-iframe');
                if (iptvIframe) {
                    iptvIframe.src = 'about:blank';
                    iptvIframe.style.display = 'none';
                    console.log('[IPTV] Default iframe disabled (custom Xtream active)');
                }
            } catch(_) {}
        }

        function enableIptvIframe() {
            try {
                const iptvIframe = document.getElementById('iptv-iframe');
                if (iptvIframe) {
                    iptvIframe.style.display = '';
                    if (!iptvIframe.src || iptvIframe.src === 'about:blank') {
                        iptvIframe.src = 'https://iptvplaytorrio.pages.dev/';
                    }
                    console.log('[IPTV] Default iframe enabled');
                }
            } catch(_) {}
        }
        const xtreamState = {
            base: '',
            username: '',
            password: '',
            tab: 'live', // 'live' | 'vod' | 'series'
            active: false,
            mode: 'none', // 'none' | 'xtream' | 'm3u'
            liveCategories: [],
            vodCategories: [],
            seriesCategories: [],
            lastStreams: [],
            m3u: { items: [], categories: [] },
            displayedIndex: 0,
            pageSize: 50,
        };

        // Persistent IPTV settings helpers
        async function iptvLoadSettings() {
            try {
                const resp = await fetch('/api/iptv/settings', { cache: 'no-store' });
                const data = await resp.json();
                return data?.iptv || { lastMode: 'iframe', rememberCreds: false, xtream: { base: '', username: '', password: '' }, m3u: { url: '' } };
            } catch {
                // Fallback to localStorage for backward compatibility
                try {
                    const saved = JSON.parse(localStorage.getItem('xtreamCodesCreds') || '{}');
                    return { lastMode: 'iframe', rememberCreds: !!(saved.base || saved.username || saved.password), xtream: { base: saved.base||'', username: saved.username||'', password: saved.password||'' }, m3u: { url: '' } };
                } catch { return { lastMode: 'iframe', rememberCreds: false, xtream: { base: '', username: '', password: '' }, m3u: { url: '' } }; }
            }
        }

        async function iptvSaveSettings(patch = {}) {
            try {
                await fetch('/api/iptv/settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch) });
            } catch (e) {
                console.warn('[IPTV] Failed to save settings', e);
            }
        }

        // Auto-restore IPTV state from saved settings on app load
        async function xtreamAutoLogin(base, username, password) {
            try {
                let apiBase = xtreamNormalizeBase(base);
                const loginParams = `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`;
                async function attemptLogin(baseUrl) {
                    const url = `/api/proxy/xtream?base=${encodeURIComponent(baseUrl)}&params=${encodeURIComponent(loginParams)}`;
                    const resp = await fetch(url, { cache: 'no-store' });
                    if (!resp.ok) throw new Error('Server returned ' + resp.status);
                    const data = await resp.json();
                    return { data, baseUrl };
                }
                let { data, baseUrl } = await attemptLogin(apiBase);
                if (!data || data.nonJson || (!data.user_info && !data.server_info)) {
                    try {
                        const flipped = apiBase.startsWith('https://') ? apiBase.replace(/^https:\/\//i, 'http://') : apiBase.replace(/^http:\/\//i, 'https://');
                        const retry = await attemptLogin(flipped);
                        if (retry?.data && !retry.data.nonJson && (retry.data.user_info || retry.data.server_info)) {
                            data = retry.data; baseUrl = retry.baseUrl; apiBase = flipped;
                        }
                    } catch {}
                }
                if (!data || data.nonJson) throw new Error('Non-JSON response');
                if (data.user_info && String(data.user_info.status).toLowerCase() !== 'active') throw new Error('Account is not active');
                xtreamState.base = apiBase; xtreamState.username = username; xtreamState.password = password; xtreamState.tab = 'live';
                xtreamState.active = true; xtreamState.mode = 'xtream';
                await xtreamLoadAllCategories();
                try { clearIptvPage(); disableIptvIframe(); } catch(_) {}
                hideXtreamLoginModal();
                showXtreamBrowser();
                await xtreamRenderCurrentTab();
                updateIptvActionButton();
                showNotification('Xtream Codes connected (restored)', 'success');
            } catch (e) {
                console.warn('[XTREAM] auto-login failed:', e?.message || e);
                // Fall back to iframe to keep UI usable
                try { enableIptvIframe(); } catch(_) {}
                updateIptvActionButton();
            }
        }

        async function iptvAutoRestore() {
            try {
                const saved = await iptvLoadSettings();
                const mode = saved?.lastMode || 'iframe';
                if (mode === 'iframe') {
                    try { enableIptvIframe(); hideXtreamBrowser(); } catch(_) {}
                    updateIptvActionButton();
                    return;
                }
                if (mode === 'm3u' && saved?.m3u?.url) {
                    await loadM3UFromUrl(saved.m3u.url);
                    return;
                }
                if (mode === 'xtream' && saved?.rememberCreds && saved?.xtream?.base && saved?.xtream?.username && saved?.xtream?.password) {
                    await xtreamAutoLogin(saved.xtream.base, saved.xtream.username, saved.xtream.password);
                    return;
                }
                // Default fallback
                try { enableIptvIframe(); hideXtreamBrowser(); } catch(_) {}
                updateIptvActionButton();
            } catch (e) {
                console.warn('[IPTV] auto-restore failed:', e?.message || e);
                try { enableIptvIframe(); hideXtreamBrowser(); } catch(_) {}
                updateIptvActionButton();
            }
        }

        function xtreamNormalizeBase(url) {
            if (!url) return '';
            let u = (url + '').trim();
            // Add scheme if missing
            if (!/^https?:\/\//i.test(u)) u = 'http://' + u;
            // Remove query/fragment for base
            try { const tmp = new URL(u); u = tmp.origin + tmp.pathname; } catch {}
            // Strip common portal/file suffixes
            u = u.replace(/\/+$/, '');
            u = u.replace(/\/(player_api\.php|xmltv\.php|get\.php)$/i, '');
            u = u.replace(/\/(c|panel_api|client_area)\/?$/i, '');
            // Final trim of trailing slashes
            u = u.replace(/\/+$/, '');
            return u;
        }

        async function showXtreamLoginModal(prefill = true) {
            const modal = document.getElementById('xtream-login-modal');
            if (!modal) return;
            // prefill from storage
            if (prefill) {
                try {
                    const saved = await iptvLoadSettings();
                    const baseEl = document.getElementById('xtream-base-url');
                    const userEl = document.getElementById('xtream-username');
                    const passEl = document.getElementById('xtream-password');
                    const remEl = document.getElementById('xtream-remember');
                    const m3uEl = document.getElementById('xtream-m3u-url');
                    if (saved?.xtream) {
                        if (saved.rememberCreds) {
                            if (baseEl) baseEl.value = saved.xtream.base || '';
                            if (userEl) userEl.value = saved.xtream.username || '';
                            if (passEl) passEl.value = saved.xtream.password || '';
                        }
                        if (remEl) remEl.checked = !!saved.rememberCreds;
                    }
                    if (m3uEl && saved?.m3u?.url) m3uEl.value = saved.m3u.url;
                } catch(_) {}
            }
            modal.style.display = 'flex';
        }

        function hideXtreamLoginModal() {
            const modal = document.getElementById('xtream-login-modal');
            if (modal) modal.style.display = 'none';
        }

        function showXtreamBrowser() {
            const inline = document.getElementById('xtream-inline');
            const grid = document.getElementById('xtream-grid');
            const empty = document.getElementById('xtream-empty');
            const search = document.getElementById('xtream-search');
            const cat = document.getElementById('xtream-category-select');
            if (inline) inline.style.display = 'block';
            if (grid) grid.innerHTML = '';
            if (empty) empty.style.display = '';
            if (search) search.value = '';
            if (cat) cat.innerHTML = '<option value="">All Categories</option>';
        }

        function hideXtreamBrowser() {
            const inline = document.getElementById('xtream-inline');
            if (inline) inline.style.display = 'none';
        }

        let xtreamHls = null;

        function ensureHlsScriptLoaded() {
            return new Promise((resolve, reject) => {
                if (window.Hls) return resolve();
                const existing = document.getElementById('hlsjs-script');
                if (existing) {
                    existing.addEventListener('load', () => resolve());
                    existing.addEventListener('error', () => reject(new Error('Failed to load hls.js')));
                    return;
                }
                const s = document.createElement('script');
                s.id = 'hlsjs-script';
                s.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
                s.async = true;
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('Failed to load hls.js'));
                document.head.appendChild(s);
            });
        }

        async function showXtreamPlayer(title, url) {
            const modal = document.getElementById('xtream-player-modal');
            const video = document.getElementById('xtream-video');
            const label = document.getElementById('xtream-player-title');
            const openBtn = document.getElementById('xtream-open-external');
            const openMpvBtn = document.getElementById('xtream-open-mpv');
            const openIinaBtn = document.getElementById('xtream-open-iina');
            const openVlcBtn = document.getElementById('xtream-open-vlc');
            if (!modal || !video) return;
            // reset any previous playback and hls instance
            try { video.pause(); } catch(_) {}
            try { if (xtreamHls) { xtreamHls.destroy(); xtreamHls = null; } } catch(_) {}
            video.removeAttribute('src');
            video.load();
            video.crossOrigin = 'anonymous';
            if (label) label.textContent = title || 'Playing';

            // Toggle buttons per platform
            const platform = window.electronAPI?.platform;
            if (openMpvBtn) {
                openMpvBtn.style.display = 'inline-flex'; // Show on all platforms
                openMpvBtn.innerHTML = '<i class="fas fa-play"></i> Play Now';
            }
            if (openIinaBtn) openIinaBtn.style.display = (platform === 'darwin') ? 'inline-flex' : 'none';

            // External open buttons
            if (openBtn) {
                openBtn.onclick = () => {
                    if (window.electronAPI?.openExternal) window.electronAPI.openExternal(url);
                    else window.open(url, '_blank');
                };
            }
            if (openMpvBtn) {
                openMpvBtn.onclick = async () => {
                    try {
                        // Integrated HTML5 player (replaces mpv.js)
                        if (window.electronAPI && window.electronAPI.spawnMpvjsPlayer) {
                            const payload = { url };
                            const result = await window.electronAPI.spawnMpvjsPlayer(payload);
                            if (!result || !result.success) {
                                showNotification(result?.message || 'Failed to launch player');
                            }
                            return;
                        }
                        showNotification('Integrated player not available');
                    } catch (e) {
                        showNotification('Failed to launch player: ' + (e?.message || e));
                    }
                };
            }
            if (openIinaBtn) {
                openIinaBtn.onclick = async () => {
                    try {
                        if (!window.electronAPI || !window.electronAPI.openInIINA) {
                            showNotification('IINA integration not available in this environment');
                            return;
                        }
                        const data = { streamUrl: url };
                        const result = await window.electronAPI.openInIINA(data);
                        if (!result || !result.success) {
                            showNotification(result?.message || 'Failed to launch IINA');
                        }
                    } catch (e) {
                        showNotification('Failed to launch IINA: ' + (e?.message || e));
                    }
                };
            }
            if (openVlcBtn) {
                openVlcBtn.onclick = async () => {
                    try {
                        if (!window.electronAPI || !window.electronAPI.openInVLC) {
                            showNotification('VLC integration not available in this environment');
                            return;
                        }
                        const data = { streamUrl: url };
                        const result = await window.electronAPI.openInVLC(data);
                        if (!result || !result.success) {
                            showNotification(result?.message || 'Failed to launch VLC');
                        }
                    } catch (e) {
                        showNotification('Failed to launch VLC: ' + (e?.message || e));
                    }
                };
            }
            modal.style.display = 'flex';
            // Choose playback method
            const isHls = /\.m3u8(\?|$)/i.test(url);
            if (isHls) {
                try {
                    await ensureHlsScriptLoaded();
                    if (window.Hls && window.Hls.isSupported()) {
                        xtreamHls = new window.Hls({ enableWorker: true });
                        xtreamHls.loadSource(url);
                        xtreamHls.attachMedia(video);
                        xtreamHls.on(window.Hls.Events.MANIFEST_PARSED, () => {
                            try { video.play().catch(()=>{}); } catch(_) {}
                        });
                        xtreamHls.on(window.Hls.Events.ERROR, (e, data) => {
                            if (data && data.fatal) {
                                try { xtreamHls.destroy(); } catch(_) {}
                                xtreamHls = null;
                                // If this is an Xtream live stream, try TS fallback before opening browser
                                if ((xtreamState.mode === 'xtream') && /\.m3u8(\?|$)/i.test(url)) {
                                    const tsUrl = url.replace(/\.m3u8(\?.*)?$/i, '.ts$1');
                                    try {
                                        video.src = tsUrl;
                                        video.load();
                                        video.play().catch(() => {
                                            showNotification('HLS failed. TS fallback also failed. Use "Open in Browser" if desired.', 'error');
                                        });
                                    } catch (_) {
                                        showNotification('HLS failed. Use "Open in Browser" if desired.', 'error');
                                    }
                                } else {
                                    showNotification('HLS playback error. Use "Open in Browser" if desired.', 'error');
                                }
                            }
                        });
                    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                        video.src = url;
                        setTimeout(() => { try { video.play().catch(()=>{}); } catch(_) {} }, 50);
                    } else {
                        // No HLS support
                        showNotification('HLS not supported by this device. Use "Open in Browser" or external players.', 'warning');
                    }
                } catch (e) {
                    console.error('[HLS] load error:', e);
                    showNotification('Failed to initialize HLS. Use "Open in Browser" if desired.', 'error');
                }
            } else {
                // Regular file/stream
                try {
                    video.src = url;
                    video.currentTime = 0;
                    video.load();
                    setTimeout(() => { try { video.play().catch(()=>{}); } catch(_) {} }, 50);
                } catch {
                    showNotification('Playback failed. Use "Open in Browser" if desired.', 'error');
                }
            }
            // add basic error fallback
            const onError = () => {
                showNotification('Playback error. Use "Open in Browser" if desired.', 'error');
            };
            video.onerror = onError;
        }

        function hideXtreamPlayer() {
            const modal = document.getElementById('xtream-player-modal');
            const video = document.getElementById('xtream-video');
            if (video) { try { video.pause(); } catch(_) {} video.removeAttribute('src'); video.load(); }
            try { if (xtreamHls) { xtreamHls.destroy(); xtreamHls = null; } } catch(_) {}
            if (modal) modal.style.display = 'none';
        }

        function updateIptvActionButton() {
            const btn = document.getElementById('iptv-custom-btn');
            if (!btn) return;
            if (xtreamState.active) {
                btn.innerHTML = '<i class="fas fa-exchange-alt"></i> Use PlayTorrio IPTV';
                btn.title = 'Switch back to the default IPTV page';
            } else {
                btn.innerHTML = '<i class="fas fa-user-lock"></i> Custom IPTV (Xtream Codes)';
                btn.title = 'Login with your Xtream Codes provider';
            }
        }

        function iptvActionButtonClick() {
            if (xtreamState.active) {
                // Switch back to default IPTV
                try { hideXtreamBrowser(); } catch(_) {}
                try { hideXtreamPlayer(); } catch(_) {}
                try { enableIptvIframe(); } catch(_) {}
                xtreamState.active = false;
                // persist last mode
                iptvSaveSettings({ lastMode: 'iframe' });
                updateIptvActionButton();
                showNotification('Switched to PlayTorrio IPTV', 'success');
            } else {
                // Open login for custom Xtream
                showXtreamLoginModal(true);
            }
        }

        async function xtreamLogin() {
            const baseEl = document.getElementById('xtream-base-url');
            const userEl = document.getElementById('xtream-username');
            const passEl = document.getElementById('xtream-password');
            const remember = document.getElementById('xtream-remember')?.checked;
            const status = document.getElementById('xtream-login-status');
            const btn = document.getElementById('xtream-login-submit');

            const base = xtreamNormalizeBase(baseEl.value);
            const username = (userEl.value || '').trim();
            const password = (passEl.value || '').trim();
            if (!base || !username || !password) {
                if (status) status.textContent = 'Please fill all fields.';
                return;
            }

            if (btn) { btn.disabled = true; btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Logging in...'; }
            if (status) status.textContent = 'Contacting server...';
            try {
                let apiBase = xtreamNormalizeBase(base);
                const loginParams = `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`;

                async function attemptLogin(baseUrl) {
                    const url = `/api/proxy/xtream?base=${encodeURIComponent(baseUrl)}&params=${encodeURIComponent(loginParams)}`;
                    const resp = await fetch(url, { cache: 'no-store' });
                    if (!resp.ok) throw new Error('Server returned ' + resp.status);
                    const data = await resp.json();
                    return { data, baseUrl };
                }

                let { data, baseUrl } = await attemptLogin(apiBase);
                // If non-JSON or invalid, retry once with scheme flipped (http<->https)
                if (!data || data.nonJson || (!data.user_info && !data.server_info)) {
                    try {
                        const flipped = apiBase.startsWith('https://')
                            ? apiBase.replace(/^https:\/\//i, 'http://')
                            : apiBase.replace(/^http:\/\//i, 'https://');
                        const retry = await attemptLogin(flipped);
                        if (retry?.data && !retry.data.nonJson && (retry.data.user_info || retry.data.server_info)) {
                            data = retry.data; baseUrl = retry.baseUrl; apiBase = flipped;
                        }
                    } catch {}
                }

                if (!data || data.nonJson) {
                    const detail = data?.contentType ? ` (${data.contentType}${data.status ? ', ' + data.status : ''})` : '';
                    throw new Error('Server returned non-JSON response' + detail);
                }
                if (!data.user_info && !data.server_info) throw new Error('Invalid response');
                if (data.user_info && String(data.user_info.status).toLowerCase() !== 'active') {
                    throw new Error('Account is not active');
                }
                xtreamState.base = apiBase; xtreamState.username = username; xtreamState.password = password; xtreamState.tab = 'live';
                xtreamState.active = true; xtreamState.mode = 'xtream';
                // persist settings (respect remember toggle for credentials)
                if (remember) {
                    await iptvSaveSettings({ lastMode: 'xtream', rememberCreds: true, xtream: { base, username, password } });
                } else {
                    await iptvSaveSettings({ lastMode: 'xtream', rememberCreds: false, xtream: { base: '', username: '', password: '' } });
                }
                if (status) status.textContent = 'Login successful. Loading categories...';
                await xtreamLoadAllCategories();
                // Disable the default IPTV iframe when using custom Xtream
                try { clearIptvPage(); disableIptvIframe(); } catch(_) {}
                hideXtreamLoginModal();
                showXtreamBrowser();
                await xtreamRenderCurrentTab();
                showNotification('Xtream Codes connected', 'success');
                updateIptvActionButton();
            } catch (e) {
                console.error('[XTREAM] Login error:', e);
                if (status) status.textContent = 'Login failed: ' + (e?.message || 'Unknown error');
                showNotification('Xtream login failed: ' + (e?.message || 'Unknown error'), 'error');
            } finally {
                if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-sign-in-alt"></i> Login'; }
            }
        }

        // ---- M3U/M3U8 Support ----
        function parseM3U(text) {
            const lines = (text || '').split(/\r?\n/);
            const items = [];
            let current = null;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                if (line.startsWith('#EXTINF:')) {
                    // Parse attributes from EXTINF
                    const attrPart = line.substring(line.indexOf(',') > -1 ? 0 : line.length);
                    const name = line.substring(line.indexOf(',') + 1).trim();
                    const attrs = {};
                    const attrRegex = /(\w[\w-]*)=\"([^\"]*)\"/g;
                    let m;
                    while ((m = attrRegex.exec(line)) !== null) {
                        attrs[m[1]] = m[2];
                    }
                    current = {
                        name: name || attrs['tvg-name'] || attrs['channel-name'] || 'Channel',
                        logo: attrs['tvg-logo'] || '',
                        group: attrs['group-title'] || 'Other',
                        url: ''
                    };
                } else if (!line.startsWith('#') && current) {
                    current.url = line;
                    items.push(current);
                    current = null;
                }
            }
            // Build categories
            const cats = Array.from(new Set(items.map(it => it.group || 'Other'))).sort();
            return { items, categories: cats };
        }

        async function loadM3UFromUrl(url) {
            const status = document.getElementById('xtream-login-status');
            try {
                if (status) status.textContent = 'Loading playlist...';
                const proxyUrl = `/api/proxy/fetch-text?url=${encodeURIComponent(url)}`;
                const resp = await fetch(proxyUrl, { cache: 'no-store' });
                if (!resp.ok) throw new Error('Playlist request failed: ' + resp.status);
                const text = await resp.text();
                const parsed = parseM3U(text);
                if (!parsed.items.length) throw new Error('No channels found in playlist');
                xtreamState.m3u = parsed;
                xtreamState.tab = 'live';
                xtreamState.active = true; xtreamState.mode = 'm3u';
                // persist last mode and playlist URL
                await iptvSaveSettings({ lastMode: 'm3u', m3u: { url } });
                // Disable default IPTV iframe
                try { clearIptvPage(); disableIptvIframe(); } catch(_) {}
                hideXtreamLoginModal();
                showXtreamBrowser();
                await xtreamRenderCurrentTab();
                updateIptvActionButton();
                showNotification(`Loaded ${parsed.items.length} playlist items`, 'success');
            } catch (e) {
                console.error('[M3U] Load error:', e);
                if (status) status.textContent = 'Failed to load playlist: ' + (e?.message || 'Unknown error');
                showNotification('Failed to load playlist: ' + (e?.message || 'Unknown error'), 'error');
            }
        }

        function isDirectMediaUrl(u) {
            try {
                const url = (u || '').toLowerCase();
                return /\.(m3u8|mp4|mp3|aac|m4a|ts|webm|mkv|mov|avi)(\?|$)/.test(url);
            } catch { return false; }
        }

        async function xtreamFetch(pathParams) {
            const { base, username, password } = xtreamState;
            const qs = `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}${pathParams ? '&' + pathParams : ''}`;
            async function attempt(baseUrl) {
                const url = `/api/proxy/xtream?base=${encodeURIComponent(baseUrl)}&params=${encodeURIComponent(qs)}`;
                const resp = await fetch(url, { cache: 'no-store' });
                if (!resp.ok) throw new Error('Request failed: ' + resp.status);
                const data = await resp.json();
                return { data, baseUrl };
            }
            let { data, baseUrl } = await attempt(base);
            if (!data || data.nonJson) {
                try {
                    const flipped = base.startsWith('https://') ? base.replace(/^https:\/\//i, 'http://') : base.replace(/^http:\/\//i, 'https://');
                    const retry = await attempt(flipped);
                    if (retry?.data && !retry.data.nonJson) { data = retry.data; baseUrl = retry.baseUrl; }
                } catch {}
            }
            if (!data || data.nonJson) {
                const detail = data?.contentType ? ` (${data.contentType}${data.status ? ', ' + data.status : ''})` : '';
                throw new Error('Xtream API returned non-JSON' + detail);
            }
            return data;
        }

        async function xtreamLoadAllCategories() {
            try {
                const [live, vod, series] = await Promise.all([
                    xtreamFetch('action=get_live_categories').catch(()=>[]),
                    xtreamFetch('action=get_vod_categories').catch(()=>[]),
                    xtreamFetch('action=get_series_categories').catch(()=>[])
                ]);
                xtreamState.liveCategories = Array.isArray(live) ? live : [];
                xtreamState.vodCategories = Array.isArray(vod) ? vod : [];
                xtreamState.seriesCategories = Array.isArray(series) ? series : [];
            } catch (e) {
                console.warn('[XTREAM] Failed to load some categories:', e);
            }
        }

        function xtreamPopulateCategories() {
            const select = document.getElementById('xtream-category-select');
            if (!select) return;
            const tab = xtreamState.tab;
            let cats = [];
            if (xtreamState.mode === 'm3u') {
                // Only one logical tab: live
                cats = (xtreamState.m3u?.categories) || [];
            } else {
                if (tab === 'live') cats = xtreamState.liveCategories; else if (tab === 'vod') cats = xtreamState.vodCategories; else cats = xtreamState.seriesCategories;
            }
            const current = select.value;
            select.innerHTML = '<option value="">All Categories</option>';
            
            // Show all categories - dropdown will naturally scroll
            if (xtreamState.mode === 'm3u') {
                cats.forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                });
            } else {
                cats.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.category_id;
                    opt.textContent = c.category_name || ('Category ' + c.category_id);
                    select.appendChild(opt);
                });
            }
            // try keep selection if exists
            if ([...select.options].some(o => o.value === current)) select.value = current;
        }

        function xtreamBuildStreamUrl(kind, stream) {
            const { base, username, password } = xtreamState;
            if (!stream) return '';
            if (xtreamState.mode === 'm3u') {
                return stream.url || '';
            }
            const id = stream.stream_id || stream.series_id || stream.id;
            if (kind === 'live') {
                const ext = (stream?.container_extension) ? stream.container_extension.replace(/^\./,'') : 'm3u8';
                return `${base}/live/${encodeURIComponent(username)}/${encodeURIComponent(password)}/${id}.${ext}`;
            } else if (kind === 'vod') {
                const ext = (stream?.container_extension) ? stream.container_extension.replace(/^\./,'') : 'mp4';
                return `${base}/movie/${encodeURIComponent(username)}/${encodeURIComponent(password)}/${id}.${ext}`;
            }
            return '';
        }

        async function xtreamLoadStreamsForCurrentTab(categoryId = '') {
            const tab = xtreamState.tab;
            try {
                let list = [];
                if (xtreamState.mode === 'm3u') {
                    const all = (xtreamState.m3u?.items) || [];
                    if (!categoryId) list = all;
                    else list = all.filter(it => (it.group || '') === categoryId);
                } else if (tab === 'live') {
                    const p = categoryId ? `action=get_live_streams&category_id=${encodeURIComponent(categoryId)}` : 'action=get_live_streams';
                    list = await xtreamFetch(p);
                } else if (tab === 'vod') {
                    const p = categoryId ? `action=get_vod_streams&category_id=${encodeURIComponent(categoryId)}` : 'action=get_vod_streams';
                    list = await xtreamFetch(p);
                } else {
                    const p = categoryId ? `action=get_series&category_id=${encodeURIComponent(categoryId)}` : 'action=get_series';
                    list = await xtreamFetch(p);
                }
                xtreamState.lastStreams = Array.isArray(list) ? list : [];
                // Initialize pagination
                xtreamState.displayedIndex = 0;
                xtreamState.pageSize = 50; // Load 50 items at a time
            } catch (e) {
                console.error('[XTREAM] Load streams error:', e);
                xtreamState.lastStreams = [];
            }
        }

        function xtreamRenderGrid(append = false) {
            const grid = document.getElementById('xtream-grid');
            const empty = document.getElementById('xtream-empty');
            const search = (document.getElementById('xtream-search')?.value || '').toLowerCase().trim();
            if (!grid || !empty) return;

            let items = xtreamState.lastStreams || [];
            if (search) {
                items = items.filter(it => ((it.name || it.title || '').toLowerCase().includes(search)));
            }

            // Pagination logic
            const start = append ? xtreamState.displayedIndex : 0;
            const end = start + xtreamState.pageSize;
            const itemsToRender = items.slice(start, end);
            
            if (!append) {
                grid.innerHTML = '';
            }
            
            if (!items.length) {
                empty.style.display = '';
                return;
            }
            empty.style.display = 'none';

            const tab = xtreamState.tab;
            itemsToRender.forEach(it => {
                const card = document.createElement('div');
                card.className = 'music-card';
                card.style.cursor = 'default';
                const name = xtreamState.mode === 'm3u' ? (it.name || 'Channel') : (it.name || it.title || `ID ${it.stream_id || it.series_id || ''}`);
                const poster = xtreamState.mode === 'm3u' ? (it.logo || '') : (it.stream_icon || it.cover || it.movie_image || '');
                const playUrl = (tab === 'series' && xtreamState.mode !== 'm3u') ? '' : xtreamBuildStreamUrl(tab, it);
                const btns = (tab === 'series' && xtreamState.mode !== 'm3u') ? `
                    <button class="btn" style="padding:.4rem .7rem; border:none; border-radius:6px; background:linear-gradient(135deg,#f59e0b,#b45309); color:#fff; cursor:pointer;" data-action="series" data-id="${it.series_id}">
                        <i class="fas fa-list"></i> Episodes
                    </button>
                ` : `
                    <button class="btn" style="padding:.4rem .7rem; border:none; border-radius:6px; background:linear-gradient(135deg,#10b981,#059669); color:#fff; cursor:pointer;" data-action="play" data-url="${playUrl}" data-name="${name.replace(/"/g,'&quot;')}">
                        <i class="fas fa-play"></i> Play
                    </button>
                    <button class="btn" style="padding:.4rem .7rem; border:none; border-radius:6px; background:linear-gradient(135deg,#3b82f6,#2563eb); color:#fff; cursor:pointer;" data-action="open" data-url="${playUrl}">
                        <i class="fas fa-external-link-alt"></i>
                    </button>
                    <button class="btn" style="padding:.4rem .7rem; border:none; border-radius:6px; background:rgba(255,255,255,.1); color:#fff; cursor:pointer;" data-action="copy" data-url="${playUrl}">
                        <i class="fas fa-copy"></i>
                    </button>
                `;
                card.innerHTML = `
                    <div class="music-cover">
                        ${poster ? `<img loading="lazy" src="${poster}" alt="${name}" onerror="this.style.display='none'">` : `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.05)"><i class='fas fa-tv'></i></div>`}
                    </div>
                    <div class="music-info">
                        <div class="music-title">${name}</div>
                        <div class="music-actions" style="flex-wrap:wrap; gap:.4rem; margin-top:.4rem;">${btns}</div>
                    </div>
                `;
                grid.appendChild(card);
            });

            // Update displayed index
            xtreamState.displayedIndex = end;

            // wire buttons (only for newly added items)
            const newCards = Array.from(grid.children).slice(-itemsToRender.length);
            newCards.forEach(card => {
                card.querySelectorAll('[data-action="play"]').forEach(b => b.addEventListener('click', (e) => {
                    const url = e.currentTarget.getAttribute('data-url');
                    const name = e.currentTarget.getAttribute('data-name');
                    if (!url) { showNotification('No stream URL found', 'error'); return; }
                    showXtreamPlayer(name, url);
                }));
                card.querySelectorAll('[data-action="open"]').forEach(b => b.addEventListener('click', (e) => {
                    const url = e.currentTarget.getAttribute('data-url');
                    if (!url) { showNotification('No stream URL found', 'error'); return; }
                    if (window.electronAPI?.openExternal) window.electronAPI.openExternal(url); else window.open(url, '_blank');
                }));
                card.querySelectorAll('[data-action="copy"]').forEach(b => b.addEventListener('click', async (e) => {
                    const url = e.currentTarget.getAttribute('data-url');
                    try { await navigator.clipboard.writeText(url); showNotification('Stream URL copied', 'success'); } catch { showNotification('Copy failed', 'error'); }
                }));
                card.querySelectorAll('[data-action="series"]').forEach(b => b.addEventListener('click', (e) => {
                    const seriesId = e.currentTarget.getAttribute('data-id');
                    xtreamShowSeriesEpisodes(seriesId);
                }));
            });
        }

        async function xtreamShowSeriesEpisodes(seriesId) {
            try {
                const info = await xtreamFetch(`action=get_series_info&series_id=${encodeURIComponent(seriesId)}`);
                const episodesData = (info?.episodes) ? Object.values(info.episodes).flat() : [];
                if (!episodesData.length) { showNotification('No episodes found', 'info'); return; }
                
                // Group episodes by season
                const seasonMap = {};
                episodesData.forEach(ep => {
                    const season = ep.season || '1';
                    if (!seasonMap[season]) seasonMap[season] = [];
                    seasonMap[season].push(ep);
                });
                
                // Render season cards with collapsible episodes
                const grid = document.getElementById('xtream-grid');
                if (!grid) return;
                grid.innerHTML = '';
                
                const seasons = Object.keys(seasonMap).sort((a, b) => parseInt(a) - parseInt(b));
                
                seasons.forEach(seasonNum => {
                    const episodes = seasonMap[seasonNum];
                    const seasonCard = document.createElement('div');
                    seasonCard.className = 'music-card';
                    seasonCard.style.gridColumn = '1 / -1'; // Full width
                    seasonCard.style.cursor = 'pointer';
                    seasonCard.style.background = 'linear-gradient(135deg, rgba(59,130,246,0.1), rgba(37,99,235,0.05))';
                    seasonCard.style.border = '1px solid rgba(59,130,246,0.3)';
                    
                    const seasonId = `season-${seriesId}-${seasonNum}`;
                    seasonCard.innerHTML = `
                        <div style="padding:1rem;">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <h3 style="color:#fff; margin:0; font-size:1.1rem;">
                                    <i class="fas fa-tv" style="color:#3b82f6;"></i> Season ${seasonNum}
                                    <span style="color:#9ca3af; font-size:0.9rem; margin-left:0.5rem;">(${episodes.length} episodes)</span>
                                </h3>
                                <button class="season-toggle" data-season-id="${seasonId}" style="background:rgba(59,130,246,0.2); border:1px solid rgba(59,130,246,0.4); color:#3b82f6; padding:0.4rem 0.8rem; border-radius:6px; cursor:pointer;">
                                    <i class="fas fa-chevron-down"></i> Show Episodes
                                </button>
                            </div>
                            <div id="${seasonId}" style="display:none; margin-top:1rem;">
                                <div style="display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:0.75rem;"></div>
                            </div>
                        </div>
                    `;
                    grid.appendChild(seasonCard);
                    
                    // Add toggle functionality
                    const toggleBtn = seasonCard.querySelector('.season-toggle');
                    const episodesContainer = seasonCard.querySelector(`#${seasonId}`);
                    const episodesGrid = episodesContainer.querySelector('div');
                    
                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isHidden = episodesContainer.style.display === 'none';
                        
                        if (isHidden) {
                            // Render episodes if not already rendered
                            if (episodesGrid.children.length === 0) {
                                episodes.forEach(ep => {
                                    const name = `E${ep.episode_num} - ${ep.title || 'Episode'}`;
                                    const url = `${xtreamState.base}/series/${encodeURIComponent(xtreamState.username)}/${encodeURIComponent(xtreamState.password)}/${ep.id}.${(ep.container_extension || 'mp4').replace(/^\./,'')}`;
                                    
                                    const epCard = document.createElement('div');
                                    epCard.style.cssText = 'background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.1); border-radius:8px; padding:0.75rem; display:flex; flex-direction:column; gap:0.5rem;';
                                    epCard.innerHTML = `
                                        <div style="color:#fff; font-weight:600; font-size:0.9rem;">${name}</div>
                                        <div style="display:flex; gap:0.4rem; flex-wrap:wrap;">
                                            <button class="btn" style="padding:.3rem .6rem; border:none; border-radius:6px; background:linear-gradient(135deg,#10b981,#059669); color:#fff; cursor:pointer; font-size:0.85rem;" data-action="play" data-url="${url}" data-name="${name.replace(/"/g,'&quot;')}">
                                                <i class="fas fa-play"></i> Play
                                            </button>
                                            <button class="btn" style="padding:.3rem .6rem; border:none; border-radius:6px; background:linear-gradient(135deg,#3b82f6,#2563eb); color:#fff; cursor:pointer; font-size:0.85rem;" data-action="open" data-url="${url}">
                                                <i class="fas fa-external-link-alt"></i>
                                            </button>
                                            <button class="btn" style="padding:.3rem .6rem; border:none; border-radius:6px; background:rgba(255,255,255,.1); color:#fff; cursor:pointer; font-size:0.85rem;" data-action="copy" data-url="${url}">
                                                <i class="fas fa-copy"></i>
                                            </button>
                                        </div>
                                    `;
                                    episodesGrid.appendChild(epCard);
                                });
                                
                                // Wire episode buttons
                                episodesGrid.querySelectorAll('[data-action="play"]').forEach(b => b.addEventListener('click', (e) => {
                                    const url = e.currentTarget.getAttribute('data-url');
                                    const name = e.currentTarget.getAttribute('data-name');
                                    if (!url) { showNotification('No stream URL found', 'error'); return; }
                                    showXtreamPlayer(name, url);
                                }));
                                episodesGrid.querySelectorAll('[data-action="open"]').forEach(b => b.addEventListener('click', (e) => {
                                    const url = e.currentTarget.getAttribute('data-url');
                                    if (!url) { showNotification('No stream URL found', 'error'); return; }
                                    if (window.electronAPI?.openExternal) window.electronAPI.openExternal(url); else window.open(url, '_blank');
                                }));
                                episodesGrid.querySelectorAll('[data-action="copy"]').forEach(b => b.addEventListener('click', async (e) => {
                                    const url = e.currentTarget.getAttribute('data-url');
                                    try { await navigator.clipboard.writeText(url); showNotification('Stream URL copied', 'success'); } catch { showNotification('Copy failed', 'error'); }
                                }));
                            }
                            episodesContainer.style.display = '';
                            toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i> Hide Episodes';
                        } else {
                            episodesContainer.style.display = 'none';
                            toggleBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Show Episodes';
                        }
                    });
                });
                
            } catch (e) {
                console.error('[XTREAM] Series info error:', e);
                showNotification('Failed to load episodes: ' + (e?.message || 'Unknown'), 'error');
            }
        }

        async function xtreamRenderCurrentTab() {
            xtreamPopulateCategories();
            const select = document.getElementById('xtream-category-select');
            const catId = select ? select.value : '';
            const empty = document.getElementById('xtream-empty');
            if (empty) { empty.style.display = ''; empty.textContent = 'Loading...'; }
            await xtreamLoadStreamsForCurrentTab(catId);
            xtreamRenderGrid();
        }

        function bindXtreamUi() {
            const openBtn = document.getElementById('iptv-custom-btn');
            if (openBtn) openBtn.addEventListener('click', iptvActionButtonClick);

            const closeLogin = document.getElementById('xtream-login-close');
            const cancelLogin = document.getElementById('xtream-login-cancel');
            const submitLogin = document.getElementById('xtream-login-submit');
            if (closeLogin) closeLogin.addEventListener('click', hideXtreamLoginModal);
            if (cancelLogin) cancelLogin.addEventListener('click', hideXtreamLoginModal);
            if (submitLogin) submitLogin.addEventListener('click', xtreamLogin);

            // Setup infinite scroll for content
            const contentContainer = document.getElementById('xtream-inline-content');
            if (contentContainer) {
                contentContainer.addEventListener('scroll', () => {
                    const { scrollTop, scrollHeight, clientHeight } = contentContainer;
                    // Load more when user scrolls to bottom (with 200px threshold)
                    if (scrollTop + clientHeight >= scrollHeight - 200) {
                        const search = (document.getElementById('xtream-search')?.value || '').toLowerCase().trim();
                        let items = xtreamState.lastStreams || [];
                        if (search) {
                            items = items.filter(it => ((it.name || it.title || '').toLowerCase().includes(search)));
                        }
                        // Only load more if there are more items to show
                        if (xtreamState.displayedIndex < items.length) {
                            xtreamRenderGrid(true); // append mode
                        }
                    }
                });
            }

            // No inline close button; switching is handled by the header action button

            const catSel = document.getElementById('xtream-category-select');
            if (catSel) catSel.addEventListener('change', () => xtreamRenderCurrentTab());

            const search = document.getElementById('xtream-search');
            if (search) search.addEventListener('input', () => {
                // Reset pagination on search
                xtreamState.displayedIndex = 0;
                xtreamRenderGrid(false);
            });

            // Tab buttons
            document.querySelectorAll('.xtream-tab-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    document.querySelectorAll('.xtream-tab-btn').forEach(b => { b.style.background = 'transparent'; b.style.color = '#ddd'; });
                    const b = e.currentTarget; b.style.background = '#1b1b1b'; b.style.color = '#fff';
                    const nextTab = b.getAttribute('data-tab');
                    if (xtreamState.mode === 'm3u' && nextTab !== 'live') {
                        showNotification('This playlist only supports Live channels', 'info');
                        // re-highlight Live
                        const liveBtn = document.querySelector('.xtream-tab-btn[data-tab="live"]');
                        if (liveBtn) { liveBtn.style.background = '#1b1b1b'; liveBtn.style.color = '#fff'; }
                        xtreamState.tab = 'live';
                        return;
                    }
                    xtreamState.tab = nextTab;
                    await xtreamRenderCurrentTab();
                });
            });

            // Player controls
            const closePlayer = document.getElementById('xtream-player-close');
            if (closePlayer) closePlayer.addEventListener('click', hideXtreamPlayer);
            const modalOuter = document.getElementById('xtream-player-modal');
            if (modalOuter) modalOuter.addEventListener('click', (e) => { if (e.target === modalOuter) hideXtreamPlayer(); });

            // M3U submit
            const m3uBtn = document.getElementById('xtream-m3u-submit');
            const m3uInput = document.getElementById('xtream-m3u-url');
            if (m3uBtn) m3uBtn.addEventListener('click', async () => {
                const url = (m3uInput?.value || '').trim();
                if (!url) { showNotification('Please enter a playlist URL', 'warning'); return; }
                const status = document.getElementById('xtream-login-status');
                if (status) status.textContent = '';
                if (isDirectMediaUrl(url)) {
                    // Treat as single stream
                    try { clearIptvPage(); disableIptvIframe(); } catch(_) {}
                    hideXtreamLoginModal();
                    xtreamState.active = true; xtreamState.mode = 'direct';
                    updateIptvActionButton();
                    showXtreamPlayer('Custom Stream', url);
                } else {
                    await loadM3UFromUrl(url);
                }
            });
            if (m3uInput) m3uInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const url = (m3uInput?.value || '').trim();
                    if (!url) { showNotification('Please enter a playlist URL', 'warning'); return; }
                    if (isDirectMediaUrl(url)) {
                        try { clearIptvPage(); disableIptvIframe(); } catch(_) {}
                        hideXtreamLoginModal();
                        xtreamState.active = true; xtreamState.mode = 'direct';
                        updateIptvActionButton();
                        showXtreamPlayer('Custom Stream', url);
                    } else {
                        await loadM3UFromUrl(url);
                    }
                }
            });

            // Recommended M3U presets
            const presetButtons = document.querySelectorAll('#xtream-m3u-recommended .m3u-preset');
            presetButtons.forEach(btn => btn.addEventListener('click', async () => {
                const url = btn.getAttribute('data-url');
                const input = document.getElementById('xtream-m3u-url');
                if (input) input.value = url;
                if (url) {
                    await loadM3UFromUrl(url);
                }
            }));
        }

        // TorBox supported hosts list (based on TorBox documentation)
        const TORBOX_SUPPORTED_HOSTS = [
            'buzzheavier.com', 'bzzhr.co', 'bzz.lol',  // BuzzHeavier and mirrors
            'gofile.io',
            '1fichier.com',
            'mediafire.com',
            'pixeldrain.com',
            'dropbox.com',
            'mega.nz', 'mega.co.nz',
            'rapidgator.net',
            'uploaded.net', 'ul.to',
            'turbobit.net',
            'nitroflare.com',
            'katfile.com',
            'filefactory.com',
            'ddownload.com',
            'filestore.me'
        ];
        
        function isTorBoxSupported(url) {
            try {
                const hostname = new URL(url).hostname.toLowerCase();
                return TORBOX_SUPPORTED_HOSTS.some(h => hostname.includes(h));
            } catch {
                return false;
            }
        }

        // Games Downloader page functions
        function showGamesDownloaderPage() {
            window.location.hash = '#/games-downloader';
        }

        async function loadGameCategories() {
            try {
                console.log('[GAMES] Loading categories...');
                const categorySelect = document.getElementById('games-category-select');
                
                if (!categorySelect) {
                    console.error('[GAMES] Category select element not found');
                    return;
                }

                // Hardcoded categories list
                const categories = [
                    "Action",
                    "Adventure",
                    "Anime",
                    "Building",
                    "First-person Shooter Games",
                    "Horror",
                    "Indie",
                    "Multiplayer",
                    "Nudity",
                    "Open World",
                    "Racing",
                    "Role-playing game",
                    "Sci-fi",
                    "Shooters",
                    "Simulation",
                    "Sports",
                    "Strategy",
                    "Survival",
                    "Uncategorized",
                    "Virtual Reality"
                ];

                // Populate dropdown
                categorySelect.innerHTML = '<option value="" style="background: var(--bg-secondary); color: var(--secondary); padding: 0.5rem; font-weight: 500;">Select a category...</option>';
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    option.style.cssText = 'background: var(--card-bg); color: var(--light); padding: 0.5rem; font-weight: 500;';
                    categorySelect.appendChild(option);
                });
                
                console.log('[GAMES] Categories populated in dropdown:', categories.length);
            } catch (error) {
                console.error('[GAMES] Failed to load categories:', error);
            }
        }

        async function browseByCategory(category) {
            const statusEl = document.getElementById('games-search-status');
            const resultsSection = document.getElementById('games-results-section');
            const emptyState = document.getElementById('games-empty-state');
            const resultsGrid = document.getElementById('games-results-grid');
            const resultsCount = document.getElementById('games-results-count');

            try {
                statusEl.textContent = `Loading ${category} games...`;
                statusEl.style.color = '#8b5cf6';
                emptyState.style.display = 'none';

                const response = await fetch(`http://localhost:6987/api/games/category/${encodeURIComponent(category)}`);
                if (!response.ok) throw new Error('Failed to load category');

                const data = await response.json();
                
                if (!data.games || data.games.length === 0) {
                    statusEl.textContent = `No games found in ${category}`;
                    statusEl.style.color = '#ef4444';
                    emptyState.style.display = '';
                    return;
                }

                // Store games and display first 20
                window.allGames = data.games;
                window.currentGameIndex = 0;
                window.gamesPerLoad = 20;
                
                resultsGrid.innerHTML = '';
                resultsSection.style.display = '';
                loadMoreGames();

            } catch (error) {
                console.error('Browse by category error:', error);
                statusEl.style.color = '#ef4444';
                emptyState.style.display = '';
            }
        }

        async function searchGames(query) {
            const statusEl = document.getElementById('games-search-status');
            const resultsSection = document.getElementById('games-results-section');
            const emptyState = document.getElementById('games-empty-state');
            const resultsGrid = document.getElementById('games-results-grid');
            const resultsCount = document.getElementById('games-results-count');

            if (!query || !query.trim()) {
                statusEl.textContent = 'Please enter a game name';
                statusEl.style.color = '#ef4444';
                return;
            }

            try {
                statusEl.textContent = 'Searching...';
                statusEl.style.color = '#8b5cf6';
                resultsSection.style.display = 'none';
                emptyState.style.display = 'none';

                const response = await fetch(`http://localhost:6987/api/games/search/${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();
                
                if (!data.games || data.games.length === 0) {
                    statusEl.textContent = 'No games found';
                    statusEl.style.color = '#ef4444';
                    emptyState.style.display = '';
                    return;
                }

                // Display results
                statusEl.textContent = `Found ${data.count} game${data.count !== 1 ? 's' : ''}`;
                statusEl.style.color = '#10b981';
                resultsCount.textContent = `${data.count} game${data.count !== 1 ? 's' : ''}`;
                
                resultsGrid.innerHTML = '';
                data.games.forEach(game => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.style.cursor = 'default';
                    
                    // Get image URL and game title for library
                    const imageUrl = game.imgID 
                        ? `http://localhost:6987/api/games/image/${game.imgID}`
                        : 'https://via.placeholder.com/300x400?text=No+Image';
                    const gameTitle = game.game || game.name || 'Unknown Game';
                    const gameSize = game.size || '';
                    
                    // Handle new API structure - download_links is an object with arrays
                    let downloadLinksHtml = '';
                    if (game.download_links && typeof game.download_links === 'object') {
                        const links = [];
                        
                        // Iterate through all link types (1fichier, buzzheavier, megadb, etc.)
                        Object.keys(game.download_links).forEach(linkType => {
                            const urls = game.download_links[linkType];
                            if (Array.isArray(urls)) {
                                urls.forEach((url, index) => {
                                    // Add protocol if missing
                                    const fullUrl = url.startsWith('//') ? 'https:' + url : url;
                                    const displayName = linkType.charAt(0).toUpperCase() + linkType.slice(1) + (urls.length > 1 ? ` ${index + 1}` : '');
                                    links.push({name: displayName, url: fullUrl, provider: linkType});
                                });
                            } else if (typeof urls === 'string') {
                                const fullUrl = urls.startsWith('//') ? 'https:' + urls : urls;
                                const displayName = linkType.charAt(0).toUpperCase() + linkType.slice(1);
                                links.push({name: displayName, url: fullUrl, provider: linkType});
                            }
                        });
                        
                        if (links.length > 0) {
                            downloadLinksHtml = links.map(link => {
                                const torboxSupported = isTorBoxSupported(link.url);
                                const bgColor = torboxSupported ? 'linear-gradient(135deg, #10b981, #059669)' : 'linear-gradient(135deg, #6b7280, #4b5563)';
                                const torboxIcon = torboxSupported ? '<i class="fas fa-bolt" style="color:#fbbf24;margin-right:2px;" title="TorBox Supported"></i>' : '<i class="fas fa-external-link-alt" style="margin-right:2px;" title="Opens in Browser"></i>';
                                const tooltip = torboxSupported ? 'TorBox supported - Click to download in-app' : 'Opens in browser (not supported by TorBox)';
                                return `
                                <button class="game-download-link" data-url="${link.url}" data-name="${gameTitle.replace(/"/g, '&quot;')}" data-image="${imageUrl}" data-size="${gameSize}" data-provider="${link.provider}" data-torbox="${torboxSupported}" style="padding: 0.4rem 0.8rem; background: ${bgColor}; border: none; border-radius: 6px; color: white; font-size: 0.85rem; cursor: pointer; margin: 0.2rem; transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" title="${tooltip}">
                                    ${torboxIcon} ${link.name}
                                </button>
                            `;
                            }).join('');
                        }
                    }
                    
                    if (!downloadLinksHtml) {
                        downloadLinksHtml = '<span style="color: var(--secondary); font-size: 0.85rem;">No download links available</span>';
                    }
                    
                    // Format categories
                    const categories = Array.isArray(game.category) 
                        ? game.category.join(', ')
                        : (game.category || 'N/A');

                    card.innerHTML = `
                        <div class="music-cover">
                            <img loading="lazy" src="${imageUrl}" alt="${gameTitle}" onerror="this.src='https://via.placeholder.com/300x400?text=No+Image'">
                        </div>
                        <div class="music-info">
                            <div class="music-title">${gameTitle}</div>
                            <div class="music-artist" style="color: #8b5cf6;">${categories}</div>
                            ${game.size ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.3rem 0;"><i class="fas fa-hdd"></i> Size: ${game.size}</div>` : ''}
                            ${game.version ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.3rem 0;"><i class="fas fa-tag"></i> Version: ${game.version}</div>` : ''}
                            ${game.description ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.5rem 0; line-height: 1.4;">${game.description.substring(0, 150)}${game.description.length > 150 ? '...' : ''}</div>` : ''}
                            <div class="music-actions" style="flex-wrap: wrap; margin-top: 0.5rem;">
                                ${downloadLinksHtml}
                            </div>
                        </div>
                    `;
                    resultsGrid.appendChild(card);
                });

                // Add click handlers to download links - left click adds to library, right click opens in browser
                resultsGrid.querySelectorAll('.game-download-link').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        const url = e.currentTarget.getAttribute('data-url');
                        const name = e.currentTarget.getAttribute('data-name');
                        const image = e.currentTarget.getAttribute('data-image');
                        const size = e.currentTarget.getAttribute('data-size');
                        const provider = e.currentTarget.getAttribute('data-provider');
                        if (url) {
                            addGameToLibrary(url, name, image, size, provider);
                        }
                    });
                    btn.addEventListener('contextmenu', async (e) => {
                        e.preventDefault();
                        const url = e.currentTarget.getAttribute('data-url');
                        if (url && window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                            showNotification('Opening in browser...', 'info');
                        }
                    });
                });

                resultsSection.style.display = '';
                emptyState.style.display = 'none';

            } catch (error) {
                console.error('Games search error:', error);
                statusEl.textContent = 'Search failed. Please try again.';
                statusEl.style.color = '#ef4444';
                emptyState.style.display = '';
            }
        }

        async function browseAllGames() {
            const statusEl = document.getElementById('games-search-status');
            const resultsSection = document.getElementById('games-results-section');
            const emptyState = document.getElementById('games-empty-state');
            const resultsGrid = document.getElementById('games-results-grid');
            const resultsCount = document.getElementById('games-results-count');

            try {
                statusEl.textContent = 'Loading games...';
                statusEl.style.color = '#8b5cf6';
                emptyState.style.display = 'none';

                const response = await fetch('http://localhost:6987/api/games/all');
                if (!response.ok) throw new Error('Failed to load games');

                const data = await response.json();
                
                if (!data.games || data.games.length === 0) {
                    statusEl.textContent = 'No games available';
                    statusEl.style.color = '#ef4444';
                    emptyState.style.display = '';
                    return;
                }

                // Store all games globally and display first 20
                window.allGames = data.games;
                window.currentGameIndex = 0;
                window.gamesPerLoad = 20;
                
                resultsGrid.innerHTML = '';
                resultsSection.style.display = '';
                loadMoreGames();

            } catch (error) {
                console.error('Browse all games error:', error);
                
                statusEl.style.color = '#ef4444';
                emptyState.style.display = '';
            }
        }

        function loadMoreGames() {
            const statusEl = document.getElementById('games-search-status');
            const resultsSection = document.getElementById('games-results-section');
            const resultsGrid = document.getElementById('games-results-grid');
            const resultsCount = document.getElementById('games-results-count');

            if (!window.allGames || window.allGames.length === 0) return;

            const startIndex = window.currentGameIndex;
            const endIndex = Math.min(startIndex + window.gamesPerLoad, window.allGames.length);
            const gamesToLoad = window.allGames.slice(startIndex, endIndex);

            // Display status
            statusEl.textContent = `Showing ${endIndex} of ${window.allGames.length} games`;
            statusEl.style.color = '#10b981';
            resultsCount.textContent = `${endIndex} / ${window.allGames.length} games`;

            gamesToLoad.forEach(game => {
                const card = document.createElement('div');
                card.className = 'music-card';
                card.style.cursor = 'default';
                
                // Get image URL and game title for library
                const imageUrl = game.imgID 
                    ? `http://localhost:6987/api/games/image/${game.imgID}`
                    : 'https://via.placeholder.com/300x400?text=No+Image';
                const gameTitle = game.game || game.name || 'Unknown Game';
                const gameSize = game.size || '';
                
                // Handle new API structure - download_links is an object with arrays
                let downloadLinksHtml = '';
                if (game.download_links && typeof game.download_links === 'object') {
                    const links = [];
                    
                    // Iterate through all link types (1fichier, buzzheavier, megadb, etc.)
                    Object.keys(game.download_links).forEach(linkType => {
                        const urls = game.download_links[linkType];
                        if (Array.isArray(urls)) {
                            urls.forEach((url, index) => {
                                // Add protocol if missing
                                const fullUrl = url.startsWith('//') ? 'https:' + url : url;
                                const displayName = linkType.charAt(0).toUpperCase() + linkType.slice(1) + (urls.length > 1 ? ` ${index + 1}` : '');
                                links.push({name: displayName, url: fullUrl, provider: linkType});
                            });
                        } else if (typeof urls === 'string') {
                            const fullUrl = urls.startsWith('//') ? 'https:' + urls : urls;
                            const displayName = linkType.charAt(0).toUpperCase() + linkType.slice(1);
                            links.push({name: displayName, url: fullUrl, provider: linkType});
                        }
                    });
                    
                    if (links.length > 0) {
                        downloadLinksHtml = links.map(link => {
                            const torboxSupported = isTorBoxSupported(link.url);
                            const bgColor = torboxSupported ? 'linear-gradient(135deg, #10b981, #059669)' : 'linear-gradient(135deg, #6b7280, #4b5563)';
                            const torboxIcon = torboxSupported ? '<i class="fas fa-bolt" style="color:#fbbf24;margin-right:2px;" title="TorBox Supported"></i>' : '<i class="fas fa-external-link-alt" style="margin-right:2px;" title="Opens in Browser"></i>';
                            const tooltip = torboxSupported ? 'TorBox supported - Click to download in-app' : 'Opens in browser (not supported by TorBox)';
                            return `
                            <button class="game-download-link" data-url="${link.url}" data-name="${gameTitle.replace(/"/g, '&quot;')}" data-image="${imageUrl}" data-size="${gameSize}" data-provider="${link.provider}" data-torbox="${torboxSupported}" style="padding: 0.4rem 0.8rem; background: ${bgColor}; border: none; border-radius: 6px; color: white; font-size: 0.85rem; cursor: pointer; margin: 0.2rem; transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" title="${tooltip}">
                                ${torboxIcon} ${link.name}
                            </button>
                        `;
                        }).join('');
                    }
                }
                
                if (!downloadLinksHtml) {
                    downloadLinksHtml = '<span style="color: var(--secondary); font-size: 0.85rem;">No download links available</span>';
                }
                
                // Format categories
                const categories = Array.isArray(game.category) 
                    ? game.category.join(', ')
                    : (game.category || 'N/A');

                card.innerHTML = `
                    <div class="music-cover">
                        <img loading="lazy" src="${imageUrl}" alt="${gameTitle}" onerror="this.onerror=null; this.src='https://via.placeholder.com/300x400?text=${encodeURIComponent(gameTitle)}'">
                    </div>
                    <div class="music-info">
                        <div class="music-title">${gameTitle}</div>
                        <div class="music-artist" style="color: #8b5cf6;">${categories}</div>
                        ${game.size ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.3rem 0;"><i class="fas fa-hdd"></i> Size: ${game.size}</div>` : ''}
                        ${game.version ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.3rem 0;"><i class="fas fa-tag"></i> Version: ${game.version}</div>` : ''}
                        ${game.description ? `<div style="color: var(--secondary); font-size: 0.85rem; margin: 0.5rem 0; line-height: 1.4;">${game.description.substring(0, 150)}${game.description.length > 150 ? '...' : ''}</div>` : ''}
                        <div class="music-actions" style="flex-wrap: wrap; margin-top: 0.5rem;">
                            ${downloadLinksHtml}
                        </div>
                    </div>
                `;
                resultsGrid.appendChild(card);
            });

            // Add click handlers to download links - left click adds to library, right click opens in browser
            resultsGrid.querySelectorAll('.game-download-link').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const url = e.currentTarget.getAttribute('data-url');
                    const name = e.currentTarget.getAttribute('data-name');
                    const image = e.currentTarget.getAttribute('data-image');
                    const size = e.currentTarget.getAttribute('data-size');
                    const provider = e.currentTarget.getAttribute('data-provider');
                    if (url) {
                        addGameToLibrary(url, name, image, size, provider);
                    }
                });
                btn.addEventListener('contextmenu', async (e) => {
                    e.preventDefault();
                    const url = e.currentTarget.getAttribute('data-url');
                    if (url && window.electronAPI?.openExternal) {
                        await window.electronAPI.openExternal(url);
                        showNotification('Opening in browser...', 'info');
                    }
                });
            });

            window.currentGameIndex = endIndex;

            // Show/hide Load More button
            let loadMoreBtn = document.getElementById('games-load-more-btn');
            if (!loadMoreBtn) {
                loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'games-load-more-btn';
                loadMoreBtn.innerHTML = '<i class="fas fa-arrow-down"></i> Load More Games';
                loadMoreBtn.style.cssText = 'display: block; margin: 2rem auto; padding: 0.75rem 2rem; background: linear-gradient(135deg, #f97316, #ea580c); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); font-size: 1rem;';
                loadMoreBtn.onmouseover = () => loadMoreBtn.style.transform = 'scale(1.05)';
                loadMoreBtn.onmouseout = () => loadMoreBtn.style.transform = 'scale(1)';
                loadMoreBtn.onclick = loadMoreGames;
                resultsGrid.parentElement.appendChild(loadMoreBtn);
            }

            if (window.currentGameIndex >= window.allGames.length) {
                loadMoreBtn.style.display = 'none';
            } else {
                loadMoreBtn.style.display = 'block';
            }

            resultsSection.style.display = '';
            emptyState.style.display = 'none';
        }

        // Initialize Games Downloader search + bind Xtream UI
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Enable performance mode by default (can be toggled later if needed)
                const pref = localStorage.getItem('perfMode');
                const enabled = pref == null ? true : (pref === 'true');
                if (enabled) document.body.classList.add('perf-mode');
            } catch(_) {}
            
            // Sidebar toggle functionality
            const sidebar = document.getElementById('appSidebar');
            const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
            const sidebarToggleBtn = document.getElementById('sidebarToggleBtn');
            
            // Load sidebar state from localStorage
            const sidebarHidden = localStorage.getItem('sidebarHidden') === 'true';
            if (sidebarHidden && sidebar) {
                sidebar.classList.add('sidebar-hidden');
            }
            
            // Close button handler
            if (sidebarCloseBtn && sidebar) {
                sidebarCloseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    sidebar.classList.add('sidebar-hidden');
                    localStorage.setItem('sidebarHidden', 'true');
                });
            }
            
            // Toggle button handler
            if (sidebarToggleBtn && sidebar) {
                sidebarToggleBtn.addEventListener('click', () => {
                    sidebar.classList.remove('sidebar-hidden');
                    localStorage.setItem('sidebarHidden', 'false');
                });
            }
            
            const searchInput = document.getElementById('games-search-input');
            const searchBtn = document.getElementById('games-search-btn');
            const browseAllBtn = document.getElementById('games-browse-all-btn');
            const categorySelect = document.getElementById('games-category-select');
            const categoryBtn = document.getElementById('games-category-btn');

            if (searchInput && searchBtn) {
                searchBtn.addEventListener('click', () => {
                    searchGames(searchInput.value);
                });

                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchGames(searchInput.value);
                    }
                });
            }

            if (browseAllBtn) {
                browseAllBtn.addEventListener('click', () => {
                    browseAllGames();
                });
            }

            if (categorySelect && categoryBtn) {
                categoryBtn.addEventListener('click', () => {
                    const selectedCategory = categorySelect.value;
                    if (selectedCategory) {
                        browseByCategory(selectedCategory);
                    }
                });

                // Also trigger on dropdown change
                categorySelect.addEventListener('change', (e) => {
                    const selectedCategory = e.target.value;
                    if (selectedCategory) {
                        browseByCategory(selectedCategory);
                    }
                });
            }

            // Initialize Games Library
            initGamesLibrary();

            // Bind Xtream UI after DOM ready and set initial button label, then auto-restore last used mode
            try { bindXtreamUi(); updateIptvActionButton(); } catch (e) { console.warn('[XTREAM] bind failed', e); }
            iptvAutoRestore();
        });

        // ============================================================================
        // GAMES LIBRARY FUNCTIONALITY
        // ============================================================================
        
        let gamesLibraryRefreshInterval = null;
        
        function initGamesLibrary() {
            const browseTab = document.getElementById('games-browse-tab');
            const libraryTab = document.getElementById('games-library-tab');
            const browseSection = document.getElementById('games-browse-section');
            const librarySection = document.getElementById('games-library-section');
            const openFolderBtn = document.getElementById('games-open-folder-btn');
            const refreshLibraryBtn = document.getElementById('games-refresh-library-btn');
            
            if (browseTab && libraryTab) {
                browseTab.addEventListener('click', () => {
                    browseTab.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
                    browseTab.style.border = 'none';
                    browseTab.style.color = 'white';
                    libraryTab.style.background = 'rgba(139,92,246,0.2)';
                    libraryTab.style.border = '2px solid rgba(139,92,246,0.3)';
                    libraryTab.style.color = '#a78bfa';
                    browseSection.style.display = 'block';
                    librarySection.style.display = 'none';
                    stopLibraryRefresh();
                });
                
                libraryTab.addEventListener('click', () => {
                    libraryTab.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
                    libraryTab.style.border = 'none';
                    libraryTab.style.color = 'white';
                    browseTab.style.background = 'rgba(139,92,246,0.2)';
                    browseTab.style.border = '2px solid rgba(139,92,246,0.3)';
                    browseTab.style.color = '#a78bfa';
                    browseSection.style.display = 'none';
                    librarySection.style.display = 'block';
                    loadGamesLibrary();
                    startLibraryRefresh();
                });
            }
            
            if (openFolderBtn) {
                openFolderBtn.addEventListener('click', async () => {
                    try {
                        const resp = await fetch('/api/game-downloads/open-folder');
                        const data = await resp.json();
                        if (data.folder && window.electronAPI?.openPath) {
                            await window.electronAPI.openPath(data.folder);
                        } else if (data.folder && window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal('file://' + data.folder);
                        }
                    } catch (e) {
                        showNotification('Could not open folder', 'error');
                    }
                });
            }
            
            if (refreshLibraryBtn) {
                refreshLibraryBtn.addEventListener('click', () => loadGamesLibrary());
            }
            
            // Check TorBox status
            checkTorBoxStatus();
        }
        
        function startLibraryRefresh() {
            stopLibraryRefresh();
            gamesLibraryRefreshInterval = setInterval(() => loadGamesLibrary(true), 2000);
        }
        
        function stopLibraryRefresh() {
            if (gamesLibraryRefreshInterval) {
                clearInterval(gamesLibraryRefreshInterval);
                gamesLibraryRefreshInterval = null;
            }
        }
        
        async function checkTorBoxStatus() {
            try {
                const resp = await fetch('/api/game-downloads/torbox-status');
                const data = await resp.json();
                const statusEl = document.getElementById('games-torbox-status');
                if (statusEl) {
                    if (data.hasTorBox) {
                        statusEl.style.display = 'block';
                        statusEl.style.background = 'rgba(16,185,129,0.1)';
                        statusEl.style.border = '1px solid rgba(16,185,129,0.3)';
                        statusEl.innerHTML = '<i class="fas fa-bolt" style="color:#10b981"></i> <span style="color:#10b981">TorBox Premium enabled</span> - Downloads will use TorBox for faster speeds';
                    } else {
                        statusEl.style.display = 'block';
                        statusEl.style.background = 'rgba(251,191,36,0.1)';
                        statusEl.style.border = '1px solid rgba(251,191,36,0.3)';
                        statusEl.innerHTML = '<i class="fas fa-info-circle" style="color:#fbbf24"></i> <span style="color:#fbbf24">Direct download mode</span> - <a href="#" onclick="showSection(\'settings\');return false;" style="color:#8b5cf6">Login to TorBox</a> for faster downloads';
                    }
                }
            } catch (e) {}
        }
        
        async function loadGamesLibrary(silent = false) {
            const grid = document.getElementById('games-library-grid');
            const emptyState = document.getElementById('games-library-empty');
            const countBadge = document.getElementById('games-library-count');
            
            try {
                const resp = await fetch('/api/game-downloads/library');
                const data = await resp.json();
                
                if (!data.downloads || data.downloads.length === 0) {
                    grid.innerHTML = '';
                    emptyState.style.display = 'block';
                    // Reset count badge to 0 and hide
                    countBadge.textContent = '0';
                    countBadge.style.display = 'none';
                    return;
                }
                
                emptyState.style.display = 'none';
                
                // Update count badge - count active downloads from actual data
                const activeCount = data.downloads.filter(d => d.status === 'downloading' || d.status === 'pending').length;
                countBadge.textContent = activeCount;
                if (activeCount > 0) {
                    countBadge.style.display = 'inline';
                } else {
                    countBadge.style.display = 'none';
                }
                
                // Render downloads
                grid.innerHTML = data.downloads.map(dl => renderDownloadCard(dl)).join('');
                
                // Attach event handlers
                grid.querySelectorAll('.game-dl-pause').forEach(btn => {
                    btn.addEventListener('click', () => pauseGameDownload(btn.dataset.id));
                });
                grid.querySelectorAll('.game-dl-resume').forEach(btn => {
                    btn.addEventListener('click', () => resumeGameDownload(btn.dataset.id));
                });
                grid.querySelectorAll('.game-dl-remove').forEach(btn => {
                    btn.addEventListener('click', () => removeGameDownload(btn.dataset.id));
                });
                grid.querySelectorAll('.game-dl-folder').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const filePath = btn.dataset.path;
                        if (filePath && window.electronAPI?.showFolderInExplorer) {
                            // Get the folder path from the file path
                            const folderPath = filePath.substring(0, filePath.lastIndexOf(filePath.includes('/') ? '/' : '\\'));
                            await window.electronAPI.showFolderInExplorer(folderPath);
                        }
                    });
                });
                
            } catch (e) {
                if (!silent) showNotification('Failed to load library', 'error');
            }
        }
        
        function renderDownloadCard(dl) {
            const statusColors = {
                'pending': '#fbbf24',
                'downloading': '#3b82f6',
                'paused': '#f97316',
                'completed': '#10b981',
                'error': '#ef4444'
            };
            const statusIcons = {
                'pending': 'fa-clock',
                'downloading': 'fa-download',
                'paused': 'fa-pause',
                'completed': 'fa-check-circle',
                'error': 'fa-exclamation-circle'
            };
            
            const color = statusColors[dl.status] || '#6b7280';
            const icon = statusIcons[dl.status] || 'fa-question';
            const speed = dl.speed > 0 ? formatSpeed(dl.speed) : '';
            const size = dl.totalBytes > 0 ? formatBytes(dl.totalBytes) : (dl.gameSize || 'Unknown size');
            const downloaded = dl.downloadedBytes > 0 ? formatBytes(dl.downloadedBytes) : '0 B';
            
            let actions = '';
            if (dl.status === 'downloading') {
                actions = `<button class="game-dl-pause" data-id="${dl.id}" style="padding:0.4rem 0.8rem;background:#f97316;border:none;border-radius:6px;color:white;cursor:pointer;font-size:0.85rem;"><i class="fas fa-pause"></i> Pause</button>`;
            } else if (dl.status === 'paused' || dl.status === 'error') {
                actions = `<button class="game-dl-resume" data-id="${dl.id}" style="padding:0.4rem 0.8rem;background:#10b981;border:none;border-radius:6px;color:white;cursor:pointer;font-size:0.85rem;"><i class="fas fa-play"></i> Resume</button>`;
            }
            // Add folder icon to open file location (only if file exists)
            if (dl.filePath) {
                actions += `<button class="game-dl-folder" data-path="${dl.filePath}" style="padding:0.4rem 0.8rem;background:#3b82f6;border:none;border-radius:6px;color:white;cursor:pointer;font-size:0.85rem;margin-left:0.5rem;" title="Open file location"><i class="fas fa-folder-open"></i></button>`;
            }
            actions += `<button class="game-dl-remove" data-id="${dl.id}" style="padding:0.4rem 0.8rem;background:#ef4444;border:none;border-radius:6px;color:white;cursor:pointer;font-size:0.85rem;margin-left:0.5rem;"><i class="fas fa-trash"></i></button>`;
            
            return `
                <div style="background:rgba(20,20,31,0.8);border:1px solid rgba(139,92,246,0.2);border-radius:12px;padding:1rem;display:flex;gap:1rem;align-items:center;">
                    <div style="width:80px;height:80px;border-radius:8px;overflow:hidden;flex-shrink:0;background:#1a1a2e;">
                        ${dl.gameImage ? `<img src="${dl.gameImage}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none'">` : '<i class="fas fa-gamepad" style="font-size:2rem;color:#8b5cf6;display:flex;align-items:center;justify-content:center;height:100%;"></i>'}
                    </div>
                    <div style="flex:1;min-width:0;">
                        <div style="font-weight:600;color:var(--light);margin-bottom:0.3rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${dl.gameName}</div>
                        <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.5rem;">
                            <i class="fas ${icon}" style="color:${color}"></i>
                            <span style="color:${color};font-size:0.85rem;text-transform:capitalize;">${dl.status}</span>
                            ${speed ? `<span style="color:var(--secondary);font-size:0.8rem;"> ${speed}</span>` : ''}
                            ${dl.useTorBox ? '<span style="color:#10b981;font-size:0.75rem;background:rgba(16,185,129,0.2);padding:0.1rem 0.4rem;border-radius:4px;">TorBox</span>' : ''}
                        </div>
                        <div style="background:rgba(139,92,246,0.2);border-radius:4px;height:6px;overflow:hidden;margin-bottom:0.5rem;">
                            <div style="background:linear-gradient(90deg,#8b5cf6,#7c3aed);height:100%;width:${dl.progress}%;transition:width 0.3s;"></div>
                        </div>
                        <div style="display:flex;justify-content:space-between;font-size:0.8rem;color:var(--secondary);">
                            <span>${downloaded} / ${size}</span>
                            <span>${dl.progress}%</span>
                        </div>
                        <div style="margin-top:0.5rem;">${actions}</div>
                        ${dl.error ? `<div style="color:#ef4444;font-size:0.8rem;margin-top:0.3rem;">${dl.error}</div>` : ''}
                    </div>
                </div>
            `;
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function formatSpeed(bytesPerSec) {
            return formatBytes(bytesPerSec) + '/s';
        }
        
        async function pauseGameDownload(id) {
            try {
                await fetch(`/api/game-downloads/pause/${id}`, { method: 'POST' });
                loadGamesLibrary();
            } catch (e) {
                showNotification('Failed to pause download', 'error');
            }
        }
        
        async function resumeGameDownload(id) {
            try {
                await fetch(`/api/game-downloads/resume/${id}`, { method: 'POST' });
                loadGamesLibrary();
            } catch (e) {
                showNotification('Failed to resume download', 'error');
            }
        }
        
        async function removeGameDownload(id) {
            if (!confirm('Remove this download? The file will also be deleted.')) return;
            try {
                // First, immediately remove from UI to give instant feedback
                const grid = document.getElementById('games-library-grid');
                const cardToRemove = grid.querySelector(`[data-id="${id}"]`)?.closest('div[style*="background"]');
                if (cardToRemove) {
                    cardToRemove.style.opacity = '0.5';
                    cardToRemove.style.pointerEvents = 'none';
                }
                
                // Stop/abort the download if active
                try {
                    await fetch(`/api/game-downloads/pause/${id}`, { method: 'POST' });
                } catch (e) {
                    // Ignore pause errors
                }
                
                // Small delay to ensure pause completes
                await new Promise(r => setTimeout(r, 200));
                
                // Delete the download
                const deleteResp = await fetch(`/api/game-downloads/${id}?deleteFile=true`, { method: 'DELETE' });
                const deleteData = await deleteResp.json();
                
                if (!deleteResp.ok || !deleteData.success) {
                    throw new Error(deleteData.error || 'Delete failed');
                }
                
                // Force a fresh reload of the library
                await new Promise(r => setTimeout(r, 100));
                await loadGamesLibrary();
                
                showNotification('Download removed', 'success');
            } catch (e) {
                console.error('[GameDownloads] Remove error:', e);
                showNotification('Failed to remove download: ' + e.message, 'error');
                // Reload anyway to sync state
                await loadGamesLibrary();
            }
        }
        
        async function addGameToLibrary(url, gameName, gameImage, gameSize, provider) {
            try {
                // Check if this host is supported by TorBox
                const torboxSupported = isTorBoxSupported(url);
                
                // If host is NOT supported by TorBox, always open in browser
                if (!torboxSupported) {
                    if (window.electronAPI?.openExternal) {
                        await window.electronAPI.openExternal(url);
                        showNotification(`Opening "${gameName}" in browser - This host is not supported by TorBox`, 'info');
                    } else {
                        window.open(url, '_blank');
                        showNotification(`Opening "${gameName}" in new tab - This host is not supported by TorBox`, 'info');
                    }
                    return;
                }
                
                // Check if TorBox is logged in
                const torboxResp = await fetch('/api/game-downloads/torbox-status');
                const torboxData = await torboxResp.json();
                
                // If TorBox is NOT logged in, open URL in default browser instead
                if (!torboxData.hasTorBox) {
                    if (window.electronAPI?.openExternal) {
                        await window.electronAPI.openExternal(url);
                        showNotification(`Opening "${gameName}" in browser - Login to TorBox for in-app downloads`, 'info');
                    } else {
                        window.open(url, '_blank');
                        showNotification(`Opening "${gameName}" in new tab - Login to TorBox for in-app downloads`, 'info');
                    }
                    return;
                }
                
                const resp = await fetch('/api/game-downloads/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url, gameName, gameImage, gameSize, provider })
                });
                const data = await resp.json();
                if (data.success) {
                    showNotification(`Added "${gameName}" to library. Download started!`, 'success');
                    // Refresh library to get accurate count
                    loadGamesLibrary();
                } else {
                    showNotification(data.error || 'Failed to add to library', 'error');
                }
            } catch (e) {
                showNotification('Failed to add to library', 'error');
            }
        }
        
        // ============================================================================
        // END GAMES LIBRARY
        // ============================================================================
        
        // MiniGames page functions
        function showMiniGamesPage() {
            window.location.hash = '#/minigames';
        }

        function reloadMiniGamesPage() {
            const miniGamesIframe = document.getElementById('minigames-iframe');
            if (miniGamesIframe) {
                // Reload the iframe
                miniGamesIframe.src = 'about:blank';
                setTimeout(() => {
                    miniGamesIframe.src = 'https://playtorriogames.pages.dev/';
                    // Auto-scroll the MiniGames page to show the iframe
                    setTimeout(() => {
                        const miniGamesPageEl = document.getElementById('minigames-page');
                        if (miniGamesPageEl) {
                            miniGamesIframe.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'start' 
                            });
                            console.log('[MINIGAMES] Auto-scrolled MiniGames page to show iframe');
                        }
                    }, 50);
                }, 100);
                console.log('[MINIGAMES] Page reloaded fresh');
            }
        }

        function clearMiniGamesPage() {
            const miniGamesIframe = document.getElementById('minigames-iframe');
            if (miniGamesIframe) {
                // Clear MiniGames iframe
                miniGamesIframe.src = 'about:blank';
                console.log('[MINIGAMES] Page cleared');
            }
        }
        
        function showBooksPage() {
            window.location.hash = '#/books';
        }
        
        function showMusicPage() {
            window.location.hash = '#/music';
        }
        
        function showAudioBooksPage() {
            window.location.hash = '#/audiobooks';
            loadInitialAudioBooks();
        }

        let allAudioBooks = [];
        let isAudioBookSearchMode = false;
        let currentAudioBookChapters = [];
        let currentAudioBookChapterIndex = 0;
        let currentAudioBookTitle = '';
        let currentAudioBookPage = 1;
        let isLoadingMoreAudioBooks = false;

        async function loadInitialAudioBooks() {
            try {
                const booksView = document.getElementById('audiobooks-books-view');
                const chaptersView = document.getElementById('audiobooks-chapters-view');
                const resultsContainer = document.getElementById('audiobookSearchResults');
                const loadingEl = document.getElementById('audiobookLoading');
                const clearBtn = document.getElementById('clearAudioBookSearchBtn');
                const loadMoreContainer = document.getElementById('audiobookLoadMoreContainer');
                
                // Reset page counter
                currentAudioBookPage = 1;
                isAudioBookSearchMode = false;
                
                // Show books view, hide chapters view
                booksView.style.display = 'block';
                chaptersView.style.display = 'none';
                clearBtn.style.display = 'none';
                
                resultsContainer.innerHTML = '';
                loadingEl.style.display = 'block';
                
                const response = await fetch('/api/audiobooks/all');
                const data = await response.json();
                
                if (data.success && data.data.length > 0) {
                    allAudioBooks = data.data;
                    // Filter out specific audiobooks for home page display
                    const filteredBooks = data.data.filter(book => {
                        const title = book.title.toLowerCase();
                        return !title.includes('1001 nights') && !title.includes('the fox and the wolf');
                    });
                    displayAudioBooks(filteredBooks);
                    loadMoreContainer.style.display = 'block';
                } else {
                    resultsContainer.innerHTML = `
                        <div class="search-placeholder">
                            <i class="fas fa-exclamation-circle" style="font-size: 3rem; color: #e74c3c; margin-bottom: 1rem;"></i>
                            <h3>No AudioBooks Found</h3>
                            <p>Unable to load audiobooks at this time</p>
                        </div>
                    `;
                    loadMoreContainer.style.display = 'none';
                }
            } catch (error) {
                console.error('Error loading audiobooks:', error);
                const resultsContainer = document.getElementById('audiobookSearchResults');
                resultsContainer.innerHTML = `
                    <div class="search-placeholder">
                        <i class="fas fa-exclamation-circle" style="font-size: 3rem; color: #e74c3c; margin-bottom: 1rem;"></i>
                        <h3>Error Loading AudioBooks</h3>
                        <p>${error.message}</p>
                    </div>
                `;
                document.getElementById('audiobookLoadMoreContainer').style.display = 'none';
            } finally {
                document.getElementById('audiobookLoading').style.display = 'none';
            }
        }

        async function loadMoreAudioBooks() {
            if (isLoadingMoreAudioBooks || isAudioBookSearchMode) return;
            
            try {
                isLoadingMoreAudioBooks = true;
                const loadMoreBtn = document.getElementById('audiobookLoadMoreBtn');
                const originalText = loadMoreBtn.innerHTML;
                loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
                loadMoreBtn.disabled = true;
                
                currentAudioBookPage++;
                const response = await fetch(`/api/audiobooks/more/${currentAudioBookPage}`);
                const data = await response.json();
                
                if (data.success && data.data.length > 0) {
                    allAudioBooks = [...allAudioBooks, ...data.data];
                    // Filter out specific audiobooks from display
                    const filteredBooks = allAudioBooks.filter(book => {
                        const title = book.title.toLowerCase();
                        return !title.includes('1001 nights') && !title.includes('the fox and the wolf');
                    });
                    displayAudioBooks(filteredBooks);
                    loadMoreBtn.innerHTML = originalText;
                    loadMoreBtn.disabled = false;
                } else {
                    loadMoreBtn.innerHTML = '<i class="fas fa-check-circle"></i> No More Books';
                    setTimeout(() => {
                        document.getElementById('audiobookLoadMoreContainer').style.display = 'none';
                    }, 2000);
                }
            } catch (error) {
                console.error('Error loading more audiobooks:', error);
                currentAudioBookPage--; // Revert page increment
                const loadMoreBtn = document.getElementById('audiobookLoadMoreBtn');
                loadMoreBtn.innerHTML = '<i class="fas fa-plus-circle"></i> Load More';
                loadMoreBtn.disabled = false;
                showNotification('Error loading more books', 'error');
            } finally {
                isLoadingMoreAudioBooks = false;
            }
        }

        async function searchAudioBooks(query) {
            try {
                const resultsContainer = document.getElementById('audiobookSearchResults');
                const loadingEl = document.getElementById('audiobookLoading');
                const clearBtn = document.getElementById('clearAudioBookSearchBtn');
                const loadMoreContainer = document.getElementById('audiobookLoadMoreContainer');
                
                resultsContainer.innerHTML = '';
                loadingEl.style.display = 'block';
                
                const response = await fetch(`/api/audiobooks/search?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                
                if (data.success && data.data.length > 0) {
                    isAudioBookSearchMode = true;
                    clearBtn.style.display = 'inline-block';
                    loadMoreContainer.style.display = 'none';
                    displayAudioBooks(data.data);
                } else {
                    clearBtn.style.display = 'inline-block';
                    loadMoreContainer.style.display = 'none';
                    resultsContainer.innerHTML = `
                        <div class="search-placeholder">
                            <i class="fas fa-search" style="font-size: 3rem; color: #8b5cf6; margin-bottom: 1rem;"></i>
                            <h3>No Results Found</h3>
                            <p>Try searching for something else</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error searching audiobooks:', error);
                const resultsContainer = document.getElementById('audiobookSearchResults');
                resultsContainer.innerHTML = `
                    <div class="search-placeholder">
                        <i class="fas fa-exclamation-circle" style="font-size: 3rem; color: #e74c3c; margin-bottom: 1rem;"></i>
                        <h3>Search Error</h3>
                        <p>${error.message}</p>
                    </div>
                `;
                document.getElementById('audiobookLoadMoreContainer').style.display = 'none';
            } finally {
                document.getElementById('audiobookLoading').style.display = 'none';
            }
        }

        function displayAudioBooks(audiobooks) {
            const resultsContainer = document.getElementById('audiobookSearchResults');
            resultsContainer.innerHTML = '';
            
            audiobooks.forEach(book => {
                const bookCard = document.createElement('div');
                bookCard.className = 'book-card';
                bookCard.style.cursor = 'pointer';
                
                bookCard.innerHTML = `
                    <div class="book-cover-container">
                        <img src="${book.image || 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22280%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22280%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22Arial%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'}" 
                             alt="${book.title}" 
                             class="book-cover"
                             onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22280%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22280%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22Arial%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                        <div class="playtorrio-logo">PlayTorrio</div>
                    </div>
                    <div class="book-info">
                        <h3 class="book-title">${book.title}</h3>
                    </div>
                `;
                
                bookCard.onclick = () => openAudioBookChapters(book);
                resultsContainer.appendChild(bookCard);
            });
        }

        async function openAudioBookChapters(book) {
            try {
                const booksView = document.getElementById('audiobooks-books-view');
                const chaptersView = document.getElementById('audiobooks-chapters-view');
                const chapterTitle = document.getElementById('audiobooksChapterBookTitle').querySelector('span');
                const chaptersList = document.getElementById('audiobooksChaptersList');
                const chapterLoading = document.getElementById('audiobooksChapterLoading');
                
                currentAudioBookTitle = book.title;
                chapterTitle.textContent = book.title;
                
                booksView.style.display = 'none';
                chaptersView.style.display = 'block';
                chapterLoading.style.display = 'block';
                chaptersList.innerHTML = '';
                
                const response = await fetch(`/api/audiobooks/chapters/${book.post_name}`);
                const data = await response.json();
                
                if (data.success && data.data) {
                    currentAudioBookChapters = data.data;
                    renderAudioBookChapters();
                } else {
                    chaptersList.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #666;">
                            <i class="fas fa-exclamation-circle" style="font-size: 3rem; color: #e74c3c; margin-bottom: 1rem;"></i>
                            <h3>Failed to Load Chapters</h3>
                            <p>Unable to load chapters for this audiobook</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading chapters:', error);
                const chaptersList = document.getElementById('audiobooksChaptersList');
                chaptersList.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #666;">
                        <i class="fas fa-exclamation-circle" style="font-size: 3rem; color: #e74c3c; margin-bottom: 1rem;"></i>
                        <h3>Error Loading Chapters</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            } finally {
                document.getElementById('audiobooksChapterLoading').style.display = 'none';
            }
        }

        function renderAudioBookChapters() {
            const chaptersList = document.getElementById('audiobooksChaptersList');
            chaptersList.innerHTML = '';
            
            currentAudioBookChapters.forEach((chapter, index) => {
                const chapterItem = document.createElement('div');
                chapterItem.className = 'book-card';
                chapterItem.style.cursor = 'pointer';
                chapterItem.style.padding = '15px 20px';
                chapterItem.style.display = 'flex';
                chapterItem.style.justifyContent = 'space-between';
                chapterItem.style.alignItems = 'center';
                chapterItem.style.gap = '10px';
                chapterItem.setAttribute('data-chapter-index', index);
                
                const chapterInfo = document.createElement('div');
                chapterInfo.style.flex = '1';
                chapterInfo.style.display = 'flex';
                chapterInfo.style.justifyContent = 'space-between';
                chapterInfo.style.alignItems = 'center';
                chapterInfo.style.minWidth = '0';
                chapterInfo.innerHTML = `
                    <span style="font-weight: 600; font-size: 15px;">${chapter.track}. ${chapter.name}</span>
                    <span style="color: #666; font-size: 13px;">${chapter.duration}</span>
                `;
                chapterInfo.onclick = () => playAudioBookChapter(index);
                
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'action-btn';
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
                downloadBtn.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
                downloadBtn.onclick = (e) => {
                    e.stopPropagation();
                    downloadAudioBookChapter(chapter, index);
                };
                
                chapterItem.appendChild(chapterInfo);
                chapterItem.appendChild(downloadBtn);
                chaptersList.appendChild(chapterItem);
            });
        }

        async function playAudioBookChapter(index) {
            try {
                currentAudioBookChapterIndex = index;
                const chapter = currentAudioBookChapters[index];
                
                // Skip welcome track
                if (chapter.chapter_id === "0" || chapter.post_id === "0") {
                    if (index < currentAudioBookChapters.length - 1) {
                        playAudioBookChapter(index + 1);
                    }
                    return;
                }
                
                const playerEl = document.getElementById('audiobooksPlayer');
                const audioEl = document.getElementById('audiobooksAudioElement');
                const titleEl = document.getElementById('audiobooksPlayerTitle');
                const chapterEl = document.getElementById('audiobooksPlayerChapter');
                const playPauseBtn = document.getElementById('audiobooksPlayPauseBtn');
                
                updateAudioBookChapterActive(index);
                titleEl.textContent = currentAudioBookTitle;
                chapterEl.textContent = chapter.name;
                playerEl.style.display = 'block';
                
                const response = await fetch('/api/audiobooks/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapterId: parseInt(chapter.chapter_id),
                        serverType: 1
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.data.link_mp3) {
                    audioEl.src = data.data.link_mp3;
                    audioEl.play();
                    playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                } else {
                    showNotification('Failed to get audio stream', 'error');
                }
            } catch (error) {
                console.error('Error playing chapter:', error);
                showNotification('Error playing chapter: ' + error.message, 'error');
            }
        }

        async function downloadAudioBookChapter(chapter, index) {
            try {
                if (chapter.chapter_id === "0" || chapter.post_id === "0") {
                    showNotification('Cannot download welcome track', 'error');
                    return;
                }
                
                const response = await fetch('/api/audiobooks/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapterId: parseInt(chapter.chapter_id),
                        serverType: 1
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.data.link_mp3) {
                    // Open download link in default browser
                    if (window.electronAPI && window.electronAPI.openExternal) {
                        await window.electronAPI.openExternal(data.data.link_mp3);
                        showNotification('Opening download in browser', 'success');
                    } else {
                        // Fallback for non-Electron environments
                        window.open(data.data.link_mp3, '_blank');
                        showNotification('Download opened', 'success');
                    }
                } else {
                    showNotification('Failed to get download link', 'error');
                }
            } catch (error) {
                console.error('Error downloading chapter:', error);
                showNotification('Error downloading: ' + error.message, 'error');
            }
        }

        function updateAudioBookChapterActive(index) {
            const items = document.querySelectorAll('#audiobooksChaptersList .book-card');
            items.forEach((item, i) => {
                if (i === index) {
                    item.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
                    item.style.color = 'white';
                    item.querySelector('span:last-child').style.color = 'rgba(255,255,255,0.9)';
                } else {
                    item.style.background = '';
                    item.style.color = '';
                    item.querySelector('span:last-child').style.color = '#666';
                }
            });
        }

        function formatAudioTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function showBookTorrioPage() {
            window.location.hash = '#/booktorrio';
        }
        
        function showAnimePage() {
            window.location.hash = '#/anime';
        }
        
        function showMangaPage() {
            window.location.hash = '#/manga';
        }
        
        function showComicsPage() {
            window.location.hash = '#/comics';
        }
        
        function showDownloaderPage() {
            window.location.hash = '#/downloader';
        }
        
        // Live TV Functionality
        let liveTvMatches = [];
        let liveTvCategories = [];
        
        async function initLiveTv() {
            const categorySelect = document.getElementById('livetv-category-select');
            const grid = document.getElementById('livetv-grid');
            const empty = document.getElementById('livetv-empty');
            
            if (!categorySelect) return;
            
            // Default to Kobra
            fetchMatches('kobra');
        }
        

        
        async function openStreamsModal(match) {
            const modal = document.getElementById('livetv-streams-modal');
            const title = document.getElementById('livetv-streams-title');
            const list = document.getElementById('livetv-streams-list');
            
            if (!modal || !title || !list) return;
            
            title.textContent = match.title;
            list.innerHTML = '<div class="livetv-loading"><i class="fas fa-spinner"></i><p>Preparing streams...</p></div>';
            modal.style.display = 'flex';
            
            try {
                // Streams are already included in the match object from watchfooty.live API
                const allStreams = match.streams || [];
                
                if (allStreams.length === 0) {
                    list.innerHTML = '<div class="livetv-empty"><p>No streams available for this match</p></div>';
                    return;
                }
                
                // Render streams with embedded iframes
                list.innerHTML = '';
                allStreams.forEach((stream, index) => {
                    const streamItem = document.createElement('div');
                    streamItem.className = 'livetv-stream-item';
                    
                    const language = stream.language || 'Unknown';
                    const quality = stream.quality || 'SD';
                    const hdBadge = quality.toLowerCase().includes('hd') || quality === '1080p' || quality === '720p' 
                        ? '<span class="livetv-stream-badge hd">HD</span>' 
                        : '';
                    const adsBadge = stream.ads ? '<span class="livetv-stream-badge ads" style="background: rgba(239,68,68,0.2); color: #ef4444;"><i class="fas fa-ad"></i> Ads</span>' : '';
                    const nsfwBadge = stream.nsfw ? '<span class="livetv-stream-badge nsfw" style="background: rgba(168,85,247,0.2); color: #a855f7;">18+</span>' : '';
                    
                    streamItem.innerHTML = `
                        <div class="livetv-stream-info">
                            <div class="livetv-stream-source">
                                <i class="fas fa-broadcast-tower"></i> Stream ${index + 1}
                            </div>
                            <div class="livetv-stream-details">
                                ${hdBadge}
                                <span class="livetv-stream-badge quality">
                                    <i class="fas fa-video"></i> ${quality}
                                </span>
                                <span class="livetv-stream-badge language">
                                    <i class="fas fa-language"></i> ${language}
                                </span>
                                ${adsBadge}
                                ${nsfwBadge}
                            </div>
                        </div>
                        <div class="livetv-stream-actions">
                            <button class="livetv-play-stream-btn" data-stream-url="${stream.url}">
                                <i class="fas fa-play"></i> Play Stream
                            </button>
                            <button class="livetv-copy-link-btn">
                                <i class="fas fa-copy"></i> Copy Link
                            </button>
                        </div>
                    `;
                    
                    // Play stream button - embed in app
                    const playBtn = streamItem.querySelector('.livetv-play-stream-btn');
                    playBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const streamUrl = stream.url;
                        
                        console.log('[LiveTV] Playing stream:', streamUrl);
                        
                        // Close streams modal
                        modal.style.display = 'none';
                        
                        // Create fullscreen iframe viewer with back button
                        const existingViewer = document.getElementById('livetv-stream-viewer');
                        if (existingViewer) {
                            existingViewer.remove();
                        }
                        
                        const viewer = document.createElement('div');
                        viewer.id = 'livetv-stream-viewer';
                        viewer.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; z-index: 99999; display: flex; flex-direction: column;';
                        
                        viewer.innerHTML = `
                            <div style="position: absolute; top: 1rem; left: 1rem; z-index: 100000;">
                                <button id="livetv-back-btn" style="
                                    background: linear-gradient(135deg, #ef4444, #dc2626);
                                    color: #fff;
                                    border: none;
                                    padding: 0.75rem 1.5rem;
                                    border-radius: 8px;
                                    font-weight: 700;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    gap: 0.5rem;
                                    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                                    transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
                                " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(239,68,68,0.6)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.5)';">
                                    <i class="fas fa-arrow-left"></i> Back
                                </button>
                            </div>
                            <iframe 
                                src="${streamUrl}" 
                                style="width: 100%; height: 100%; border: none;"
                                frameborder="0"
                                scrolling="no"
                                allowfullscreen="true"
                                webkitallowfullscreen="true"
                                mozallowfullscreen="true"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                                referrerpolicy="origin"
                            ></iframe>
                        `;
                        
                        document.body.appendChild(viewer);
                        
                        // Back button handler
                        const backBtn = document.getElementById('livetv-back-btn');
                        backBtn.addEventListener('click', () => {
                            viewer.remove();
                            console.log('[LiveTV] Stream viewer closed');
                        });
                        
                        // ESC key to close
                        const escHandler = (e) => {
                            if (e.key === 'Escape') {
                                viewer.remove();
                                document.removeEventListener('keydown', escHandler);
                                console.log('[LiveTV] Stream viewer closed via ESC');
                            }
                        };
                        document.addEventListener('keydown', escHandler);
                    });
                    
                    const copyBtn = streamItem.querySelector('.livetv-copy-link-btn');
                    copyBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        try {
                            await navigator.clipboard.writeText(stream.url);
                            const originalHTML = copyBtn.innerHTML;
                            copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                            copyBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            
                            setTimeout(() => {
                                copyBtn.innerHTML = originalHTML;
                                copyBtn.style.background = '';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy:', err);
                        }
                    });
                    
                    list.appendChild(streamItem);
                });
            } catch (error) {
                console.error('Error loading streams:', error);
                list.innerHTML = '<div class="livetv-empty"><p>Failed to load streams. Please try again.</p></div>';
            }
        }
        

        
    function setupEventListeners() {
            // Custom Title Bar Controls
            const minimizeBtn = document.getElementById('minimizeBtn');
            const maximizeBtn = document.getElementById('maximizeBtn');
            const closeBtn = document.getElementById('closeBtn');
            
            if (minimizeBtn && window.electronAPI) {
                minimizeBtn.addEventListener('click', () => {
                    window.electronAPI.minimizeWindow();
                });
            }
            
            if (maximizeBtn && window.electronAPI) {
                maximizeBtn.addEventListener('click', () => {
                    window.electronAPI.maximizeWindow();
                });
            }
            
            if (closeBtn && window.electronAPI) {
                closeBtn.addEventListener('click', () => {
                    window.electronAPI.closeWindow();
                });
            }
            
            // Initialize Video.js player
            if (typeof videojs !== 'undefined') {
                try {
                    window.vjsPlayer = videojs('customVideo', {
                        controls: false,
                        preload: 'metadata',
                        fluid: false,
                        fill: true
                    });
                    console.log('Video.js initialized');
                } catch (e) {
                    console.warn('Video.js initialization failed:', e);
                }
            }
            
            // API Setup Modal - REMOVED (event listeners disabled)
            // saveFirstTimeApiKey button removed
            // useTorrentlessSetup button removed
            // videoTutorialFirst button removed
            
            // Donate modal removed
            
            // Discord Modal
            if (discordClose) {
                discordClose.addEventListener('click', hideDiscordModal);
            }
            if (discordJoinBtn) {
                discordJoinBtn.addEventListener('click', async () => {
                    const url = 'https://discord.gg/bbkVHRHnRk';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            window.open(url, '_blank', 'noopener');
                        }
                        // Save to both file and localStorage for reliability
                        localStorage.setItem('pt_discord_dismissed_v1', 'true');
                        if (window.electronAPI?.setUserPref) {
                            await window.electronAPI.setUserPref('discord_dismissed', true);
                        }
                        hideDiscordModal();
                        showNotification('Opening Discord invite...', 'success');
                    } catch(err) {
                        console.error('Failed to open Discord:', err);
                        showNotification('Failed to open Discord link', 'error');
                    }
                });
            }
            if (discordDontShowBtn) {
                discordDontShowBtn.addEventListener('click', async () => {
                    // Save to both file and localStorage for reliability
                    localStorage.setItem('pt_discord_dismissed_v1', 'true');
                    if (window.electronAPI?.setUserPref) {
                        await window.electronAPI.setUserPref('discord_dismissed', true);
                    }
                    hideDiscordModal();
                    showNotification("We'll stop showing this.", 'success');
                });
            }
            
            // Update & What's New modals removed
            
            if (discordBtn) {
                discordBtn.addEventListener('click', async () => {
                    const url = 'https://discord.gg/bbkVHRHnRk';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            window.open(url, '_blank', 'noopener');
                        }
                        showNotification('Opening Discord...', 'success');
                    } catch(err) {
                        console.error('Failed to open Discord:', err);
                        showNotification('Failed to open Discord link', 'error');
                    }
                });
            }
            // Donate button (persistent)
            const donateBtn = document.getElementById('donateBtn');
            if (donateBtn) {
                donateBtn.addEventListener('click', async () => {
                    const url = 'https://ko-fi.com/ayman228x';
                    try {
                        if (window.electronAPI?.openExternal) {
                            await window.electronAPI.openExternal(url);
                        } else {
                            window.open(url, '_blank', 'noopener');
                        }
                        showNotification('Opening Ko-fi...', 'success');
                    } catch(err) {
                        console.error('Failed to open Ko-fi:', err);
                        showNotification('Failed to open Ko-fi link', 'error');
                    }
                });
            }
            
            // Chromecast Device Modal
            const closeChromecastModal = document.getElementById('close-chromecast-modal');
            if (closeChromecastModal) {
                closeChromecastModal.addEventListener('click', () => {
                    const modal = document.getElementById('chromecast-device-modal');
                    if (modal) {
                        modal.style.display = 'none';
                        modal.classList.remove('active');
                        modal.style.opacity = '0';
                        modal.style.pointerEvents = 'none';
                    }
                });
            }
            
            // Settings Modal
            clearCacheBtn.addEventListener('click', async () => {
                const result = await window.electronAPI.clearCache();
                showNotification(result.message, result.success ? 'success' : 'error');
            });
            // Cache folder browse buttons (attach to ALL instances)
            if (window.electronAPI && window.electronAPI.selectCacheFolder) {
                const selectCacheBtns = document.querySelectorAll('#selectCacheBtn');
                selectCacheBtns.forEach(btn => btn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    try {
                        const result = await window.electronAPI.selectCacheFolder();
                        if (result.success && result.path) {
                            // Prefer the cacheLocation input in the same card/section as the clicked button
                            const scope = btn.closest('.settings-card-body, .api-input-group, .form-group') || document;
                            const scopedInput = scope.querySelector('#cacheLocation');
                            if (scopedInput) {
                                scopedInput.value = result.path;
                            } else {
                                // Fallback: update the visible cacheLocation input
                                const allInputs = document.querySelectorAll('#cacheLocation');
                                let updated = false;
                                for (const input of allInputs) {
                                    if (input.offsetParent !== null) { input.value = result.path; updated = true; break; }
                                }
                                if (!updated && allInputs.length > 0) { allInputs[0].value = result.path; }
                            }
                        }
                    } catch (error) {
                        console.error('Error selecting cache folder:', error);
                        showNotification('Failed to select folder');
                    }
                }));
            }
            // MPV install helpers removed
            settingsClose.addEventListener('click', hideSettingsModal);
            saveSettings.addEventListener('click', saveSettings_);
            cancelSettings.addEventListener('click', hideSettingsModal);
            
            // Settings page buttons
            const saveSettingsPage = document.getElementById('saveSettingsPage');
            const cancelSettingsPage = document.getElementById('cancelSettingsPage');
            if (saveSettingsPage) {
                saveSettingsPage.addEventListener('click', saveSettings_);
            }
            if (cancelSettingsPage) {
                cancelSettingsPage.addEventListener('click', () => {
                    window.history.back();
                });
            }
            
            // Theme selector (attach to all instances - modal and settings page)
            const themeSelectors = document.querySelectorAll('#themeSelector');
            themeSelectors.forEach(themeSelector => {
                if (themeSelector) {
                    themeSelector.addEventListener('change', (e) => {
                        const selectedTheme = e.target.value;
                        applyTheme(selectedTheme);
                        showNotification(`Theme changed to ${e.target.options[e.target.selectedIndex].text}`, 'success');
                    });
                }
            });
            
            const videoTutorialBtns = document.querySelectorAll('#videoTutorialBtn');
            videoTutorialBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const url = 'https://www.youtube.com/watch?v=3igLReZFFzg';
                    if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(url);
                });
            });
            
            // Watch without Jackett toggle - attach to ALL instances
            const useTorrentlessToggles = document.querySelectorAll('#useTorrentlessToggle');
            useTorrentlessToggles.forEach(toggle => {
                toggle.addEventListener('change', async (e) => {
                    const enabled = !!e.target.checked;
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ useTorrentless: enabled })
                        });
                        if (res.ok) {
                            useTorrentless = enabled;
                            // Update all other toggles
                            useTorrentlessToggles.forEach(t => t.checked = enabled);
                            showNotification(enabled ? 'Watch without Jackett enabled.' : 'Watch without Jackett disabled.');
                        } else {
                            e.target.checked = !enabled;
                            showNotification('Failed to update setting.');
                        }
                    } catch {
                        e.target.checked = !enabled;
                        showNotification('Failed to update setting.');
                    }
                });
            });
            
            // Torrent source buttons - attach to ALL instances
            const torrentioBtns = document.querySelectorAll('#torrentioBtn');
            const inAppScraperBtns = document.querySelectorAll('#inAppScraperBtn');
            
            if (torrentioBtns.length > 0 && inAppScraperBtns.length > 0) {
                const handleSourceChange = async (source) => {
                    console.log('=================================');
                    console.log('[Settings] Button clicked! Changing source to:', source);
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ torrentSource: source })
                        });
                        const responseData = await res.json();
                        console.log('[Settings] Server response:', responseData);
                        
                        if (res.ok) {
                            // Update UI immediately for ALL button instances
                            if (source === 'torrentio') {
                                torrentioBtns.forEach(btn => btn.classList.add('active'));
                                inAppScraperBtns.forEach(btn => btn.classList.remove('active'));
                                console.log('[Settings] UI updated: Torrentio active');
                            } else {
                                torrentioBtns.forEach(btn => btn.classList.remove('active'));
                                inAppScraperBtns.forEach(btn => btn.classList.add('active'));
                                console.log('[Settings] UI updated: In-App Scraper active');
                            }
                            console.log('[Settings] SUCCESS! Setting saved:', source);
                            console.log('=================================');
                            showNotification(`Torrent source changed to ${source === 'torrentio' ? 'Torrentio' : 'In-App Scraper'}`);
                        } else {
                            console.error('[Settings] FAILED to save setting');
                            console.log('=================================');
                            showNotification('Failed to update torrent source.');
                        }
                    } catch (err) {
                        console.error('[Settings] ERROR:', err);
                        console.log('=================================');
                        showNotification('Failed to update torrent source.');
                    }
                };
                
                torrentioBtns.forEach(btn => {
                    btn.addEventListener('click', () => handleSourceChange('torrentio'));
                });
                inAppScraperBtns.forEach(btn => {
                    btn.addEventListener('click', () => handleSourceChange('in-app-scraper'));
                });
            }

            // Debrid settings
            if (useDebridToggle || debridProviderSel) {
                const onDebridChange = async () => {
                    // Get visible useDebridToggle
                    const useDebridToggles = document.querySelectorAll('#useDebridToggle');
                    let enabled = false;
                    for (const toggle of useDebridToggles) {
                        if (toggle.offsetParent !== null) {
                            enabled = !!toggle.checked;
                            break;
                        }
                    }
                    
                    // Get visible debridProvider
                    const debridProviders = document.querySelectorAll('#debridProvider');
                    let provider = 'realdebrid';
                    for (const select of debridProviders) {
                        if (select.offsetParent !== null) {
                            provider = select.value;
                            break;
                        }
                    }
                    
                    // Get visible rdClientId input
                    const rdClientIdInputs = document.querySelectorAll('#rdClientId');
                    let visibleRdClientId = '';
                    for (const input of rdClientIdInputs) {
                        if (input.offsetParent !== null) {
                            visibleRdClientId = (input.value || '').trim();
                            break;
                        }
                    }
                    const rdClientId = visibleRdClientId;
                    
                    try {
                        const res = await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ useDebrid: enabled, debridProvider: provider, rdClientId })
                        });
                        if (!res.ok) throw new Error('save failed');

                    
                        await res.json();
                        useDebrid = enabled;
                        debridProvider = provider;
                        // Toggle provider-specific UI blocks for ALL instances
                        const isRD = provider === 'realdebrid';
                        const isAD = provider === 'alldebrid';
                        const isTB = provider === 'torbox';
                        const isPM = provider === 'premiumize';
                        
                        document.querySelectorAll('#rdClientIdGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdTokenGroup').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdTokenButtons').forEach(el => el.style.display = isRD ? '' : 'none');
                        document.querySelectorAll('#rdCodePanel').forEach(el => el.style.display = 'none');
                        document.querySelectorAll('#adSection').forEach(el => el.style.display = isAD ? '' : 'none');
                        document.querySelectorAll('#tbSection').forEach(el => el.style.display = isTB ? '' : 'none');
                        document.querySelectorAll('#pmSection').forEach(el => el.style.display = isPM ? '' : 'none');
                        
                        showNotification('Debrid settings saved.');
                    } catch {
                        showNotification('Failed to save debrid settings');
                    }
                };
                
                // Add event listeners to ALL instances
                const useDebridToggles = document.querySelectorAll('#useDebridToggle');
                useDebridToggles.forEach(toggle => {
                    toggle.addEventListener('change', onDebridChange);
                });
                
                const debridProviders = document.querySelectorAll('#debridProvider');
                debridProviders.forEach(select => {
                    select.addEventListener('change', onDebridChange);
                });
                
                const rdClientIdInputs = document.querySelectorAll('#rdClientId');
                rdClientIdInputs.forEach(input => {
                    input.addEventListener('change', onDebridChange);
                });
            }

            // Attach to ALL duplicate "Save Token" buttons (new + old settings UI)
            {
                const saveDebridTokenBtns = document.querySelectorAll('#saveDebridToken');
                saveDebridTokenBtns.forEach(btn => btn.addEventListener('click', async () => {
                    // Get visible debridToken input
                    const debridTokenInputs = document.querySelectorAll('#debridToken');
                    let token = '';
                    let visibleInput = null;
                    for (const input of debridTokenInputs) {
                        if (input.offsetParent !== null) {
                            token = (input.value || '').trim();
                            visibleInput = input;
                            break;
                        }
                    }
                    
                    if (!token) { showNotification('Enter a token first'); return; }
                    try {
                        const res = await fetch(`${API_BASE_URL}/debrid/token`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token })
                        });
                        if (res.ok) {
                            // Update ALL debridStatus elements
                            document.querySelectorAll('#debridStatus').forEach(status => {
                                status.textContent = 'Logged in';
                            });
                            // Clear ALL debridToken inputs
                            debridTokenInputs.forEach(input => {
                                input.value = '';
                            });
                            showNotification('Debrid token saved.');
                        } else {
                            showNotification('Failed to save token');
                        }
                    } catch { showNotification('Failed to save token'); }
                }));
            }
            // Attach to ALL duplicate "Logout/clear RD token" buttons
            {
                const clearDebridTokenBtns = document.querySelectorAll('#clearDebridToken');
                clearDebridTokenBtns.forEach(btn => btn.addEventListener('click', async () => {
                    try {
                        const res = await fetch(`${API_BASE_URL}/debrid/token`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token: '' })
                        });
                        if (res.ok) {
                            // Update ALL debridStatus elements
                            document.querySelectorAll('#debridStatus').forEach(status => {
                                status.textContent = 'Not logged in';
                            });
                            showNotification('Logged out of Debrid.');
                        } else {
                            showNotification('Failed to logout');
                        }
                    } catch { showNotification('Failed to logout'); }
                }));
            }

            // RD Device-code login handlers
            let rdPollTimer = null;
            function stopRdPolling() { if (rdPollTimer) { clearInterval(rdPollTimer); rdPollTimer = null; } }
            async function beginRdDeviceLogin() {
                try {
                    const clientId = (rdClientIdInput?.value || '').trim();
                    // Allow starting without clientId; server will fall back to stored rdClientId
                    const url = `${API_BASE_URL}/debrid/rd/device-code${clientId ? `?client_id=${encodeURIComponent(clientId)}` : ''}`;
                    const r = await fetch(url);
                    if (!r.ok) {
                        let msg = 'RD device-code start failed';
                        try { const t = await r.json(); if (t?.error) msg = t.error; } catch { try { msg = await r.text(); } catch {} }
                        rdLoginStatusEl.textContent = 'Error starting login';
                        showNotification(msg);
                        return;
                    }
                    const j = await r.json();
                    rdCodePanel.style.display = 'block';
                    rdUserCodeEl.textContent = j.user_code || '----';
                    rdVerifyUrlEl.textContent = j.verification_url || 'https://real-debrid.com/device';
                    rdVerifyUrlEl.href = j.verification_url || 'https://real-debrid.com/device';
                    rdLoginStatusEl.textContent = 'Waiting for approval';
                    const intervalMs = Math.max(3, Number(j.interval || 5)) * 1000;
                    const deviceCode = j.device_code;
                    // Start polling
                    stopRdPolling();
                    rdPollTimer = setInterval(async () => {
                        try {
                            const pr = await fetch(`${API_BASE_URL}/debrid/rd/poll`, {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ device_code: deviceCode, client_id: clientId || undefined })
                            });
                            if (pr.ok) {
                                stopRdPolling();
                                rdLoginStatusEl.textContent = 'Logged in!';
                                // Update ALL debridStatus elements
                                document.querySelectorAll('#debridStatus').forEach(status => {
                                    status.textContent = 'Logged in';
                                });
                                debridAuth = true;
                                showNotification('RealDebrid connected');
                                setTimeout(() => { rdCodePanel.style.display = 'none'; }, 800);
                            } else {
                                const txt = await pr.text();
                                if (/expired|invalid/i.test(txt)) {
                                    stopRdPolling();
                                    rdLoginStatusEl.textContent = 'Code expired. Try again.';
                                }
                            }
                        } catch (_) {}
                    }, intervalMs);
                } catch (_) {
                    showNotification('Failed to start device login');
                }
            }
            if (rdDeviceLoginBtn) rdDeviceLoginBtn.addEventListener('click', beginRdDeviceLogin);
            if (rdOpenVerifyBtn) rdOpenVerifyBtn.addEventListener('click', async () => {
                const href = rdVerifyUrlEl?.href || 'https://real-debrid.com/device';
                if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href);
                else window.open(href, '_blank');
            });
            if (rdCopyCodeBtn) rdCopyCodeBtn.addEventListener('click', async () => {
                try { await navigator.clipboard.writeText(rdUserCodeEl?.textContent || ''); showNotification('Code copied'); } catch(_) {}
            });
            if (rdCancelLoginBtn) rdCancelLoginBtn.addEventListener('click', async () => {
                stopRdPolling(); rdCodePanel.style.display = 'none';
            });

            // AllDebrid PIN login handlers
            let adPollTimer = null, adPin = '', adCheck = '';
            function stopAdPolling() { if (adPollTimer) { clearInterval(adPollTimer); adPollTimer = null; } }
            async function beginAdPinLogin() {
                // If already authenticated with AllDebrid, avoid creating a new API key via PIN
                try {
                    await ensureDebridState();
                } catch {}
                if (useDebrid && debridProvider === 'alldebrid' && debridAuth) {
                    showNotification('Already logged in to AllDebrid');
                    return;
                }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/pin`);
                    const j = await r.json();
                    if (r.ok && j.pin && j.check) {
                        adPin = j.pin; adCheck = j.check;
                        if (adPinPanel) adPinPanel.style.display = 'block';
                        if (adPinCodeEl) adPinCodeEl.textContent = adPin;
                        if (adUserUrlEl) adUserUrlEl.href = j.user_url || 'https://alldebrid.com/pin/';
                        if (adLoginStatusEl) adLoginStatusEl.textContent = 'Waiting';
                        stopAdPolling();
                        adPollTimer = setInterval(async () => {
                            try {
                                const pr = await fetch(`${API_BASE_URL}/debrid/ad/check`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pin: adPin, check: adCheck }) });
                                const pj = await pr.json();
                                if (pr.ok && pj.success) {
                                    stopAdPolling();
                                    // Update ALL debridStatus elements
                                    document.querySelectorAll('#debridStatus').forEach(status => {
                                        status.textContent = 'Logged in';
                                    });
                                    debridAuth = true;
                                    if (adLoginStatusEl) adLoginStatusEl.textContent = 'Logged in!';
                                    showNotification('AllDebrid connected');
                                    setTimeout(() => { if (adPinPanel) adPinPanel.style.display = 'none'; }, 800);
                                } else if (pr.ok) {
                                    // keep waiting
                                } else {
                                    stopAdPolling();
                                    if (adLoginStatusEl) adLoginStatusEl.textContent = pj?.error || 'PIN expired';
                                }
                            } catch (_) {}
                        }, 5000);
                    } else {
                        showNotification(j?.error || 'Failed to start AllDebrid PIN');
                    }
                } catch (_) {
                    showNotification('Failed to start AllDebrid PIN');
                }
            }
            if (adStartPinBtn) adStartPinBtn.addEventListener('click', beginAdPinLogin);
            if (adOpenUserUrlBtn) adOpenUserUrlBtn.addEventListener('click', async () => {
                const href = adUserUrlEl?.href || 'https://alldebrid.com/pin/';
                if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href); else window.open(href, '_blank');
            });
            if (adCopyPinBtn) adCopyPinBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(adPinCodeEl?.textContent || ''); showNotification('PIN copied'); } catch(_) {} });
            if (adCancelPinBtn) adCancelPinBtn.addEventListener('click', () => { stopAdPolling(); if (adPinPanel) adPinPanel.style.display = 'none'; });

            // --- Bind duplicated RD/AD login UIs (new settings panel) ---
            // Helper: find nearest container with a descendant matching a selector using attribute match to avoid global-ID issues
            function qIn(el, sel) { return el ? el.querySelector(sel) : null; }

            // Scoped RD device-code login
            async function beginRdDeviceLoginScoped(buttonEl) {
                const container = buttonEl.closest('#rdButtons')?.parentElement || buttonEl.parentElement;
                const rdClientInput = qIn(container, '[id="rdClientId"]');
                const codePanel = qIn(container, '[id="rdCodePanel"]');
                const userCodeEl = qIn(container, '[id="rdUserCode"]');
                const verifyUrlEl = qIn(container, '[id="rdVerifyUrl"]');
                const loginStatusEl = qIn(container, '[id="rdLoginStatus"]');
                const openVerifyBtn = qIn(container, '[id="rdOpenVerify"]');
                const copyCodeBtn = qIn(container, '[id="rdCopyCode"]');
                const cancelBtn = qIn(container, '[id="rdCancelLogin"]');

                const clientId = (rdClientInput?.value || '').trim();
                const url = `${API_BASE_URL}/debrid/rd/device-code${clientId ? `?client_id=${encodeURIComponent(clientId)}` : ''}`;
                try {
                    const r = await fetch(url);
                    if (!r.ok) {
                        let msg = 'RD device-code start failed';
                        try { const t = await r.json(); if (t?.error) msg = t.error; } catch { try { msg = await r.text(); } catch {} }
                        if (loginStatusEl) loginStatusEl.textContent = 'Error starting login';
                        showNotification(msg);
                        return;
                    }
                    const j = await r.json();
                    if (codePanel) codePanel.style.display = 'block';
                    if (userCodeEl) userCodeEl.textContent = j.user_code || '----';
                    if (verifyUrlEl) { verifyUrlEl.textContent = j.verification_url || 'https://real-debrid.com/device'; verifyUrlEl.href = j.verification_url || 'https://real-debrid.com/device'; }
                    if (loginStatusEl) loginStatusEl.textContent = 'Waiting for approval';
                    const intervalMs = Math.max(3, Number(j.interval || 5)) * 1000;
                    const deviceCode = j.device_code;

                    stopRdPolling();
                    rdPollTimer = setInterval(async () => {
                        try {
                            const pr = await fetch(`${API_BASE_URL}/debrid/rd/poll`, {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ device_code: deviceCode, client_id: clientId || undefined })
                            });
                            if (pr.ok) {
                                stopRdPolling();
                                if (loginStatusEl) loginStatusEl.textContent = 'Logged in!';
                                document.querySelectorAll('#debridStatus').forEach(status => { status.textContent = 'Logged in'; });
                                debridAuth = true;
                                // Reflect provider/toggle in all duplicate controls
                                document.querySelectorAll('#useDebridToggle').forEach(cb => { try { cb.checked = true; } catch {} });
                                document.querySelectorAll('#debridProvider').forEach(sel => { try { sel.value = 'realdebrid'; } catch {} });
                                // Persist provider and enable Debrid so caching is used
                                try { await fetch(`${API_BASE_URL}/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ useDebrid: true, debridProvider: 'realdebrid' }) }); } catch {}
                                showNotification('RealDebrid connected');
                                setTimeout(() => { if (codePanel) codePanel.style.display = 'none'; }, 800);
                            } else {
                                const txt = await pr.text();
                                if (/expired|invalid/i.test(txt)) { stopRdPolling(); if (loginStatusEl) loginStatusEl.textContent = 'Code expired. Try again.'; }
                            }
                        } catch (_) {}
                    }, intervalMs);

                    // Bind inline controls once
                    if (container && !container.dataset.rdBound) {
                        container.dataset.rdBound = '1';
                        if (openVerifyBtn) openVerifyBtn.addEventListener('click', async () => {
                            const href = verifyUrlEl?.href || 'https://real-debrid.com/device';
                            if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href); else window.open(href, '_blank');
                        });
                        if (copyCodeBtn) copyCodeBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(userCodeEl?.textContent || ''); showNotification('Code copied'); } catch(_) {} });
                        if (cancelBtn) cancelBtn.addEventListener('click', () => { stopRdPolling(); if (codePanel) codePanel.style.display = 'none'; });
                    }
                } catch (_) {
                    showNotification('Failed to start device login');
                }
            }

            // Scoped AllDebrid PIN login
            async function beginAdPinLoginScoped(buttonEl) {
                const container = buttonEl.closest('#adSection') || buttonEl.parentElement;
                const pinPanel = qIn(container, '[id="adPinPanel"]');
                const pinCodeEl = qIn(container, '[id="adPinCode"]');
                const userUrlEl = qIn(container, '[id="adUserUrl"]');
                const loginStatusEl = qIn(container, '[id="adLoginStatus"]');
                const openUserBtn = qIn(container, '[id="adOpenUserUrl"]');
                const copyPinBtn = qIn(container, '[id="adCopyPin"]');
                const cancelBtn = qIn(container, '[id="adCancelPin"]');

                try { await ensureDebridState(); } catch {}
                if (useDebrid && debridProvider === 'alldebrid' && debridAuth) { showNotification('Already logged in to AllDebrid'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/pin`);
                    const j = await r.json();
                    if (r.ok && j.pin && j.check) {
                        adPin = j.pin; adCheck = j.check;
                        if (pinPanel) pinPanel.style.display = 'block';
                        if (pinCodeEl) pinCodeEl.textContent = adPin;
                        if (userUrlEl) userUrlEl.href = j.user_url || 'https://alldebrid.com/pin/';
                        if (loginStatusEl) loginStatusEl.textContent = 'Waiting';
                        stopAdPolling();
                        adPollTimer = setInterval(async () => {
                            try {
                                const pr = await fetch(`${API_BASE_URL}/debrid/ad/check`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pin: adPin, check: adCheck }) });
                                const pj = await pr.json();
                                if (pr.ok && pj.success) {
                                    stopAdPolling();
                                    document.querySelectorAll('#debridStatus').forEach(status => { status.textContent = 'Logged in'; });
                                    debridAuth = true;
                                    if (loginStatusEl) loginStatusEl.textContent = 'Logged in!';
                                    // Reflect provider/toggle in all duplicate controls
                                    document.querySelectorAll('#useDebridToggle').forEach(cb => { try { cb.checked = true; } catch {} });
                                    document.querySelectorAll('#debridProvider').forEach(sel => { try { sel.value = 'alldebrid'; } catch {} });
                                    // Persist provider and enable Debrid
                                    try { await fetch(`${API_BASE_URL}/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ useDebrid: true, debridProvider: 'alldebrid' }) }); } catch {}
                                    showNotification('AllDebrid connected');
                                    setTimeout(() => { if (pinPanel) pinPanel.style.display = 'none'; }, 800);
                                } else if (!pr.ok) {
                                    stopAdPolling();
                                    if (loginStatusEl) loginStatusEl.textContent = pj?.error || 'PIN expired';
                                }
                            } catch (_) {}
                        }, 5000);

                        if (container && !container.dataset.adBound) {
                            container.dataset.adBound = '1';
                            if (openUserBtn) openUserBtn.addEventListener('click', async () => { const href = userUrlEl?.href || 'https://alldebrid.com/pin/'; if (window.electronAPI?.openExternal) await window.electronAPI.openExternal(href); else window.open(href, '_blank'); });
                            if (copyPinBtn) copyPinBtn.addEventListener('click', async () => { try { await navigator.clipboard.writeText(pinCodeEl?.textContent || ''); showNotification('PIN copied'); } catch(_) {} });
                            if (cancelBtn) cancelBtn.addEventListener('click', () => { stopAdPolling(); if (pinPanel) pinPanel.style.display = 'none'; });
                        }
                    } else {
                        showNotification(j?.error || 'Failed to start AllDebrid PIN');
                    }
                } catch (_) {
                    showNotification('Failed to start AllDebrid PIN');
                }
            }

            // Attach scoped handlers to ALL duplicates
            document.querySelectorAll('#rdDeviceLogin').forEach(btn => {
                if (!btn.dataset.boundRd) { btn.dataset.boundRd = '1'; btn.addEventListener('click', () => beginRdDeviceLoginScoped(btn)); }
            });
            document.querySelectorAll('#adStartPin').forEach(btn => {
                if (!btn.dataset.boundAd) { btn.dataset.boundAd = '1'; btn.addEventListener('click', () => beginAdPinLoginScoped(btn)); }
            });
            // Attach to ALL duplicate AllDebrid Save buttons
            document.querySelectorAll('#adSaveApiKey').forEach(btn => btn.addEventListener('click', async () => {
                // Get visible adApiKey input
                const adApiKeyInputs = document.querySelectorAll('#adApiKey');
                let apikey = '';
                for (const input of adApiKeyInputs) {
                    if (input.offsetParent !== null) {
                        apikey = (input.value || '').trim();
                        break;
                    }
                }
                
                if (!apikey) { showNotification('Enter an AllDebrid API key'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Logged in';
                        });
                        showNotification('AllDebrid API key saved');
                        // Clear ALL adApiKey inputs
                        adApiKeyInputs.forEach(input => { input.value = ''; });
                    }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            }));
            // Attach to ALL duplicate AllDebrid Logout buttons
            document.querySelectorAll('#adClearApiKey').forEach(btn => btn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/ad/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey: '' }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Not logged in';
                        });
                        showNotification('Logged out of AllDebrid'); 
                    }
                } catch {}
            }));

            // TorBox: save/clear token
            // Attach to ALL duplicate TorBox Save buttons
            document.querySelectorAll('#tbSaveToken').forEach(btn => btn.addEventListener('click', async () => {
                // Get visible tbToken input
                const tbTokenInputs = document.querySelectorAll('#tbToken');
                let token = '';
                for (const input of tbTokenInputs) {
                    if (input.offsetParent !== null) {
                        token = (input.value || '').trim();
                        break;
                    }
                }
                
                if (!token) { showNotification('Enter a TorBox token'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/tb/token`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Logged in';
                        });
                        // Clear ALL tbToken inputs
                        tbTokenInputs.forEach(input => { input.value = ''; });
                        showNotification('TorBox token saved'); 
                        // Refresh TorBox status banner in Games Downloader
                        if (typeof checkTorBoxStatus === 'function') checkTorBoxStatus();
                    }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            }));
            // Attach to ALL duplicate TorBox Logout buttons
            document.querySelectorAll('#tbClearToken').forEach(btn => btn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/tb/token`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ token: '' }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Not logged in';
                        });
                        showNotification('Logged out of TorBox'); 
                        // Refresh TorBox status banner in Games Downloader
                        if (typeof checkTorBoxStatus === 'function') checkTorBoxStatus();
                    }
                } catch {}
            }));

            // Premiumize: save/clear API key
            // Attach to ALL duplicate Premiumize Save buttons
            document.querySelectorAll('#pmSaveApiKey').forEach(btn => btn.addEventListener('click', async () => {
                // Get visible pmApiKey input
                const pmApiKeyInputs = document.querySelectorAll('#pmApiKey');
                let apikey = '';
                for (const input of pmApiKeyInputs) {
                    if (input.offsetParent !== null) {
                        apikey = (input.value || '').trim();
                        break;
                    }
                }
                
                if (!apikey) { showNotification('Enter a Premiumize API key'); return; }
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/pm/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Logged in';
                        });
                        // Clear ALL pmApiKey inputs
                        pmApiKeyInputs.forEach(input => { input.value = ''; });
                        showNotification('Premiumize API key saved'); 
                    }
                    else { const t = await r.text(); showNotification(t || 'Failed to save'); }
                } catch { showNotification('Failed to save'); }
            }));
            // Attach to ALL duplicate Premiumize Logout buttons
            document.querySelectorAll('#pmClearApiKey').forEach(btn => btn.addEventListener('click', async () => {
                try {
                    const r = await fetch(`${API_BASE_URL}/debrid/pm/apikey`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apikey: '' }) });
                    if (r.ok) { 
                        // Update ALL debridStatus elements
                        document.querySelectorAll('#debridStatus').forEach(status => {
                            status.textContent = 'Not logged in';
                        });
                        showNotification('Logged out of Premiumize'); 
                    }
                } catch {}
            }));

            // ===== NodeMPV Player Toggle (Windows Only) =====
            document.querySelectorAll('#useNodeMPVToggle, #useNodeMPVToggleMain').forEach(toggle => {
                toggle.addEventListener('change', async (e) => {
                    try {
                        await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ useNodeMPV: e.target.checked })
                        });
                        // Sync all toggles (both in settings and in Nuvio section)
                        document.querySelectorAll('#useNodeMPVToggle, #useNodeMPVToggleMain').forEach(t => {
                            t.checked = e.target.checked;
                        });
                        showNotification(e.target.checked ? 'MPV Player enabled' : 'HTML5 Player enabled');
                    } catch (err) {
                        showNotification('Failed to save player setting');
                    }
                });
            });
            
            // MPV Path input and browse button
            const mpvPathInput = document.getElementById('mpvPathInput');
            const browseMpvPathBtn = document.getElementById('browseMpvPathBtn');
            
            // Load saved MPV path
            if (mpvPathInput) {
                fetch(`${API_BASE_URL}/settings`).then(r => r.json()).then(s => {
                    if (s.mpvPath) mpvPathInput.value = s.mpvPath;
                }).catch(() => {});
                
                // Save on blur
                mpvPathInput.addEventListener('blur', async () => {
                    try {
                        await fetch(`${API_BASE_URL}/settings`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ mpvPath: mpvPathInput.value.trim() || null })
                        });
                    } catch (err) {
                        console.warn('Failed to save MPV path:', err);
                    }
                });
                
                mpvPathInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') mpvPathInput.blur();
                });
            }
            
            // Browse button for MPV path
            if (browseMpvPathBtn) {
                browseMpvPathBtn.addEventListener('click', async () => {
                    if (window.electronAPI?.pickFile) {
                        const result = await window.electronAPI.pickFile({
                            filters: [{ name: 'Executable', extensions: ['exe'] }],
                            title: 'Select mpv.exe'
                        });
                        if (result && mpvPathInput) {
                            mpvPathInput.value = result;
                            // Save immediately
                            try {
                                await fetch(`${API_BASE_URL}/settings`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ mpvPath: result })
                                });
                                showNotification('MPV path saved');
                            } catch (err) {
                                showNotification('Failed to save MPV path');
                            }
                        }
                    } else {
                        showNotification('File browser not available');
                    }
                });
            }
            
            // Download MPV link - open in default browser
            const downloadMpvLink = document.getElementById('downloadMpvLink');
            if (downloadMpvLink) {
                downloadMpvLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    const mpvUrl = 'https://mpv.io/installation/';
                    if (window.electronAPI?.openExternal) {
                        window.electronAPI.openExternal(mpvUrl);
                    } else {
                        window.open(mpvUrl, '_blank');
                    }
                });
            }

            // ===== TORRENT ENGINE SETTINGS =====
            const torrentEngineSelect = document.getElementById('torrentEngineSelect');
            const engineInstancesContainer = document.getElementById('engineInstancesContainer');
            const engineInstancesSlider = document.getElementById('engineInstancesSlider');
            const engineInstanceLabel = document.getElementById('engineInstanceLabel');
            const engineDescription = document.getElementById('engineDescription');
            const engineStatus = document.getElementById('engineStatus');
            const engineStatusText = document.getElementById('engineStatusText');
            
            const engineDescriptions = {
                stremio: " Stremio's engine provides reliable streaming with built-in transcoding support.",
                webtorrent: " WebTorrent uses WebRTC for browser-compatible P2P streaming. Single instance only.",
                torrentstream: " TorrentStream is optimized for video streaming with multi-instance swarm support.",
                hybrid: " Combines WebTorrent and TorrentStream for maximum peer connectivity."
            };
            
            function updateEngineUI(engine, instances) {
                if (engineDescription) {
                    engineDescription.textContent = engineDescriptions[engine] || engineDescriptions.stremio;
                }
                if (engineInstancesContainer) {
                    // Show instances slider for non-stremio, non-webtorrent engines
                    engineInstancesContainer.style.display = (engine !== 'stremio' && engine !== 'webtorrent') ? 'block' : 'none';
                }
                if (engineInstanceLabel) {
                    engineInstanceLabel.textContent = instances;
                }
            }
            
            function showEngineStatus(message, isError = false) {
                if (engineStatus && engineStatusText) {
                    engineStatus.style.display = 'block';
                    engineStatus.style.background = isError ? 'rgba(239,68,68,0.1)' : 'rgba(34,197,94,0.1)';
                    engineStatusText.style.color = isError ? '#f87171' : '#4ade80';
                    engineStatusText.innerHTML = message;
                    // Hide after 3 seconds
                    setTimeout(() => { engineStatus.style.display = 'none'; }, 3000);
                }
            }
            
            // Load current engine config
            async function loadEngineConfig() {
                try {
                    const res = await fetch('/api/torrent-engine/config');
                    if (!res.ok) throw new Error('Failed to fetch config');
                    const config = await res.json();
                    console.log('[Engine] Loaded config:', config);
                    if (torrentEngineSelect) {
                        torrentEngineSelect.value = config.engine || 'stremio';
                    }
                    if (engineInstancesSlider) {
                        engineInstancesSlider.value = config.instances || 1;
                    }
                    updateEngineUI(config.engine || 'stremio', config.instances || 1);
                } catch (e) {
                    console.warn('[Engine] Failed to load config:', e);
                }
            }
            
            // Save engine config
            async function saveEngineConfig(engine, instances) {
                try {
                    console.log('[Engine] Saving config:', { engine, instances });
                    const res = await fetch('/api/torrent-engine/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ engine, instances })
                    });
                    if (!res.ok) {
                        const err = await res.json();
                        throw new Error(err.error || 'Failed to save');
                    }
                    const result = await res.json();
                    console.log('[Engine] Config saved:', result);
                    
                    const engineNames = {
                        stremio: 'Stremio Engine',
                        webtorrent: 'WebTorrent',
                        torrentstream: 'TorrentStream',
                        hybrid: 'Hybrid Mode'
                    };
                    showEngineStatus(`${engineNames[engine]} activated${instances > 1 ? ` with ${instances} instances` : ''}`);
                    showNotification(`Torrent engine: ${engineNames[engine]}${instances > 1 ? ` (${instances} instances)` : ''}`);
                } catch (e) {
                    console.error('[Engine] Failed to save config:', e);
                    showEngineStatus('Failed to change engine: ' + e.message, true);
                    showNotification('Failed to save engine config: ' + e.message);
                }
            }
            
            if (torrentEngineSelect) {
                torrentEngineSelect.addEventListener('change', async () => {
                    const engine = torrentEngineSelect.value;
                    const instances = parseInt(engineInstancesSlider?.value || 1);
                    updateEngineUI(engine, instances);
                    await saveEngineConfig(engine, instances);
                });
            }
            
            if (engineInstancesSlider) {
                engineInstancesSlider.addEventListener('input', () => {
                    if (engineInstanceLabel) {
                        engineInstanceLabel.textContent = engineInstancesSlider.value;
                    }
                });
                engineInstancesSlider.addEventListener('change', async () => {
                    const engine = torrentEngineSelect?.value || 'stremio';
                    const instances = parseInt(engineInstancesSlider.value);
                    await saveEngineConfig(engine, instances);
                });
            }
            
            // Load engine config on page load
            loadEngineConfig();

            // ===== FEBBOX TOKEN EVENT LISTENER =====
            
            // Febbox token (attach to ALL duplicate inputs/buttons)
            const febboxInputs = document.querySelectorAll('#febboxTokenInput');
            const savedFebboxToken = localStorage.getItem('febboxToken');
            if (savedFebboxToken) {
                febboxInputs.forEach(inp => { try { inp.value = savedFebboxToken; } catch(_){} });
            }
            const saveFebboxBtns = document.querySelectorAll('#saveFebboxToken');
            saveFebboxBtns.forEach(btn => btn.addEventListener('click', () => {
                // Prefer token from the input in the same card/section as the clicked button
                const scope = btn.closest('.settings-card-body, .api-input-group, .form-group') || document;
                let input = scope.querySelector('#febboxTokenInput');
                if (!input) {
                    // Fallback: use the visible input if any
                    for (const el of febboxInputs) { if (el.offsetParent !== null) { input = el; break; } }
                }
                const token = (input?.value || '').trim();
                if (token) {
                    localStorage.setItem('febboxToken', token);
                    // Reflect into all duplicate inputs for consistency
                    febboxInputs.forEach(inp => { try { inp.value = token; } catch(_){} });
                    showNotification('Febbox token saved successfully', 'success');
                } else {
                    localStorage.removeItem('febboxToken');
                    febboxInputs.forEach(inp => { try { inp.value = ''; } catch(_){} });
                    showNotification('Febbox token cleared, using default', 'success');
                }
            }));

            // ===== TRAKT EVENT LISTENERS - attach to ALL instances =====
            
            const traktLoginBtns = document.querySelectorAll('#traktLogin');
            const traktDisconnectBtns = document.querySelectorAll('#traktDisconnect');
            const traktCopyCodeBtns = document.querySelectorAll('#traktCopyCode');
            const traktOpenVerifyBtns = document.querySelectorAll('#traktOpenVerify');
            const traktCancelLoginBtns = document.querySelectorAll('#traktCancelLogin');
            
            traktLoginBtns.forEach(btn => btn.addEventListener('click', startTraktLogin));
            traktDisconnectBtns.forEach(btn => btn.addEventListener('click', disconnectTrakt));
            traktCopyCodeBtns.forEach(btn => btn.addEventListener('click', copyTraktCode));
            traktOpenVerifyBtns.forEach(btn => btn.addEventListener('click', openTraktVerify));
            traktCancelLoginBtns.forEach(btn => btn.addEventListener('click', cancelTraktLogin));
            
            const traktViewWatchlistBtns = document.querySelectorAll('#traktViewWatchlist');
            traktViewWatchlistBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/trakt/watchlist?type=mixed');
                    const data = await response.json();
                    
                    if (data.success && data.watchlist) {
                        showNotification(`Found ${data.watchlist.length} items in your watchlist`, 'info');
                        // TODO: Could open a modal to show watchlist items
                        console.log('[TRAKT] Watchlist:', data.watchlist);
                    } else {
                        showNotification('Failed to load watchlist', 'error');
                    }
                } catch (error) {
                    console.error('[TRAKT] Watchlist error:', error);
                    showNotification('Failed to load watchlist', 'error');
                }
                });
            });
            
            const traktViewHistoryBtns = document.querySelectorAll('#traktViewHistory');
            traktViewHistoryBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/trakt/history?type=mixed&limit=20');
                    const data = await response.json();
                    
                    if (data.success && data.history) {
                        showNotification(`Loaded ${data.history.length} recent items from your history`, 'info');
                        console.log('[TRAKT] History:', data.history);
                    } else {
                        showNotification('Failed to load history', 'error');
                    }
                } catch (error) {
                    console.error('[TRAKT] History error:', error);
                    showNotification('Failed to load history', 'error');
                }
                });
            });
            
            const traktViewStatsBtns = document.querySelectorAll('#traktViewStats');
            traktViewStatsBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/trakt/stats');
                    const data = await response.json();
                    
                    if (data.success && data.stats) {
                        const stats = data.stats;
                        const message = `Movies: ${stats.movies?.watched || 0} watched, Shows: ${stats.shows?.watched || 0} watched, Episodes: ${stats.episodes?.watched || 0} watched`;
                        showNotification(message, 'info', 5000);
                        console.log('[TRAKT] Stats:', stats);
                    } else {
                        showNotification('Failed to load stats', 'error');
                    }
                } catch (error) {
                    console.error('[TRAKT] Stats error:', error);
                    showNotification('Failed to load stats', 'error');
                }
                });
            });

            // ===== END TRAKT EVENT LISTENERS =====

            // Open Jackett installer link - REMOVED (button no longer exists)
            

            // Open Jackett video tutorial in default browser
            const jackettTutorialBtn = document.getElementById('jackettTutorialBtn');
            if (jackettTutorialBtn) {
                jackettTutorialBtn.addEventListener('click', async () => {
                    const url = 'https://www.youtube.com/watch?v=3igLReZFFzg&t';
                    if (window.electronAPI?.openExternal) {
                        const res = await window.electronAPI.openExternal(url);
                        if (!res?.success) {
                            showNotification('Failed to open browser. Copying link to clipboard.');
                            try { await navigator.clipboard.writeText(url); } catch {}
                        }
                    } else {
                        // Fallback: copy link if preload is unavailable
                        showNotification('Copying link to clipboard. Open it in your browser.');
                        try { await navigator.clipboard.writeText(url); } catch {}
                    }
                });
            }
            
            // Close modals on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    // Check in priority order and stop after handling one
                    if (mpvPlayerContainer.classList.contains('active')) {
                        e.preventDefault();
                        e.stopPropagation();
                        closePlayer(false); // Don't show notification when using Escape
                    }
                    else if (settingsModal.classList.contains('active')) {
                        e.preventDefault();
                        e.stopPropagation();
                        hideSettingsModal();
                    }
                    // API Setup Modal removed - no longer checking for it
                }
            });
            
            // Enter key for API inputs - REMOVED (firstTimeApiKey no longer exists)
            
            newApiKey.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveSettings_();
                }
            });

            // Search input
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter' && searchInput.value.trim() !== '') {
                    e.preventDefault();
                    const query = searchInput.value.trim();
                    // Navigate to home for search to display results clearly
                    if (activeRoute !== 'home') {
                        window.location.hash = '#/';
                    }
                    await searchMovies(query);
                }
            });
            
            // Back to Home button
            const backToHomeBtn = document.getElementById('backToHomeBtn');
            if (backToHomeBtn) {
                backToHomeBtn.querySelector('button').addEventListener('click', () => {
                    // Clear search input and search mode
                    searchInput.value = '';
                    isSearchMode = false;
                    lastSearchResults = [];
                    lastSearchQuery = '';
                    
                    // Reload home page with hero and sliders
                    backToHomeBtn.style.display = 'none';
                    if (document.body.classList.contains('ui-new')) {
                        const slidersContainer = document.getElementById('slidersContainer');
                        const heroSection = document.getElementById('heroSection');
                        if (slidersContainer) slidersContainer.style.display = 'block';
                        if (heroSection) heroSection.style.display = 'block';
                        moviesGrid.style.display = 'none';
                        moviesGrid.innerHTML = '';
                    }
                });
            }

            // Genres navigation
            genresBtn.addEventListener('click', () => {
                window.location.hash = '#/genres';
            });

            // Custom Magnet Modal - Close handlers only (open handled after nav setup)
            const customMagnetModal = document.getElementById('custom-magnet-modal');
            const closeCustomMagnetModal = document.getElementById('close-custom-magnet-modal');
            const cancelCustomMagnetBtn = document.getElementById('cancel-custom-magnet-btn');
            const playCustomMagnetBtn = document.getElementById('play-custom-magnet-btn');
            const customMagnetInput = document.getElementById('custom-magnet-input');

            if (closeCustomMagnetModal && customMagnetModal) {
                closeCustomMagnetModal.addEventListener('click', () => {
                    customMagnetModal.style.display = 'none';
                    customMagnetModal.classList.remove('active');
                    customMagnetModal.style.opacity = '0';
                    customMagnetModal.style.pointerEvents = 'none';
                });
            }

            if (cancelCustomMagnetBtn && customMagnetModal) {
                cancelCustomMagnetBtn.addEventListener('click', () => {
                    customMagnetModal.style.display = 'none';
                    customMagnetModal.classList.remove('active');
                    customMagnetModal.style.opacity = '0';
                    customMagnetModal.style.pointerEvents = 'none';
                });
            }

            if (playCustomMagnetBtn && customMagnetModal && customMagnetInput) {
                playCustomMagnetBtn.addEventListener('click', async () => {
                    const magnetLink = customMagnetInput.value.trim();
                    
                    if (!magnetLink) {
                        showNotification('Please enter a magnet link', 'warning');
                        return;
                    }
                    
                    if (!magnetLink.startsWith('magnet:')) {
                        showNotification('Invalid magnet link format', 'error');
                        return;
                    }
                    
                    // Close modal
                    customMagnetModal.style.display = 'none';
                    
                    // Use the existing startStream function which handles both debrid and non-debrid
                    try {
                        await startStream(magnetLink);
                    } catch (error) {
                        console.error('Error playing custom magnet:', error);
                        showNotification('Failed to play magnet link', 'error');
                    }
                });
            }

            // Close modal when clicking outside
            if (customMagnetModal) {
                customMagnetModal.addEventListener('click', (e) => {
                    if (e.target === customMagnetModal) {
                        customMagnetModal.style.display = 'none';
                        customMagnetModal.classList.remove('active');
                        customMagnetModal.style.opacity = '0';
                        customMagnetModal.style.pointerEvents = 'none';
                    }
                });
            }

            // My List navigation
            const myListBtn = document.getElementById('myListBtn');
            if (myListBtn) {
                myListBtn.addEventListener('click', () => {
                    window.location.hash = '#/my-list';
                });
            }

            // Done Watching navigation
            const doneWatchingBtn = document.getElementById('doneWatchingBtn');
            if (doneWatchingBtn) {
                doneWatchingBtn.addEventListener('click', () => {
                    window.location.hash = '#/done-watching';
                });
            }

            // Router: hash change
            window.addEventListener('hashchange', handleRoute);

            // Infinite scroll - performant listeners with rAF throttle and passive mode
            let __scrollScheduled = false;
            function __handleScrollRaf(e) {
                if (__scrollScheduled) return;
                __scrollScheduled = true;
                requestAnimationFrame(() => {
                    try { handleScroll(e); } finally { __scrollScheduled = false; }
                });
            }
            // Attach based on current UI mode to avoid duplicate listeners
            if (document.body.classList.contains('ui-new')) {
                const appMainElement = document.querySelector('.app-main main');
                if (appMainElement) appMainElement.addEventListener('scroll', __handleScrollRaf, { passive: true });
            } else {
                window.addEventListener('scroll', __handleScrollRaf, { passive: true });
            }
            
            // Modal close
            modalClose.addEventListener('click', closeModal);
            
            // Player close
            closePlayerBtn.addEventListener('click', closePlayer);
            
            // Custom Player close
            closeCustomPlayer.addEventListener('click', closeCustomPlayer_);
            
            // Watch now button
            watchNowBtn.addEventListener('click', (e) => {
                console.log('[DEBUG] Watch button clicked!');
                try {
                    const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
                    if (streamingMode && currentMediaType === 'movie') {
                        // Build mediaData for server selection
                        const mediaData = {
                            id: currentContent?.id,
                            type: 'movie',
                            title: currentContent?.title || currentContent?.name || 'Untitled',
                            subtitle: '',
                            year: (currentContent?.release_date || currentContent?.first_air_date || '').substring(0,4),
                            rating: Number(currentContent?.vote_average || 0).toFixed(1),
                            poster: currentContent?.poster_path ? `https://image.tmdb.org/t/p/w342${currentContent.poster_path}` : ''
                        };
                        showServerSelection(mediaData);
                    } else {
                        showTorrents(e);
                        // Auto-scroll to provider buttons for quick access
                        setTimeout(() => {
                            const pb = document.querySelector('.provider-buttons');
                            if (pb) pb.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 200);
                    }
                } catch (error) {
                    console.error('[DEBUG] Error in Watch Now handler:', error);
                }
            });

            // Toggle streaming mode from details modal
            const useStreamsBtn = document.getElementById('useStreamsBtn');
            if (useStreamsBtn) {
                useStreamsBtn.addEventListener('click', () => {
                    const current = localStorage.getItem('useStreamingServers') === 'true';
                    const next = !current;
                    localStorage.setItem('useStreamingServers', next ? 'true' : 'false');
                    // Sync settings toggles in the UI
                    const toggles = document.querySelectorAll('#useStreamingServersToggle');
                    toggles.forEach(t => t.checked = next);
                    // Update main button text and hint
                    updateWatchButtonText();
                    showNotification(`Streaming mode ${next ? 'enabled' : 'disabled'}`, next ? 'success' : 'info');
                });
            }
            
            // Watch Trailer button
            if (watchTrailerBtn) {
                watchTrailerBtn.addEventListener('click', async () => {
                    if (!currentContent) return;
                    
                    // Show trailer modal with loading state
                    trailerModal.classList.add('active');
                    trailerModalTitle.textContent = `${currentContent.title || currentContent.name || 'Trailer'} - Trailer`;
                    trailerPlaceholder.innerHTML = `
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                        <p>Loading trailer...</p>
                    `;
                    trailerPlaceholder.style.display = 'flex';
                    
                    // Remove any existing iframe
                    const existingIframe = trailerContainer.querySelector('iframe');
                    if (existingIframe) existingIframe.remove();
                    
                    try {
                        // Fetch videos from TMDB
                        const videosUrl = `https://api.themoviedb.org/3/${currentMediaType}/${currentContent.id}/videos?api_key=${TMDB_API_KEY}`;
                        const response = await fetch(videosUrl);
                        const data = await response.json();
                        const videos = data.results || [];
                        
                        // Find the best trailer (prefer official YouTube trailers)
                        const trailer = videos.find(v => 
                            v.site === 'YouTube' && 
                            v.type === 'Trailer' && 
                            v.official === true
                        ) || videos.find(v => 
                            v.site === 'YouTube' && 
                            v.type === 'Trailer'
                        ) || videos.find(v => 
                            v.site === 'YouTube' && 
                            (v.type === 'Teaser' || v.type === 'Clip')
                        );
                        
                        if (trailer) {
                            trailerPlaceholder.style.display = 'none';
                            const iframe = document.createElement('iframe');
                            iframe.style.cssText = 'width: 100%; height: 100%; border: 0;';
                            iframe.setAttribute('allowfullscreen', '');
                            iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                            iframe.src = `https://www.youtube.com/embed/${trailer.key}?autoplay=1&rel=0`;
                            trailerContainer.appendChild(iframe);
                        } else {
                            trailerPlaceholder.innerHTML = `
                                <i class="fas fa-film" style="font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.5;"></i>
                                <p>No trailer available</p>
                            `;
                        }
                    } catch (error) {
                        console.error('Error fetching trailer:', error);
                        trailerPlaceholder.innerHTML = `
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem; color: #ef4444;"></i>
                            <p>Failed to load trailer</p>
                        `;
                    }
                });
            }
            
            // Trailer modal close
            if (trailerModalClose) {
                trailerModalClose.addEventListener('click', () => {
                    trailerModal.classList.remove('active');
                    // Stop video playback
                    const iframe = trailerContainer.querySelector('iframe');
                    if (iframe) iframe.src = '';
                });
            }
            
            // Close trailer modal on backdrop click
            if (trailerModal) {
                trailerModal.addEventListener('click', (e) => {
                    if (e.target === trailerModal) {
                        trailerModal.classList.remove('active');
                        const iframe = trailerContainer.querySelector('iframe');
                        if (iframe) iframe.src = '';
                    }
                });
            }
            
            // Refresh torrents
            refreshTorrents.addEventListener('click', () => {
                torrentsLoaded = false;
                fetchTorrents(lastSearchedSeason, lastSearchedEpisode);
            });
            
            // Sort selector for torrents
            const torrentSortSelect = document.getElementById('torrentSortSelect');
            function handleSortChange() {
                const newMode = torrentSortSelect ? torrentSortSelect.value : 'seeders';
                console.log('[SORT] Changing from', torrentSortMode, 'to', newMode);
                torrentSortMode = newMode;
                try { if (typeof torrentsPage === 'number') torrentsPage = 1; } catch(_) {}
                
                // Re-render based on active provider
                if (selectedProvider === 'nuvio' && allNuvioStreams.length > 0) {
                    console.log('[SORT] Re-rendering Nuvio streams with mode:', torrentSortMode);
                    try { displayNuvioStreams(allNuvioStreams); } catch(_) {}
                } else if (selectedProvider === 'moviebox') {
                    console.log('[SORT] Skipping re-render for provider:', selectedProvider, '(sorting not supported)');
                    return;
                } else if (selectedProvider === '111477' && window._last111477Files) {
                    console.log('[SORT] Re-rendering 111477 files with mode:', torrentSortMode);
                    try { render111477Files(window._last111477Files); } catch(_) {}
                } else {
                    // Comet, Jackett, Torrentio, PlayTorrio all use standard torrent rendering
                    console.log('[SORT] Re-rendering torrents page with mode:', torrentSortMode);
                    try { renderTorrentsPage(); } catch(_) {}
                }
            }
            if (torrentSortSelect) {
                torrentSortSelect.addEventListener('change', handleSortChange);
                // Fire during selection as well for more immediate updates in some environments
                torrentSortSelect.addEventListener('input', handleSortChange);
            }

            // Size filter selector for torrents
            const torrentSizeFilterSelect = document.getElementById('torrentSizeFilterSelect');
            function handleSizeFilterChange() {
                torrentSizeFilter = (torrentSizeFilterSelect && torrentSizeFilterSelect.value) ? torrentSizeFilterSelect.value : 'all';
                console.log('[FILTER] Size filter changed to:', torrentSizeFilter);
                try { if (typeof torrentsPage === 'number') torrentsPage = 1; } catch(_) {}
                
                // Re-render based on active provider
                if (selectedProvider === 'nuvio' && allNuvioStreams.length > 0) {
                    console.log('[FILTER] Re-rendering Nuvio streams with filter:', torrentSizeFilter);
                    try { displayNuvioStreams(allNuvioStreams); } catch(_) {}
                } else if (selectedProvider === 'moviebox') {
                    console.log('[FILTER] Skipping re-render for provider:', selectedProvider, '(filtering not supported)');
                    return;
                } else if (selectedProvider === '111477' && window._last111477Files) {
                    console.log('[FILTER] Re-rendering 111477 files with filter:', torrentSizeFilter);
                    try { render111477Files(window._last111477Files); } catch(_) {}
                } else {
                    // Comet, Jackett, Torrentio, PlayTorrio all use standard torrent rendering
                    console.log('[FILTER] Re-rendering torrents page with filter:', torrentSizeFilter);
                    try { renderTorrentsPage(); } catch(_) {}
                }
            }
            if (torrentSizeFilterSelect) {
                torrentSizeFilterSelect.addEventListener('change', handleSizeFilterChange);
                // Fire during selection as well for more immediate updates in some environments
                torrentSizeFilterSelect.addEventListener('input', handleSizeFilterChange);
            }
            
            // Provider buttons
            document.querySelectorAll('.provider-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update active state
                    document.querySelectorAll('.provider-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update selected provider
                    selectedProvider = btn.dataset.provider;
                    console.log('[Provider] Switched to:', selectedProvider);

                    // Always show a searching indicator immediately
                    try {
                        const tl = document.getElementById('torrentsList');
                        if (tl) {
                            const label = selectedProvider === 'moviebox' ? 'MovieBox' :
                                          selectedProvider === 'nuvio' ? 'Nuvio' :
                                          selectedProvider === 'comet' ? 'Comet' :
                                          selectedProvider === '111477' ? '111477' : 'torrents';
                            tl.innerHTML = `<div class="loading"><i class="fas fa-spinner"></i> Searching ${label}...</div>`;
                        }
                    } catch(_) {}

                    // Fetch with new provider using last searched parameters; call MovieBox directly to avoid any gating
                    torrentsLoaded = false;
                    if (selectedProvider === 'moviebox') {
                        fetchMovieBoxStreams(lastSearchedSeason, lastSearchedEpisode);
                    } else {
                        fetchTorrents(lastSearchedSeason, lastSearchedEpisode);
                    }
                });
            });
            
            // Keyword filter for torrents
            if (torrentKeywordFilter) {
                torrentKeywordFilter.addEventListener('input', () => {
                    torrentsPage = 1; // Reset to first page when filtering
                    renderTorrentsPage();
                });
            }
            
            // MPV Controls
            // Resume modal elements
            const resumeModal = document.getElementById('resumeModal');
            const resumeClose = document.getElementById('resumeClose');
            const resumeTimeEl = document.getElementById('resumeTime');
            const resumeContinue = document.getElementById('resumeContinue');
            const resumeStartOver = document.getElementById('resumeStartOver');

            function formatResumeSeconds(s) { try { return formatTime(Math.floor(Number(s||0))); } catch(_) { return '00:00'; } }
            function hideResumeModal(){ resumeModal?.classList.remove('active'); }
            function showResumeModal(){ resumeModal?.classList.add('active'); }

            // Dismiss on outside click
            if (resumeModal) {
                resumeModal.addEventListener('click', (e) => {
                    if (e.target === resumeModal) {
                        hideResumeModal();
                    }
                });
                // prevent bubbling from content
                const rc = resumeModal.querySelector('.modal-content');
                if (rc) rc.addEventListener('click', (e) => e.stopPropagation());
            }

            // Robust Season/Episode parser for torrent filenames
            function parseSeasonEpisodeFromTitle(title) {
                if (!title || typeof title !== 'string') return null;
                const t = title.replace(/[_\.-]/g, ' ').toLowerCase();

                // Try common compact forms first: S01E01, S1E1, S01.E01, S01 E01
                let m = /\b[s](\d{1,2})\s*[\.\-\s_]*[e](\d{1,3})\b/i.exec(title);
                if (m) return { season: parseInt(m[1], 10), episode: parseInt(m[2], 10) };

                // Forms like S1 EP7 or S01 Ep 07
                m = /\b[s](\d{1,2})\s*[\.\-\s_]*(?:ep|episode)\s*(\d{1,3})\b/i.exec(title);
                if (m) return { season: parseInt(m[1], 10), episode: parseInt(m[2], 10) };

                // Bracketed forms like [S01E07] or (S01E07)
                m = /[\[(]\s*s?(\d{1,2})\s*[\.\-\s_]*e?(\d{1,3})\s*[\])]?/i.exec(title);
                if (m && m[1] && m[2]) return { season: parseInt(m[1], 10), episode: parseInt(m[2], 10) };

                // 1x07, 01x07 (with optional spaces)
                m = /(?:^|\D)(\d{1,2})\s*[x]\s*(\d{1,3})(?!\d)/i.exec(title);
                if (m) return { season: parseInt(m[1], 10), episode: parseInt(m[2], 10) };

                // Hyphenated season-episode inside brackets (e.g., [1-07])
                m = /[\[(]\s*(\d{1,2})\s*[-_]\s*(\d{1,3})\s*[\])]/i.exec(title);
                if (m) return { season: parseInt(m[1], 10), episode: parseInt(m[2], 10) };

                // Season 1 Episode 7 (various spacings) ('series' synonym)
                m = /(season|series)\s*(\d{1,2})\s*(?:episode|ep)\s*(\d{1,3})/i.exec(t);
                if (m) return { season: parseInt(m[2], 10), episode: parseInt(m[3], 10) };

                // Episode 7 Season 1 (reverse order) ('series' synonym)
                m = /(?:episode|ep)\s*(\d{1,3})\s*(season|series)\s*(\d{1,2})/i.exec(t);
                if (m) return { season: parseInt(m[3], 10), episode: parseInt(m[1], 10) };

                // S01 01 or S1 1 (space-separated)
                m = /\b[s](\d{1,2})\s+(\d{1,3})\b/i.exec(t);
                if (m) return { season: parseInt(m[1], 10), episode: parseInt(m[2], 10) };

                // If only episode is found, return partial; caller may fill season from UI state
                m = /\b(?:episode|ep)\s*(\d{1,3})\b/i.exec(t);
                if (m) return { season: undefined, episode: parseInt(m[1], 10) };

                return null;
            }

            async function handlePlayNowClick() {
                // Use integrated MPV player on all platforms
                if (!currentStreamUrl) {
                    showNotification('No file selected to play');
                    return;
                }
                
                try {
                    const tmdbId = currentContent?.id?.toString() || '';
                    let seasonNum = null;
                    let episodeNum = null;
                    
                    // For Nuvio provider, prefer UI-selected season/episode from modal state
                    if (currentMediaType === 'tv' && selectedProvider === 'nuvio') {
                        if (lastSearchedSeason && lastSearchedEpisode) {
                            seasonNum = String(lastSearchedSeason);
                            episodeNum = String(lastSearchedEpisode);
                        }
                    } else if (currentMediaType === 'tv' && currentSelectedVideoName) {
                        // Torrents: extract S/E from filename using robust parser
                        const se = parseSeasonEpisodeFromTitle(currentSelectedVideoName);
                        if (se) {
                            if (typeof se.season === 'number' && typeof se.episode === 'number') {
                                seasonNum = String(se.season);
                                episodeNum = String(se.episode);
                            } else if (typeof se.episode === 'number' && currentSeason) {
                                // Partial match: use UI's currentSeason if available
                                seasonNum = String(currentSeason);
                                episodeNum = String(se.episode);
                            }
                        }
                    }
                    
                    const result = await window.electronAPI.spawnMpvjsPlayer({
                        url: currentStreamUrl,
                        tmdbId: tmdbId,
                        seasonNum: seasonNum,
                        episodeNum: episodeNum,
                        isDebrid: useDebrid
                    });
                    
                    if (result.success) {
                        showNotification('Player launched');
                        return;
                    }
                    
                    // If MPV fails to launch, show the error message (e.g., installation instructions)
                    if (result.message) {
                        // Using alert or a custom large notification because the install commands might be long
                        alert(result.message);
                    } else {
                        showNotification('Failed to launch MPV player');
                    }
                } catch (err) {
                    console.error('[Play Now] Error:', err.message);
                    showNotification('Error launching player: ' + err.message);
                }
            }

            async function handleOpenMPVClick() {
                // Ensure we have latest resume info; fetch if not present
                let res = resumeInfo;
                if ((!res || typeof res.position !== 'number') && resumeKey) {
                    try { res = await fetchResume(resumeKey); } catch(_) {}
                }
                if (res && typeof res.position === 'number' && res.position > 0) {
                    resumeInfo = res;
                    resumeTimeEl.textContent = formatResumeSeconds(res.position);
                    showResumeModal();
                    const onCont = async () => {
                        // Immediately persist current resume snapshot for MPV continue
                        try {
                            if (resumeKey && resumeInfo && typeof resumeInfo.position === 'number') {
                                const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
                                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: Math.floor(resumeInfo.position || 0), duration: Math.floor(resumeInfo.duration || 0), title }) });
                            }
                        } catch(_) {}
                        hideResumeModal();
                        await openInMPV();
                        cleanup();
                    };
                    const onOver = async () => {
                        try { if (resumeKey) await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                        resumeInfo = null; // start from 0
                        hideResumeModal();
                        await openInMPV();
                        cleanup();
                    };
                    const cleanup = () => {
                        resumeContinue.removeEventListener('click', onCont);
                        resumeStartOver.removeEventListener('click', onOver);
                        resumeClose.removeEventListener('click', onClose);
                        document.removeEventListener('keydown', onEsc);
                    };
                    const onClose = () => { hideResumeModal(); cleanup(); };
                    const onEsc = (e) => { if (e.key === 'Escape') { hideResumeModal(); cleanup(); } };
                    resumeContinue.addEventListener('click', onCont);
                    resumeStartOver.addEventListener('click', onOver);
                    resumeClose.addEventListener('click', onClose);
                    document.addEventListener('keydown', onEsc);
                    return;
                }
                await openInMPV();
            }

            openMPVBtn.addEventListener('click', handleOpenMPVClick);
            // Mirror resume prompt flow for VLC
            async function handleOpenVLCClick() {
                let res = resumeInfo;
                if ((!res || typeof res.position !== 'number') && resumeKey) {
                    try { res = await fetchResume(resumeKey); } catch(_) {}
                }
                if (res && typeof res.position === 'number' && res.position > 0) {
                    resumeInfo = res;
                    resumeTimeEl.textContent = formatResumeSeconds(res.position);
                    showResumeModal();
                    const onCont = async () => {
                        try {
                            if (resumeKey && resumeInfo && typeof resumeInfo.position === 'number') {
                                const title = currentSelectedVideoName || (currentContent?.title || currentContent?.name || '');
                                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: resumeKey, position: Math.floor(resumeInfo.position || 0), duration: Math.floor(resumeInfo.duration || 0), title }) });
                            }
                        } catch(_) {}
                        hideResumeModal();
                        await openInVLC();
                        cleanup();
                    };
                    const onOver = async () => {
                        try { if (resumeKey) await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                        resumeInfo = null;
                        hideResumeModal();
                        await openInVLC();
                        cleanup();
                    };
                    const cleanup = () => {
                        resumeContinue.removeEventListener('click', onCont);
                        resumeStartOver.removeEventListener('click', onOver);
                        resumeClose.removeEventListener('click', onClose);
                        document.removeEventListener('keydown', onEsc);
                    };
                    const onClose = () => { hideResumeModal(); cleanup(); };
                    const onEsc = (e) => { if (e.key === 'Escape') { hideResumeModal(); cleanup(); } };
                    resumeContinue.addEventListener('click', onCont);
                    resumeStartOver.addEventListener('click', onOver);
                    resumeClose.addEventListener('click', onClose);
                    document.addEventListener('keydown', onEsc);
                    return;
                }
                await openInVLC();
            }

            // Platform detection - hide VLC buttons on macOS
            let isMacOS = false;
            (async () => {
                try {
                    const platformInfo = await window.electron.invoke('get-platform');
                    isMacOS = platformInfo.isMac;
                    if (isMacOS) {
                        // Hide all VLC buttons on macOS since VLC is not included
                        const hideAllVLCButtons = () => {
                            const vlcButtons = document.querySelectorAll('#openVLCBtn, .vlc-nuvio-btn, [class*="vlc"][class*="btn"]');
                            vlcButtons.forEach(btn => {
                                if (btn && btn.textContent && btn.textContent.includes('VLC')) {
                                    btn.style.display = 'none';
                                }
                            });
                        };
                        hideAllVLCButtons();
                        // Re-run after DOM updates (for dynamically added buttons)
                        setInterval(hideAllVLCButtons, 2000);
                        console.log('[Platform] VLC buttons hidden on macOS');
                    }
                } catch (err) {
                    console.error('[Platform] Failed to get platform info:', err);
                }
            })();

            if (openVLCBtn) openVLCBtn.addEventListener('click', handleOpenVLCClick);
            copyStreamBtn.addEventListener('click', copyStreamUrl);
            playNowBtn.addEventListener('click', handlePlayNowClick);
            
            // Chromecast button (in MPV controls) - uses backend catt
            const castToChromecastBtn = document.getElementById('castToChromecastBtn');
            if (castToChromecastBtn) {
                castToChromecastBtn.addEventListener('click', castMPVToChromecast);
            }
            
            // Custom Player Controls
            playPauseBtn.addEventListener('click', togglePlayPause);
            rewindBtn.addEventListener('click', () => skipTime(-10));
            forwardBtn.addEventListener('click', () => skipTime(10));
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // Cast button (in custom player controls) - uses Google Cast SDK
            const castBtn = document.getElementById('castBtn');
            if (castBtn) {
                castBtn.addEventListener('click', castToChromecast);
            }
            
            progressBar.addEventListener('click', seekVideo);
            subtitleFile.addEventListener('change', handleSubtitleUpload);
            // HTML5 audio controls
            htmlVolume.addEventListener('input', () => { customVideo.volume = Math.max(0, Math.min(1, Number(htmlVolume.value) / 100)); });
            htmlMuteBtn.addEventListener('click', () => { customVideo.muted = !customVideo.muted; htmlMuteBtn.innerHTML = customVideo.muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>'; });
            // HTML5 Subtitles menu
            htmlSubsBtn.addEventListener('click', () => {
                if (htmlSubsPanel.style.display === 'block') htmlSubsPanel.style.display = 'none';
                else { 
                    htmlSubsPanel.style.display = 'block'; 
                    fetchAndRenderHtmlSubs();
                    updateSubtitleControlDisplays();
                }
            });
            htmlSubsClose.addEventListener('click', () => htmlSubsPanel.style.display = 'none');
            
            // Subtitle customization controls
            if (htmlSubsUploadBtn && subtitleFile) {
                htmlSubsUploadBtn.addEventListener('click', () => subtitleFile.click());
            }
            
            if (subsSizeInput) {
                subsSizeInput.addEventListener('input', () => {
                    subtitleSettings.size = Number(subsSizeInput.value);
                    updateSubtitleControlDisplays();
                    applySubtitleSettings();
                });
            }
            
            if (subsColorInput) {
                subsColorInput.addEventListener('input', () => {
                    subtitleSettings.color = subsColorInput.value;
                    applySubtitleSettings();
                });
            }
            
            if (subsBackgroundInput) {
                subsBackgroundInput.addEventListener('input', () => {
                    subtitleSettings.background = subsBackgroundInput.value;
                    applySubtitleSettings();
                });
            }
            
            if (subsBackgroundOpacityInput) {
                subsBackgroundOpacityInput.addEventListener('input', () => {
                    subtitleSettings.backgroundOpacity = Number(subsBackgroundOpacityInput.value);
                    updateSubtitleControlDisplays();
                    applySubtitleSettings();
                });
            }
            
            if (subsFontSelect) {
                subsFontSelect.addEventListener('change', () => {
                    subtitleSettings.font = subsFontSelect.value;
                    applySubtitleSettings();
                });
            }
            
            // WCJS Controls
            closeWcjsPlayer.addEventListener('click', closeWCJSPlayer);
            wcjsPlayPauseBtn.addEventListener('click', wcjsTogglePlayPause);
            wcjsRewindBtn.addEventListener('click', () => wcjsSkipTime(-10));
            wcjsForwardBtn.addEventListener('click', () => wcjsSkipTime(10));
            wcjsFullscreenBtn.addEventListener('click', wcjsToggleFullscreen);
            wcjsProgressBar.addEventListener('click', wcjsSeek);
            wcjsMuteBtn.addEventListener('click', wcjsToggleMute);
            wcjsVolume.addEventListener('input', wcjsSetVolume);
            wcjsSubtitleFile.addEventListener('change', wcjsHandleSubtitleUpload);
            wcjsSubsBtn.addEventListener('click', () => {
                if (wcjsSubsPanel.style.display === 'block') wcjsSubsPanel.style.display = 'none';
                else { wcjsSubsPanel.style.display = 'block'; wcjsAudioPanel.style.display = 'none'; fetchAndRenderSubtitles(); }
            });
            wcjsAudioBtn.addEventListener('click', () => {
                if (wcjsAudioPanel.style.display === 'block') wcjsAudioPanel.style.display = 'none';
                else { wcjsAudioPanel.style.display = 'block'; wcjsSubsPanel.style.display = 'none'; renderAudioTracks(); }
            });
            wcjsSubsRefresh.addEventListener('click', fetchAndRenderSubtitles);
            wcjsSubsClose.addEventListener('click', () => wcjsSubsPanel.style.display = 'none');
            wcjsAudioClose.addEventListener('click', () => wcjsAudioPanel.style.display = 'none');
            
          
            customVideo.addEventListener('loadstart', () => {
                loadingOverlay.style.display = 'flex';
            });
            
            customVideo.addEventListener('canplay', () => {
                loadingOverlay.style.display = 'none';
            });
            
            customVideo.addEventListener('timeupdate', updateProgress);
            customVideo.addEventListener('loadedmetadata', updateDuration);
            customVideo.addEventListener('play', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                
                // Start Trakt scrobbling when video plays
                if (currentStreamTitle && traktAutoScrobbleToggle.checked) {
                    const progress = customVideo.currentTime / customVideo.duration * 100;
                    const { title, type, year, season, episode } = parseMediaTitle(currentStreamTitle);
                    scrobbleStart(title, type, year, season, episode, Math.floor(progress));
                }
            });
            customVideo.addEventListener('pause', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                
                // Pause Trakt scrobbling when video pauses
                if (customVideo.duration && traktScrobbleProgressToggle.checked) {
                    const progress = customVideo.currentTime / customVideo.duration * 100;
                    scrobblePause(Math.floor(progress));
                }
            });
            customVideo.addEventListener('ended', () => {
                // Stop Trakt scrobbling when video ends
                if (customVideo.duration) {
                    scrobbleStop(100); // 100% watched
                }
            });
            
           
            detailsModal.addEventListener('click', (e) => {
                if (e.target === detailsModal) {
                    closeModal();
                }
            });
            
 

            customPlayerContainer.addEventListener('click', (e) => {
                if (e.target === customPlayerContainer) {
                    closeCustomPlayer_();
                }
            });

          
            wcjsPlayerContainer.addEventListener('click', (e) => {
                if (e.target === wcjsPlayerContainer) {
                    closeWCJSPlayer();
                }
            });

            // Close settings modal when clicking outside
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    hideSettingsModal();
                }
            });

            // Category filtering (home)
            document.querySelectorAll('.category').forEach(category => {
                category.addEventListener('click', () => {
                    document.querySelectorAll('.category').forEach(c => c.classList.remove('active'));
                    category.classList.add('active');
                    currentCategory = category.dataset.category;
                    
                    // For new UI, check if in search mode
                    if (document.body.classList.contains('ui-new')) {
                        const slidersContainer = document.getElementById('slidersContainer');
                        const heroSection = document.getElementById('heroSection');
                        const backBtn = document.getElementById('backToHomeBtn');
                        
                        if (isSearchMode) {
                            // Filter search results by category
                            moviesGrid.innerHTML = '';
                            let filteredResults = lastSearchResults;
                            
                            if (currentCategory === 'movie') {
                                filteredResults = lastSearchResults.filter(item => item.media_type === 'movie');
                            } else if (currentCategory === 'tv') {
                                filteredResults = lastSearchResults.filter(item => item.media_type === 'tv');
                            }
                            // 'all' shows everything
                            
                            displayMovies(filteredResults);
                        } else if (currentCategory === 'all') {
                            // Show sliders for "All"
                            if (slidersContainer) slidersContainer.style.display = 'block';
                            if (heroSection) heroSection.style.display = 'block';
                            if (backBtn) backBtn.style.display = 'none';
                            moviesGrid.style.display = 'none';
                            moviesGrid.innerHTML = '';
                        } else {
                            // Show grid for Movies/TV
                            if (slidersContainer) slidersContainer.style.display = 'none';
                            if (heroSection) heroSection.style.display = 'none';
                            if (backBtn) backBtn.style.display = 'none';
                            moviesGrid.style.display = 'grid';
                            moviesGrid.innerHTML = '';
                            currentPage = 1;
                            loadMovies(currentCategory);
                        }
                    } else {
                        // Old UI behavior
                        moviesGrid.innerHTML = '';
                        currentPage = 1;
                        loadMovies(currentCategory);
                    }
                });
            });

            // Toggle buttons on genre details
            toggleMoviesBtn.addEventListener('click', () => {
                if (currentGenreType !== 'movie') {
                    setGenreType('movie');
                }
            });
            toggleTVBtn.addEventListener('click', () => {
                if (currentGenreType !== 'tv') {
                    setGenreType('tv');
                }
            });

            // Keyboard shortcuts for custom player
            document.addEventListener('keydown', (e) => {
                if (customPlayerContainer.classList.contains('active')) {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            togglePlayPause();
                            break;
                        case 'ArrowRight':
                            skipTime(10);
                            break;
                        case 'ArrowLeft':
                            skipTime(-10);
                            break;
                        case 'KeyF':
                            toggleFullscreen();
                            break;
                        case 'Escape':
                            closeCustomPlayer_();
                            break;
                    }
                } else if (wcjsPlayerContainer.classList.contains('active')) {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            wcjsTogglePlayPause();
                            break;
                        case 'ArrowRight':
                            wcjsSkipTime(10);
                            break;
                        case 'ArrowLeft':
                            wcjsSkipTime(-10);
                            break;
                        case 'KeyF':
                            wcjsToggleFullscreen();
                            break;
                        case 'Escape':
                            closeWCJSPlayer();
                            break;
                    }
                }
            });
            
            // Logo click handlers - navigate to home
            const sidebarLogo = document.getElementById('sidebarLogo');
            if (sidebarLogo) {
                sidebarLogo.addEventListener('click', () => {
                    window.location.href = 'http://localhost:6987';
                });
            }
            
            // Header logo click (for both OLD and NEW UI)
            const headerLogo = document.querySelector('.logo');
            if (headerLogo) {
                headerLogo.addEventListener('click', (e) => {
                    e.preventDefault();
                    window.location.href = 'http://localhost:6987';
                });
            }
            
            // Sidebar navigation for new UI
            const sidebarNavItems = document.querySelectorAll('.nav-item[data-page]');
            sidebarNavItems.forEach(item => {
                item.addEventListener('click', () => {
                    const page = item.dataset.page;
                    sidebarNavItems.forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    
                    if (page === 'home') {
                        showHomePage();
                    } else if (page === 'genres') {
                        showGenresPage();
                    } else if (page === 'my-list') {
                        showMyListPage();
                    } else if (page === 'done-watching') {
                        showDoneWatchingPage();
                    } else if (page === 'trakt') {
                        showTraktPage();
                    } else if (page === 'livetv') {
                        showLiveTvPage();
                    } else if (page === 'iptv') {
                        showIptvPage();
                    } else if (page === 'games-downloader') {
                        showGamesDownloaderPage();
                    } else if (page === 'minigames') {
                        showMiniGamesPage();
                    } else if (page === 'books') {
                        showBooksPage();
                    } else if (page === 'audiobooks') {
                        showAudioBooksPage();
                    } else if (page === 'music') {
                        showMusicPage();
                    } else if (page === 'booktorrio') {
                        showBookTorrioPage();
                    } else if (page === 'anime') {
                        showAnimePage();
                    } else if (page === 'comics') {
                        showComicsPage();
                    } else if (page === 'manga') {
                        showMangaPage();
                    } else if (page === 'downloader') {
                        showDownloaderPage();
                    }
                });
            });
            
            // Custom Magnet button (separate from data-page navigation)
            const customMagnetNavBtn = document.getElementById('customMagnetBtn');
            const customMagnetModalElem = document.getElementById('custom-magnet-modal');
            const customMagnetInputElem = document.getElementById('custom-magnet-input');
            if (customMagnetNavBtn && customMagnetModalElem) {
                customMagnetNavBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Custom Magnet nav button clicked!');
                    customMagnetModalElem.style.display = 'flex';
                    if (customMagnetInputElem) {
                        customMagnetInputElem.value = '';
                        setTimeout(() => customMagnetInputElem.focus(), 100);
                    }
                });
            }
            
            // Sidebar clear cache
            const sidebarClearCache = document.getElementById('sidebarClearCache');
            if (sidebarClearCache) {
                sidebarClearCache.addEventListener('click', async () => {
                    const result = await window.electronAPI.clearCache();
                    showNotification(result.message, result.success ? 'success' : 'error');
                });
            }
            
            // Sidebar settings
            const sidebarSettings = document.getElementById('sidebarSettings');
            if (sidebarSettings) {
                sidebarSettings.addEventListener('click', showSettingsModal);
            }

            // Floating navigation (Old UI)
            const floatingNavContainer = document.getElementById('floatingNavContainer');
            const floatingNavBtn = document.getElementById('floatingNavBtn');
            const floatingNavMenu = document.getElementById('floatingNavMenu');
            
            if (floatingNavBtn) {
                floatingNavBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    floatingNavContainer.classList.toggle('active');
                });
            }

            // Handle floating nav menu item clicks
            if (floatingNavMenu) {
                floatingNavMenu.addEventListener('click', (e) => {
                    const item = e.target.closest('.floating-nav-item');
                    if (item) {
                        const action = item.getAttribute('data-action');
                        floatingNavContainer.classList.remove('active');
                        
                        switch (action) {
                            case 'settings':
                                showSettingsModal();
                                break;
                            case 'home':
                                showHomePage();
                                break;
                            case 'genres':
                                showGenresPage();
                                break;
                            case 'my-list':
                                showMyListPage();
                                break;
                            case 'done-watching':
                                showDoneWatchingPage();
                                break;
                            case 'livetv':
                                showLiveTvPage();
                                break;
                            case 'iptv':
                                showIptvPage();
                                break;
                            case 'games-downloader':
                                showGamesDownloaderPage();
                                break;
                            case 'minigames':
                                showMiniGamesPage();
                                break;
                            case 'music':
                                showMusicPage();
                                break;
                            case 'books':
                                showBooksPage();
                                break;
                            case 'audiobooks':
                                showAudioBooksPage();
                                break;
                            case 'booktorrio':
                                showBookTorrioPage();
                                break;
                            case 'anime':
                                showAnimePage();
                                break;
                            case 'comics':
                                showComicsPage();
                                break;
                            case 'manga':
                                showMangaPage();
                                break;
                            case 'downloader':
                                showDownloaderPage();
                                break;
                            case 'trakt':
                                showTraktPage();
                                break;
                        }
                    }
                });
            }

            // Close floating nav when clicking outside
            document.addEventListener('click', (e) => {
                if (floatingNavContainer && !floatingNavContainer.contains(e.target)) {
                    floatingNavContainer.classList.remove('active');
                }
            });

            // Books Functionality
            let booksSearchResults = [];
            let booksCurrentPage = 1;
            let booksIsLoading = false;
            let booksHasMore = true;
            let booksCurrentQuery = '';
            
            // Books search input and button
            const booksSearchInput = document.getElementById('books-search-input');
            const booksSearchBtn = document.getElementById('books-search-btn');
            const booksLoading = document.getElementById('books-loading');
            const booksEmpty = document.getElementById('books-empty');
            const booksResults = document.getElementById('books-results');
            const booksResultsGrid = document.getElementById('books-results-grid');
            const booksResultsTitle = document.getElementById('books-results-title');
            const booksResultsCount = document.getElementById('books-results-count');
            
            // Books reader modal
            const booksReaderModal = document.getElementById('books-reader-modal');
            const booksReaderBack = document.getElementById('books-reader-back');
            const booksReaderTitle = document.getElementById('books-reader-title');
            const booksReaderFrame = document.getElementById('books-reader-frame');

            // Initialize/Reset books page
            async function startBooks() {
                booksCurrentPage = 1;
                booksHasMore = true;
                booksCurrentQuery = '';
                booksSearchResults = [];
                booksResultsGrid.innerHTML = '';
                booksEmpty.style.display = 'none';
                booksResults.style.display = 'none';
                booksLoading.style.display = 'block';
                
                // Load popular books by default
                await loadBooks(1);
            }

            function getSavedBooks() {
                try {
                    return JSON.parse(localStorage.getItem('zlib_saved_books') || '[]');
                } catch (e) {
                    return [];
                }
            }

            function saveBook(book) {
                const saved = getSavedBooks();
                // Avoid duplicates based on URL
                if (!saved.some(b => (b.url || b.bookUrl) === (book.url || book.bookUrl))) {
                    saved.push(book);
                    localStorage.setItem('zlib_saved_books', JSON.stringify(saved));
                    showNotification('Book saved to library', 'success');
                }
            }

            function removeBook(bookUrl) {
                let saved = getSavedBooks();
                saved = saved.filter(b => (b.url || b.bookUrl) !== bookUrl);
                localStorage.setItem('zlib_saved_books', JSON.stringify(saved));
                showNotification('Book removed from library', 'info');
            }

            function isBookSaved(bookUrl) {
                const saved = getSavedBooks();
                return saved.some(b => (b.url || b.bookUrl) === bookUrl);
            }

            async function loadBooks(page = 1, append = false) {
                if (booksIsLoading) return;
                booksIsLoading = true;
                if (!append) {
                    booksLoading.style.display = 'block';
                    if (page === 1) booksResultsGrid.innerHTML = '';
                }

                try {
                    let url;
                    // Using new API endpoints
                    const booksBase = 'http://localhost:6987/api/zlib'; 

                    if (booksCurrentQuery) {
                         // Search mode (no pagination support in backend for search yet, so we only load page 1)
                         if (page > 1) {
                             booksIsLoading = false;
                             return; 
                         }
                         url = `${booksBase}/search/${encodeURIComponent(booksCurrentQuery)}`;
                    } else {
                        // Popular/All mode (supports pagination)
                        url = `${booksBase}/all?page=${page}`;
                    }
                    
                    console.log(`[BOOKS] Fetching: ${url}`);
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    let items = [];
                    
                    if (booksCurrentQuery) {
                        // Search returns { success: 1, books: [...] }
                        items = data.books || [];
                        booksHasMore = false; // Disable infinite scroll for search for now
                    } else {
                        // All/Popular returns [ ... ] or { books: [...] }
                        if (Array.isArray(data)) {
                            items = data;
                        } else if (data.books && Array.isArray(data.books)) {
                            items = data.books;
                        } else if (data.mostPopular && Array.isArray(data.mostPopular)) {
                             items = data.mostPopular;
                        }
                        
                        // If we got items, assume there might be more pages
                        booksHasMore = items.length > 0;
                    }
                    
                    if (append) {
                        booksSearchResults = [...booksSearchResults, ...items];
                    } else {
                        booksSearchResults = items;
                    }
                    
                    displayBooksResults(items, append);
                    
                } catch (error) {
                    console.error('[BOOKS] Error loading books:', error);
                    if (!append) {
                        booksResults.style.display = 'none';
                        booksEmpty.style.display = 'block';
                        booksEmpty.innerHTML = `<div class="books-empty-icon"><i class="fas fa-exclamation-triangle"></i></div><h3>Error Loading Books</h3><p>${error.message}</p>`;
                    }
                } finally {
                    booksIsLoading = false;
                    booksLoading.style.display = 'none';
                }
            }

            async function loadMoreBooks() {
                if (booksIsLoading || !booksHasMore || booksCurrentQuery) return; // Disable infinite scroll for search
                booksCurrentPage++;
                await loadBooks(booksCurrentPage, true);
            }
            
            // Search functionality
            async function searchBooks(query) {
                if (!query || query.trim().length === 0) {
                    showNotification('Please enter a search term', 'warning');
                    return;
                }
                
                booksCurrentQuery = query.trim();
                booksCurrentPage = 1;
                booksHasMore = true; 
                
                await loadBooks(1, false);
            }
            
            function displayBooksResults(books, append) {
                if (!append) {
                    booksResultsTitle.textContent = booksCurrentQuery ? `Search Results for "${booksCurrentQuery}"` : 'Most Popular Books';
                    booksResultsCount.textContent = ''; 
                    booksResultsGrid.innerHTML = '';
                }

                if (books.length === 0 && !append) {
                     booksResults.style.display = 'none';
                     booksEmpty.style.display = 'block';
                     booksEmpty.innerHTML = `
                        <div class="books-empty-icon">
                            <i class="fas fa-search"></i>
                        </div>
                        <h3>No Books Found</h3>
                        <p>${booksCurrentQuery ? `No results found for "${booksCurrentQuery}"` : 'No popular books found at the moment.'}</p>
                     `;
                     return;
                }
                
                booksEmpty.style.display = 'none';
                booksResults.style.display = 'block';
                
                books.forEach(book => {
                    const bookCard = document.createElement('div');
                    bookCard.className = 'books-book-card';
                    
                    const cover = book.cover || book.photo || '';
                    const title = book.title || 'Unknown Title';
                    const author = book.author || 'Unknown Author';
                    const format = book.extension || book.format || 'EPUB';
                    const bookUrl = book.url || book.bookUrl; 
                    
                    // Add styles for save button if not present
                    if (!document.getElementById('zlib-save-btn-style')) {
                        const style = document.createElement('style');
                        style.id = 'zlib-save-btn-style';
                        style.textContent = `
                            .books-save-btn {
                                position: absolute;
                                top: 5px;
                                right: 5px;
                                width: 32px;
                                height: 32px;
                                border-radius: 50%;
                                background: rgba(0, 0, 0, 0.6);
                                color: white;
                                border: none;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                cursor: pointer;
                                transition: all 0.2s;
                                z-index: 10;
                            }
                            .books-save-btn:hover {
                                background: #2ecc71;
                                transform: scale(1.1);
                            }
                        `;
                        document.head.appendChild(style);
                    }

                    const isSaved = isBookSaved(bookUrl);

                    bookCard.innerHTML = `
                        <div class="books-book-cover">
                            <img loading="lazy" src="${cover}" alt="${title}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="books-book-cover-placeholder" style="display: none;">
                                <i class="fas fa-book"></i>
                            </div>
                            <div class="books-book-format">${format}</div>
                            <button class="books-save-btn" data-book='${JSON.stringify(book).replace(/'/g, "&apos;")}' title="${isSaved ? 'Remove from Saved' : 'Save Book'}">
                                <i class="fas ${isSaved ? 'fa-check' : 'fa-plus'}"></i>
                            </button>
                        </div>
                        <div class="books-book-info">
                            <h3 class="books-book-title">${title}</h3>
                            <p class="books-book-author">by ${author}</p>
                            <div class="books-book-actions">
                                <button class="books-read-btn" data-book-path="${bookUrl}" data-title="${title}">
                                    <i class="fas fa-book-open"></i>
                                    Read Now
                                </button>
                            </div>
                        </div>
                    `;
                    
                    booksResultsGrid.appendChild(bookCard);

                    // Save button listener
                    const saveBtn = bookCard.querySelector('.books-save-btn');
                    saveBtn.addEventListener('click', (e) => {
                         e.stopPropagation();
                         const btn = e.currentTarget;
                         const bookData = JSON.parse(btn.getAttribute('data-book'));
                         const bUrl = bookData.url || bookData.bookUrl;
                         
                         if (isBookSaved(bUrl)) {
                             removeBook(bUrl);
                             btn.innerHTML = '<i class="fas fa-plus"></i>';
                             btn.title = 'Save Book';
                             
                             // If viewing saved books, remove the card
                             if (booksCurrentQuery === '__saved__') {
                                 bookCard.remove();
                                 // Check if grid is empty
                                 if (booksResultsGrid.children.length === 0) {
                                     booksResults.style.display = 'none';
                                     booksEmpty.style.display = 'block';
                                     booksEmpty.innerHTML = `
                                        <div class="books-empty-icon"><i class="fas fa-bookmark"></i></div>
                                        <h3>No Saved Books</h3>
                                        <p>You haven't saved any books yet.</p>
                                     `;
                                 }
                             }
                         } else {
                             saveBook(bookData);
                             btn.innerHTML = '<i class="fas fa-check"></i>';
                             btn.title = 'Remove from Saved';
                         }
                    });
                    
                    // Attach event listener immediately
                    const readBtn = bookCard.querySelector('.books-read-btn');
                    readBtn.addEventListener('click', async (e) => {
                        const btn = e.currentTarget;
                        const path = btn.getAttribute('data-book-path');
                        const title = btn.getAttribute('data-title');
                        
                        if (!path) return;
                        
                        const originalText = btn.innerHTML;
                        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Opening...';
                        btn.disabled = true;
                        
                        try {
                            const booksBase = 'http://localhost:6987/api/zlib'; 
                            const resp = await fetch(`${booksBase}/read-link?path=${encodeURIComponent(path)}`);
                            const json = await resp.json();
                            
                            if (json.success && json.readLink) {
                                if (window.electronAPI?.openExternal) {
                                    window.electronAPI.openExternal(json.readLink);
                                    showNotification(`Opening "${title}"...`, 'success');
                                } else {
                                     window.open(json.readLink, '_blank');
                                }
                            } else {
                                showNotification('Could not find read link for this book', 'error');
                            }
                        } catch (err) {
                            console.error(err);
                            showNotification('Failed to fetch read link', 'error');
                        } finally {
                            btn.innerHTML = originalText;
                            btn.disabled = false;
                        }
                    });
                });
            }

            // Music Functionality
            let musicResultsCache = [];
            const musicSearchInput = document.getElementById('music-search-input');
            const musicSearchBtn = document.getElementById('music-search-btn');

            // Wire up Books search
            const booksSavedBtn = document.getElementById('books-saved-btn');
            
            if (booksSavedBtn) {
                booksSavedBtn.addEventListener('click', () => {
                     booksCurrentQuery = '__saved__';
                     booksResultsTitle.textContent = 'My Saved Books';
                     booksResultsCount.textContent = '';
                     
                     const savedBooks = getSavedBooks();
                     
                     if (savedBooks.length === 0) {
                         booksResults.style.display = 'none';
                         booksEmpty.style.display = 'block';
                         booksEmpty.innerHTML = `
                            <div class="books-empty-icon"><i class="fas fa-bookmark"></i></div>
                            <h3>No Saved Books</h3>
                            <p>You haven't saved any books yet.</p>
                         `;
                         booksResultsGrid.innerHTML = '';
                         return;
                     }
                     
                     booksResultsGrid.innerHTML = '';
                     displayBooksResults(savedBooks, false);
                });
            }

            if (booksSearchBtn) {
                booksSearchBtn.addEventListener('click', () => {
                    searchBooks(booksSearchInput.value);
                });
            }
            if (booksSearchInput) {
                booksSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchBooks(booksSearchInput.value);
                    }
                });
            }
            const musicLoading = document.getElementById('music-loading');
            const musicEmpty = document.getElementById('music-empty');
            const musicResults = document.getElementById('music-results');
            const musicResultsGrid = document.getElementById('music-results-grid');
            const musicResultsCount = document.getElementById('music-results-count');
            const musicResultsTitle = document.getElementById('music-results-title');

            const musicModal = document.getElementById('music-player-modal');
            const musicModalBack = document.getElementById('music-player-back');
            const musicModalMinimize = document.getElementById('music-player-minimize');
            const musicModalTitle = document.getElementById('music-player-title');
            const musicSongTitle = document.getElementById('music-player-song-title');
            const musicArtist = document.getElementById('music-player-artist');
            const musicCover = document.getElementById('music-player-cover');
            const musicAudio = document.getElementById('music-player-audio');
            const musicPlayPauseBtn = document.getElementById('music-play-pause-btn');
            const musicBackwardBtn = document.getElementById('music-backward-btn');
            const musicForwardBtn = document.getElementById('music-forward-btn');
            const musicPrevTrackBtn = document.getElementById('music-prev-track-btn');
            const musicNextTrackBtn = document.getElementById('music-next-track-btn');
            const musicProgressBar = document.getElementById('music-progress-bar');
            const musicProgressFill = document.getElementById('music-progress-fill');
            const musicCurrentTime = document.getElementById('music-current-time');
            const musicTotalTime = document.getElementById('music-total-time');
            const musicVolumeSlider = document.getElementById('music-volume-slider');
            const musicVolumeFill = document.getElementById('music-volume-fill');
            const musicAutoplayToggle = document.getElementById('music-autoplay-toggle');
            
            // Mini player elements
            const miniPlayer = document.getElementById('music-mini-player');
            const miniPlayerMaximize = document.getElementById('music-player-maximize');
            const miniPlayerSongTitle = document.getElementById('mini-player-song-title');
            const miniPlayerArtist = document.getElementById('mini-player-artist');
            const miniPlayPauseBtn = document.getElementById('mini-play-pause-btn');
            const miniBackwardBtn = document.getElementById('mini-backward-btn');
            const miniForwardBtn = document.getElementById('mini-forward-btn');
            const miniPrevTrackBtn = document.getElementById('mini-prev-track-btn');
            const miniNextTrackBtn = document.getElementById('mini-next-track-btn');
            const miniProgressBar = document.getElementById('mini-progress-bar');
            const miniProgressFill = document.getElementById('mini-progress-fill');
            const miniCurrentTime = document.getElementById('mini-current-time');
            const miniTotalTime = document.getElementById('mini-total-time');
            // Playlist chooser modal refs
            const playlistChooser = document.getElementById('music-playlist-chooser');
            const playlistChooserBack = document.getElementById('playlist-chooser-back');
            const playlistChooserList = document.getElementById('playlist-chooser-list');
            const playlistChooserEmpty = document.getElementById('playlist-chooser-empty');
            const playlistChooserNewName = document.getElementById('playlist-chooser-new-name');
            const playlistChooserCreate = document.getElementById('playlist-chooser-create');
            let playlistChooserTrack = null;

            // Music providers (fallback order)
            let HIFI_BASES = [
                // Monochrome.tf instances
                'https://frankfurt.monochrome.tf',
                'https://virginia.monochrome.tf',
                'https://ohio.monochrome.tf',
                'https://singapore.monochrome.tf',
                'https://california.monochrome.tf',
                'https://oregon.monochrome.tf',
                'https://jakarta.monochrome.tf',
                'https://tokyo.monochrome.tf',
                'https://london.monochrome.tf',

                // Squid.wtf instances
                'https://triton.squid.wtf',
                'https://aether.squid.wtf',
                'https://zeus.squid.wtf',
                'https://kraken.squid.wtf',
                'https://phoenix.squid.wtf',
                'https://shiva.squid.wtf',
                'https://chaos.squid.wtf',

                // QQDL.site instances
                'https://hund.qqdl.site',
                'https://katze.qqdl.site',
                'https://vogel.qqdl.site',
                'https://maus.qqdl.site',
                'https://wolf.qqdl.site',

                // UI instances that also expose the API
                'https://monochrome.tf',
                'https://music.binimum.org',
                'https://tidal.squid.wtf',
                'https://tidal.qqdl.site',

                // Existing known instances
                'https://hifi.401658.xyz',
                'https://tidal.401658.xyz'
            ];

            // HiFi ranking cache key
            const HIFI_RANK_KEY = 'pt_hifi_rank_v1';

            // Utility: unique array preserving order
            function uniq(arr) { return Array.from(new Set(arr)); }

            // Ping a base and return latency in ms (Infinity on failure)
            async function pingHiFiBase(base, timeoutMs = 2500) {
                const url = base.replace(/\/$/, '') + '/?_ping=' + Math.floor(Math.random() * 10000);
                const ctrl = new AbortController();
                const t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                const timer = setTimeout(() => { try { ctrl.abort(); } catch(_){} }, Math.max(500, timeoutMs));
                try {
                    // Use no-cors GET to avoid CORS issues; we only need timing
                    await fetch(url, { method: 'GET', mode: 'no-cors', cache: 'no-store', redirect: 'follow', signal: ctrl.signal });
                    const t1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                    clearTimeout(timer);
                    return Math.max(0, Math.round(t1 - t0));
                } catch(_) {
                    clearTimeout(timer);
                    return Infinity;
                }
            }

            // Rank all HiFi bases by measured latency (fastest first) and persist
            async function rankHiFiBasesOnce() {
                const bases = [...HIFI_BASES];
                try {
                    const timings = await Promise.all(bases.map(b => pingHiFiBase(b)));
                    const ranked = bases
                        .map((b, i) => ({ base: b, time: timings[i] }))
                        .sort((a, b) => a.time - b.time)
                        .map(x => x.base);
                    HIFI_BASES = uniq(ranked);
                    try { localStorage.setItem(HIFI_RANK_KEY, JSON.stringify({ list: HIFI_BASES, ts: Date.now() })); } catch(_) {}
                } catch(_) { /* keep default order on error */ }
            }

            // Initialize HiFi ranking on first launch only
            (function initHiFiRanking() {
                try {
                    const cached = JSON.parse(localStorage.getItem(HIFI_RANK_KEY) || 'null');
                    if (cached && Array.isArray(cached.list) && cached.list.length) {
                        // Prefer cached order but keep any new bases appended
                        HIFI_BASES = uniq([ ...cached.list, ...HIFI_BASES ]);
                        return;
                    }
                } catch(_) {}
                // No cache: rank asynchronously right after load
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => { try { rankHiFiBasesOnce(); } catch(_) {} });
                } else {
                    try { rankHiFiBasesOnce(); } catch(_) {}
                }
            })();

            // Helper to fetch from music providers with fallback
            async function musicFetchJson(path) {
                let lastError = null;
                for (const base of HIFI_BASES) {
                    try {
                        const resp = await fetch(`${base}${path}`);
                        if (resp.ok) {
                            return await resp.json();
                        }
                        lastError = new Error(`HTTP ${resp.status} from ${base}`);
                    } catch (e) {
                        lastError = e;
                    }
                }
                throw lastError || new Error('All music providers failed');
            }

            function tidalCoverUrl(cover) {
                if (!cover) return '';
                try {
                    // If a full URL is provided (e.g. from Spotify), return it directly
                    if (typeof cover === 'string' && cover.startsWith('http')) {
                        return cover;
                    }
                    return `https://resources.tidal.com/images/${cover.replace(/-/g, '/')}/320x320.jpg`;
                } catch (_) {
                    return '';
                }
            }

            function fmtTime(sec) {
                if (!isFinite(sec)) return '0:00';
                const m = Math.floor(sec / 60);
                const s = Math.floor(sec % 60).toString().padStart(2, '0');
                return `${m}:${s}`;
            }

            // Helper to call our own API endpoints instead of HiFi/Tidal. Wraps fetch and JSON parsing.
            async function musicApiFetch(path) {
                try {
                    // Ensure the path starts with /api
                    const url = path.startsWith('/api/') ? path : `/api${path}`;
                    const resp = await fetch(url);
                    if (!resp.ok) {
                        throw new Error(`API request failed with status ${resp.status}`);
                    }
                    return await resp.json();
                } catch (err) {
                    console.error('[MUSIC] API error:', err);
                    throw err;
                }
            }

            async function searchMusic(query) {
                if (!query || !query.trim()) {
                    showNotification('Please enter a search term', 'warning');
                    return;
                }

                const q = query.trim();
                musicEmpty.style.display = 'none';
                musicResults.style.display = 'none';
                musicLoading.style.display = 'block';

                try {
                    // Use our API to search for tracks via Spotify
                    const resp = await musicApiFetch(`/api/search?q=${encodeURIComponent(q)}&type=track&limit=30`);
                    musicLoading.style.display = 'none';
                    const items = Array.isArray(resp?.results) ? resp.results : [];
                    if (!items.length) {
                        musicResults.style.display = 'none';
                        musicEmpty.style.display = 'block';
                        musicEmpty.innerHTML = `
                            <div class="books-empty-icon"><i class="fas fa-search"></i></div>
                            <h3>No Music Found</h3>
                            <p>No results found for "${q}". Try a different search.</p>
                        `;
                        showNotification('No music found for your search', 'info');
                        return;
                    }
                    // Normalize results into the shape expected by displayMusicResults
                    const normalized = items.map(it => {
                        const id = it.id;
                        const title = it.title || it.name || 'Unknown Title';
                        const artistName = it.artists || 'Unknown Artist';
                        const albumArt = it.albumArt || '';
                        return {
                            id: id,
                            title: title,
                            trackId: id,
                            artist: artistName,
                            artists: artistName,
                            album: { cover: albumArt },
                            cover: albumArt,
                            albumCover: albumArt,
                            duration: it.duration
                        };
                    });
                    musicResultsCache = normalized;
                    displayMusicResults(normalized, q);
                    showNotification(`Found ${normalized.length} item${normalized.length !== 1 ? 's' : ''}`, 'success');
                } catch (e) {
                    console.error('[MUSIC] Search error', e);
                    musicLoading.style.display = 'none';
                    musicResults.style.display = 'none';
                    musicEmpty.style.display = 'block';
                    musicEmpty.innerHTML = `
                        <div class="books-empty-icon"><i class="fas fa-exclamation-triangle"></i></div>
                        <h3>Search Error</h3>
                        <p>Failed to search music. Please try again.</p>
                    `;
                    showNotification('Failed to search music', 'error');
                }
            }

            function displayMusicResults(results, q) {
                // Store results for re-rendering after download
                window.currentMusicResults = results;
                window.currentMusicQuery = q;
                
                musicResultsTitle.textContent = `Search Results for "${q}"`;
                musicResultsCount.textContent = `${results.length} item${results.length !== 1 ? 's' : ''} found`;
                // Ensure we are not in playlist-open mode when showing generic results
                const musicPage = document.getElementById('music-page');
                if (musicPage) musicPage.classList.remove('playlist-open');
                // Hide My Albums and Album View when showing generic results
                const myAlbumsSec = document.getElementById('my-albums');
                if (myAlbumsSec) myAlbumsSec.style.display = 'none';
                const albumViewSec = document.getElementById('music-album-view');
                if (albumViewSec) albumViewSec.style.display = 'none';
                musicResultsGrid.innerHTML = '';

                // Store for building a queue from search results
                const currentSearchTracks = [];
                results.forEach(item => {
                    const trackId = item.id || item.trackId || item.itemId;
                    const title = item.title || item.trackTitle || 'Unknown Title';
                    const artistName = (item.artist && (item.artist.name || item.artist)) || (item.artists && item.artists[0]?.name) || 'Unknown Artist';
                    const cover = item.album?.cover || item.cover || item.albumCover || '';
                    const img = tidalCoverUrl(cover) || 'https://via.placeholder.com/320x320?text=Music';
                    if (trackId) currentSearchTracks.push({ id: String(trackId), title, artist: artistName, cover: img });

                    const card = document.createElement('div');
                    card.className = 'music-card';
                    const isSaved = getMyMusic().some(x => x.id == trackId);
                    const isDownloaded = isTrackDownloaded(trackId);
                    card.innerHTML = `
                        <div class="music-cover">
                            <img loading="lazy" src="${img}" alt="${title}">
                        </div>
                        <div class="music-info">
                            <div class="music-title">${title}</div>
                            <div class="music-artist">${artistName}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-play"></i> Play</button>
                                <button class="music-heart-btn ${isSaved ? 'added' : ''}" title="${isSaved ? 'In My Music' : 'Add to My Music'}" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas ${isSaved ? 'fa-heart' : 'fa-heart'}"></i></button>
                                <button class="music-plus-btn" title="Add to Playlist" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-plus"></i></button>
                                ${isDownloaded ? 
                                    `<button class="music-download-btn downloaded" title="Downloaded" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-check-circle"></i></button>` : 
                                    `<button class="music-download-btn" title="Download" data-id="${trackId}" data-title="${title.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${img}"><i class="fas fa-download"></i></button>`
                                }
                            </div>
                        </div>
                    `;
                    musicResultsGrid.appendChild(card);
                });

                // Wire up buttons
                musicResultsGrid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const trackId = String(e.currentTarget.getAttribute('data-id'));
                        const idx = currentSearchTracks.findIndex(t => String(t.id) === trackId);
                        if (idx >= 0) {
                            setPlayQueue(currentSearchTracks, idx);
                        } else {
                            const card = e.currentTarget.closest('.music-card');
                            const title = card.querySelector('.music-title')?.textContent || 'Unknown Title';
                            const artistName = card.querySelector('.music-artist')?.textContent || 'Unknown Artist';
                            const coverSrc = card.querySelector('img')?.src || '';
                            await playMusicTrack({ trackId, title, artistName, coverSrc });
                        }
                    });
                });

                // Heart (My Music)
                musicResultsGrid.querySelectorAll('.music-heart-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        const saved = getMyMusic();
                        const track = {
                            id: el.getAttribute('data-id'),
                            title: el.getAttribute('data-title'),
                            artist: el.getAttribute('data-artist'),
                            cover: el.getAttribute('data-cover')
                        };
                        if (!saved.find(x => x.id === track.id)) {
                            saved.push(track);
                            setMyMusic(saved);
                            showNotification(`Saved "${track.title}" to My Music`, 'success');
                            el.classList.add('added');
                            el.title = 'In My Music';
                        } else {
                            showNotification('Already in My Music', 'info');
                        }
                    });
                });

                // Add to playlist
                musicResultsGrid.querySelectorAll('.music-plus-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        const track = {
                            id: el.getAttribute('data-id'),
                            title: el.getAttribute('data-title'),
                            artist: el.getAttribute('data-artist'),
                            cover: el.getAttribute('data-cover')
                        };
                        showPlaylistChooser(track);
                    });
                });

                // Download music
                musicResultsGrid.querySelectorAll('.music-download-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        // Prevent concurrent downloads: if one is in progress, show notice and do nothing
                        if (currentDownloadId || currentDownloadController) {
                            showNotification('Please wait for the current download to finish', 'info');
                            return;
                        }
                        const el = e.currentTarget;
                        const trackId = el.getAttribute('data-id');
                        const title = el.getAttribute('data-title');
                        const artist = el.getAttribute('data-artist');
                        const cover = el.getAttribute('data-cover');
                        
                        if (isTrackDownloaded(trackId)) {
                            showNotification('Track already downloaded', 'info');
                            return;
                        }
                        
                        await downloadMusicTrack(trackId, title, artist, cover);
                    });
                });

                

                musicEmpty.style.display = 'none';
                musicResults.style.display = 'block';
            }

            // ===== Albums Search & View =====
            const albumSearchBtn = document.getElementById('music-album-search-btn');
            const albumsSection = document.getElementById('music-albums');
            const albumsGrid = document.getElementById('music-albums-grid');
            const albumsCount = document.getElementById('music-albums-count');
            const albumView = document.getElementById('music-album-view');
            const albumCloseBtn = document.getElementById('album-close-btn');
            const albumTracksEl = document.getElementById('album-tracks');
            const albumViewTitle = document.getElementById('album-view-title');
            const albumViewMeta = document.getElementById('album-view-meta');
            const albumViewCover = document.getElementById('album-view-cover');

            function setMusicSectionVisible(section) {
                const sections = ['music-results','my-music','music-playlists','music-albums','music-album-view'];
                const empty = document.getElementById('music-empty');
                sections.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });
                if (empty) empty.style.display = 'none';
                const musicPage = document.getElementById('music-page');
                if (musicPage) musicPage.classList.remove('playlist-open');
                if (section === 'results') document.getElementById('music-results').style.display = '';
                if (section === 'my-music') document.getElementById('my-music').style.display = '';
                if (section === 'music-playlists') document.getElementById('music-playlists').style.display = '';
                if (section === 'albums') document.getElementById('music-albums').style.display = '';
                if (section === 'album-view') document.getElementById('music-album-view').style.display = '';
                if (section === 'my-albums') document.getElementById('my-albums').style.display = '';
            }

            async function searchAlbums(query) {
                if (!query || !query.trim()) {
                    showNotification('Please enter an album search term', 'warning');
                    return;
                }
                setMusicSectionVisible('albums');
                albumsGrid.innerHTML = '';
                albumsCount.textContent = 'Searching';
                try {
                    // Use our API to search for albums via Spotify
                    const resp = await musicApiFetch(`/api/search?q=${encodeURIComponent(query.trim())}&type=album&limit=20`);
                    const albums = Array.isArray(resp?.results) ? resp.results : [];
                    renderAlbumResults(albums);
                } catch (e) {
                    console.error('[MUSIC] Album search error', e);
                    albumsCount.textContent = 'Error searching albums';
                }
            }

            function renderAlbumResults(albums) {
                albumsGrid.innerHTML = '';
                albumsCount.textContent = `${albums.length} album${albums.length===1?'':'s'}`;
                if (!albums.length) {
                    albumsGrid.innerHTML = '<div class="album-empty">No albums found.</div>';
                    return;
                }
                albums.forEach(a => {
                    // Normalize album data for display. API returns { id, name, artists, albumArt, releaseDate, totalTracks }
                    let artistName = 'Unknown Artist';
                    if (typeof a.artists === 'string') artistName = a.artists;
                    else if (Array.isArray(a.artists) && a.artists.length > 0) artistName = (typeof a.artists[0] === 'string' ? a.artists[0] : a.artists[0].name);
                    else if (a.artist && typeof a.artist === 'string') artistName = a.artist;
                    else if (a.artist && a.artist.name) artistName = a.artist.name;

                    const coverUrl = a.albumArt || a.cover || '';
                    const title = a.name || a.title || 'Unknown Album';
                    const totalTracks = a.totalTracks || a.numberOfTracks || 0;
                    const releaseDate = a.releaseDate || '';
                    const card = document.createElement('div');
                    card.className = 'album-card';
                    const saved = getMyAlbums().some(x => String(x.id) === String(a.id));
                    card.innerHTML = `
                        <img loading="lazy" class="album-cover" src="${coverUrl}" alt="${title}">
                        <div class="album-body">
                            <div class="album-title">${title}</div>
                            <div class="album-artist">${artistName}</div>
                            <div class="album-meta">
                                <span>${totalTracks} tracks</span>
                                ${releaseDate ? `<span></span><span>${releaseDate}</span>` : ''}
                            </div>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="album-open-btn"><i class="fas fa-folder-open"></i> Open</button>
                                <button class="album-heart-btn ${saved ? 'added' : ''}" title="${saved ? 'In My Albums' : 'Save Album'}"><i class="fas fa-heart"></i></button>
                            </div>
                        </div>`;
                    // Attach album object with normalized fields for open/save operations
                    const normalizedAlbum = { id: a.id, title: title, name: title, artists: artistName, artist: artistName, albumArt: coverUrl, cover: coverUrl, totalTracks: totalTracks, releaseDate: releaseDate };
                    card.querySelector('.album-open-btn').addEventListener('click', () => openAlbum(normalizedAlbum));
                    card.querySelector('.album-heart-btn').addEventListener('click', () => saveAlbum(normalizedAlbum, card.querySelector('.album-heart-btn')));
                    albumsGrid.appendChild(card);
                });
            }

            // Store current album tracks for Play All functionality
            let currentAlbumTracks = [];

            async function openAlbum(albumFromSearch) {
                try {
                    setMusicSectionVisible('album-view');
                    albumTracksEl.innerHTML = '<div class="album-empty">Loading tracks</div>';
                    currentAlbumTracks = []; // Clear previous album data

                    // Fetch album tracks from our API
                    const resp = await musicApiFetch(`/api/album/${encodeURIComponent(albumFromSearch.id)}/tracks`);
                    const albumMeta = resp.album || {};
                    const tracks = Array.isArray(resp.tracks) ? resp.tracks : [];
                    // Determine header info
                    const title = albumMeta.name || albumFromSearch.name || albumFromSearch.title || 'Album';
                    const artistName = albumMeta.artists || albumFromSearch.artists || 'Unknown Artist';
                    const numTracks = albumMeta.totalTracks ?? albumFromSearch.totalTracks ?? albumFromSearch.numberOfTracks ?? tracks.length;
                    const releaseDate = albumMeta.releaseDate || albumFromSearch.releaseDate || '';
                    const coverUrl = albumMeta.albumArt || albumFromSearch.albumArt || '';
                    albumViewTitle.textContent = title;
                    albumViewMeta.textContent = `${artistName}  ${numTracks} tracks${releaseDate ? '  ' + releaseDate : ''}`;
                    albumViewCover.src = coverUrl || '';
                    // Prepare queue for play all
                    currentAlbumTracks = tracks.map((t, idx) => {
                        const trackId = t.id || idx + 1;
                        const trackTitle = t.title || t.name || `Track ${idx+1}`;
                        const trackArtist = t.artists || artistName;
                        return {
                            id: trackId,
                            title: trackTitle,
                            artist: trackArtist,
                            cover: coverUrl
                        };
                    }).filter(t => t.id);
                    renderAlbumTracks(tracks, { artists: artistName, albumArt: coverUrl });
                } catch (e) {
                    console.error('[MUSIC] openAlbum error', e);
                    albumTracksEl.innerHTML = '<div class="album-empty">Failed to load album.</div>';
                    currentAlbumTracks = []; // Clear on error
                }
            }

            function renderAlbumTracks(tracks, album) {
                if (!tracks.length) {
                    albumTracksEl.innerHTML = '<div class="album-empty">No tracks found in this album.</div>';
                    return;
                }
                albumTracksEl.innerHTML = '';
                const coverSrc = album.cover ? tidalCoverUrl(album.cover) : '';
                tracks.forEach((t, idx) => {
                    const trackId = t.id || idx + 1;
                    const trackTitle = t.title || t.name || `Track ${idx+1}`;
                    // Use the provided artists string or album fallback
                    const artistName = t.artists || album.artists || 'Unknown Artist';
                    // Parse duration: could be number (seconds), string mm:ss, or durationMs (ms)
                    let durationSec = 0;
                    if (typeof t.duration === 'number') {
                        durationSec = t.duration;
                    } else if (typeof t.duration === 'string') {
                        const parts = t.duration.split(':');
                        if (parts.length >= 2) {
                            const min = parseInt(parts[0], 10);
                            const sec = parseInt(parts[1], 10);
                            if (!isNaN(min) && !isNaN(sec)) durationSec = min * 60 + sec;
                        }
                    } else if (typeof t.durationMs === 'number') {
                        durationSec = Math.round(t.durationMs / 1000);
                    }
                    const coverSrc = album.albumArt || album.cover || '';
                    const isDownloaded = isTrackDownloaded(trackId);
                    const downloadBtnClass = isDownloaded ? 'track-download-btn downloaded' : 'track-download-btn';
                    const downloadBtnIcon = isDownloaded ? 'fas fa-check-circle' : 'fas fa-download';
                    const downloadBtnTitle = isDownloaded ? 'Downloaded' : 'Download';
                    const row = document.createElement('div');
                    row.className = 'track-row';
                    row.innerHTML = `
                        <div class="track-index">${idx+1}</div>
                        <div class="track-title">${trackTitle} <span style="color:#94a3b8; font-weight:600;"> ${artistName}</span></div>
                        <div class="track-duration">${fmtTime(durationSec)}</div>
                        <div class="track-actions">
                            <button class="track-play-btn"><i class="fas fa-play"></i> Play</button>
                            <button class="${downloadBtnClass}" title="${downloadBtnTitle}" data-id="${trackId}" data-title="${trackTitle.replace(/\"/g,'&quot;')}" data-artist="${artistName.replace(/\"/g,'&quot;')}" data-cover="${coverSrc}"><i class="${downloadBtnIcon}"></i> ${isDownloaded ? 'Downloaded' : 'Download'}</button>
                            <button class="track-plus-btn"><i class="fas fa-plus"></i> Playlist</button>
                            <button class="track-heart-btn"><i class="fas fa-heart"></i> Save</button>
                        </div>`;
                    row.querySelector('.track-play-btn').addEventListener('click', () => {
                        if (!trackId) { showNotification('Unable to play: missing track id', 'error'); return; }
                        // Use precomputed album queue
                        const idxInQueue = currentAlbumTracks.findIndex(x => String(x.id) === String(trackId));
                        if (idxInQueue >= 0) {
                            setPlayQueue(currentAlbumTracks, idxInQueue);
                        } else {
                            playMusicTrack({ trackId: trackId, title: trackTitle, artistName, coverSrc });
                        }
                    });
                    row.querySelector('.track-download-btn').addEventListener('click', async () => {
                        if (!trackId) { showNotification('Unable to download: missing track id', 'error'); return; }
                        if (isTrackDownloaded(trackId)) {
                            showNotification('Track already downloaded', 'info');
                            return;
                        }
                        await downloadMusicTrack(trackId, trackTitle, artistName, coverSrc);
                        // Re-render to update button state
                        renderAlbumTracks(tracks, album);
                    });
                    row.querySelector('.track-plus-btn').addEventListener('click', () => {
                        if (!trackId) { showNotification('Unable to add: missing track id', 'error'); return; }
                        showPlaylistChooser({ id: String(trackId), title: trackTitle, artist: artistName, cover: coverSrc });
                    });
                    row.querySelector('.track-heart-btn').addEventListener('click', () => {
                        if (!trackId) { showNotification('Unable to save: missing track id', 'error'); return; }
                        const list = getMyMusic();
                        if (!list.find(x => String(x.id) === String(trackId))) {
                            list.push({ id: String(trackId), title: trackTitle, artist: artistName, cover: coverSrc });
                            setMyMusic(list);
                            showNotification(`Saved "${trackTitle}" to My Music`, 'success');
                        } else {
                            showNotification('Already in My Music', 'info');
                        }
                    });
                    albumTracksEl.appendChild(row);
                });
            }

            if (albumSearchBtn) {
                albumSearchBtn.addEventListener('click', () => searchAlbums(musicSearchInput?.value || ''));
            }
            if (albumCloseBtn) {
                albumCloseBtn.addEventListener('click', () => {
                    // If albums list has content, go back there; else back to generic state
                    if (albumsGrid && albumsGrid.children.length) setMusicSectionVisible('albums');
                    else if (musicResultsGrid && musicResultsGrid.children.length) setMusicSectionVisible('results');
                    else setMusicSectionVisible('results');
                });
            }

            // Play All button handlers
            const albumPlayAllBtn = document.getElementById('album-play-all-btn');
            if (albumPlayAllBtn) {
                albumPlayAllBtn.addEventListener('click', () => {
                    // Use stored album tracks instead of querying DOM
                    if (currentAlbumTracks.length === 0) {
                        showNotification('No tracks to play', 'info');
                        return;
                    }
                    playAllTracks(currentAlbumTracks);
                });
            }

            // Save All to Playlist (Album view)
            const albumSaveAllBtn = document.getElementById('album-save-all-btn');
            if (albumSaveAllBtn) {
                albumSaveAllBtn.addEventListener('click', () => {
                    if (!currentAlbumTracks || currentAlbumTracks.length === 0) {
                        showNotification('No tracks to save', 'info');
                        return;
                    }
                    // Open playlist chooser with entire album track list
                    showPlaylistChooser([...currentAlbumTracks]);
                });
            }

            // Shuffle (Album view)
            const albumShuffleBtn = document.getElementById('album-shuffle-btn');
            if (albumShuffleBtn) {
                albumShuffleBtn.addEventListener('click', () => {
                    if (!currentAlbumTracks || currentAlbumTracks.length === 0) {
                        showNotification('No tracks to shuffle', 'info');
                        return;
                    }
                    const shuffled = [...currentAlbumTracks];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    playAllTracks(shuffled);
                });
            }

            const myMusicPlayAllBtn = document.getElementById('my-music-play-all-btn');
            if (myMusicPlayAllBtn) {
                myMusicPlayAllBtn.addEventListener('click', () => {
                    const tracks = getMyMusic();
                    if (tracks.length === 0) {
                        showNotification('No tracks in My Music', 'info');
                        return;
                    }
                    playAllTracks(tracks);
                });
            }

            // Shuffle (My Music)
            const myMusicShuffleBtn = document.getElementById('my-music-shuffle-btn');
            if (myMusicShuffleBtn) {
                myMusicShuffleBtn.addEventListener('click', () => {
                    const tracks = getMyMusic();
                    if (!tracks || tracks.length === 0) {
                        showNotification('No tracks in My Music', 'info');
                        return;
                    }
                    const shuffled = [...tracks];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    playAllTracks(shuffled);
                });
            }

            // ===== My Albums storage and rendering =====
            const MY_ALBUMS_KEY = 'pt_my_albums_v1';
            function getMyAlbums() {
                try { return JSON.parse(localStorage.getItem(MY_ALBUMS_KEY) || '[]'); } catch(_) { return []; }
            }
            function setMyAlbums(arr) {
                try { localStorage.setItem(MY_ALBUMS_KEY, JSON.stringify(arr)); } catch(_) {}
            }
            function saveAlbum(album, btnEl) {
                const list = getMyAlbums();
                const exists = list.find(x => String(x.id) === String(album.id));
                if (exists) {
                    showNotification('Album already saved', 'info');
                    if (btnEl) btnEl.classList.add('added');
                    return;
                }
                
                // Handle various property names from different sources
                const title = album.title || album.name || 'Unknown Album';
                const cover = album.cover || album.albumArt || null;
                
                let artist = 'Unknown Artist';
                if (typeof album.artist === 'string') artist = album.artist;
                else if (typeof album.artists === 'string') artist = album.artists;
                else if (album.artist?.name) artist = album.artist.name;
                else if (Array.isArray(album.artists) && album.artists.length > 0) {
                    if (typeof album.artists[0] === 'string') artist = album.artists[0];
                    else artist = album.artists[0].name;
                }

                const toSave = {
                    id: album.id,
                    title: title,
                    cover: cover,
                    artist: artist,
                    numberOfTracks: album.numberOfTracks || album.totalTracks || 0,
                    releaseDate: album.releaseDate || ''
                };
                list.push(toSave);
                setMyAlbums(list);
                showNotification(`Saved "${toSave.title}" to My Albums`, 'success');
                if (btnEl) btnEl.classList.add('added');
            }

            function renderMyAlbums() {
                const grid = document.getElementById('my-albums-grid');
                const count = document.getElementById('my-albums-count');
                const empty = document.getElementById('my-albums-empty');
                const albums = getMyAlbums();
                grid.innerHTML = '';
                if (!albums.length) {
                    count.textContent = '0 albums';
                    empty.style.display = '';
                    return;
                }
                empty.style.display = 'none';
                count.textContent = `${albums.length} album${albums.length===1?'':'s'}`;
                albums.forEach(a => {
                    const card = document.createElement('div');
                    card.className = 'album-card';
                    const coverUrl = a.cover ? tidalCoverUrl(a.cover) : '';
                    card.innerHTML = `
                        <img loading="lazy" class="album-cover" src="${coverUrl}" alt="${a.title}">
                        <div class="album-body">
                            <div class="album-title">${a.title}</div>
                            <div class="album-artist">${a.artist || ''}</div>
                            <div class="album-meta"><span>${a.numberOfTracks||0} tracks</span>${a.releaseDate?`<span></span><span>${a.releaseDate}</span>`:''}</div>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="album-open-btn" data-id="${a.id}"><i class="fas fa-folder-open"></i> Open</button>
                                <button class="album-heart-btn added" title="Remove from My Albums" data-remove="true" data-id="${a.id}"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    grid.appendChild(card);
                });
                // Wire open and remove
                grid.querySelectorAll('.album-open-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const id = btn.getAttribute('data-id');
                        const album = getMyAlbums().find(x => String(x.id) === String(id));
                        if (album) openAlbum(album);
                    });
                });
                grid.querySelectorAll('.album-heart-btn[data-remove="true"]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const id = btn.getAttribute('data-id');
                        const list = getMyAlbums().filter(x => String(x.id) !== String(id));
                        setMyAlbums(list);
                        renderMyAlbums();
                        showNotification('Removed album', 'info');
                    });
                });
            }

            // Toggle My Albums
            const myAlbumsBtn = document.getElementById('music-my-albums-btn');
            if (myAlbumsBtn) {
                myAlbumsBtn.addEventListener('click', () => {
                    const sec = document.getElementById('my-albums');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const mySec = document.getElementById('my-music');
                    const plsSec = document.getElementById('music-playlists');
                    const downloadedSec = document.getElementById('music-downloaded');
                    const albListSec = document.getElementById('music-albums');
                    const albumViewSec = document.getElementById('music-album-view');
                    const showing = sec.style.display !== 'none';
                    if (showing) {
                        sec.style.display = 'none';
                        if (albListSec && albListSec.children.length) { albListSec.style.display = 'block'; }
                        else if (musicResultsGrid && musicResultsGrid.children.length) { resSec.style.display = 'block'; empty.style.display = 'none'; }
                        else { resSec.style.display = 'none'; empty.style.display = ''; }
                        if (albumViewSec) albumViewSec.style.display = 'none';
                    } else {
                        renderMyAlbums();
                        sec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        mySec.style.display = 'none';
                        plsSec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (albListSec) albListSec.style.display = 'none';
                        if (albumViewSec) albumViewSec.style.display = 'none';
                    }
                });
            }

            // My Music storage helpers
            const MY_MUSIC_KEY = 'pt_my_music_v1';
            function getMyMusic() {
                try { return JSON.parse(localStorage.getItem(MY_MUSIC_KEY) || '[]'); } catch(_) { return []; }
            }
            function setMyMusic(arr) {
                try { localStorage.setItem(MY_MUSIC_KEY, JSON.stringify(arr)); } catch(_) {}
            }

            // Playlists storage helpers
            const PLAYLISTS_KEY = 'pt_playlists_v1';
            function getPlaylists() {
                try { return JSON.parse(localStorage.getItem(PLAYLISTS_KEY) || '[]'); } catch(_) { return []; }
            }
            function setPlaylists(arr) {
                try { localStorage.setItem(PLAYLISTS_KEY, JSON.stringify(arr)); } catch(_) {}
            }
            function addTrackToPlaylist(playlistId, track) {
                const pls = getPlaylists();
                const pl = pls.find(p => p.id === playlistId);
                if (!pl) return false;
                if (!pl.tracks) pl.tracks = [];
                if (!pl.tracks.find(t => t.id === track.id)) {
                    pl.tracks.push(track);
                    setPlaylists(pls);
                    return true;
                }
                return false;
            }

            // Bulk add helper: add multiple tracks, avoid duplicates, single write
            function addTracksToPlaylist(playlistId, tracks) {
                if (!Array.isArray(tracks) || tracks.length === 0) return { added: 0, total: 0 };
                const pls = getPlaylists();
                const pl = pls.find(p => p.id === playlistId);
                if (!pl) return { added: 0, total: tracks.length };
                if (!Array.isArray(pl.tracks)) pl.tracks = [];
                const existing = new Set(pl.tracks.map(t => String(t.id)));
                let added = 0;
                tracks.forEach(t => {
                    if (!t || t.id == null) return;
                    const idStr = String(t.id);
                    if (!existing.has(idStr)) {
                        pl.tracks.push(t);
                        existing.add(idStr);
                        added++;
                    }
                });
                if (added > 0) setPlaylists(pls);
                return { added, total: tracks.length };
            }

            // Downloaded Music storage helpers
            const DOWNLOADED_MUSIC_KEY = 'pt_downloaded_music_v1';
            function getDownloadedMusic() {
                try { return JSON.parse(localStorage.getItem(DOWNLOADED_MUSIC_KEY) || '[]'); } catch(_) { return []; }
            }
            function setDownloadedMusic(arr) {
                try { localStorage.setItem(DOWNLOADED_MUSIC_KEY, JSON.stringify(arr)); } catch(_) {}
            }
            function isTrackDownloaded(trackId) {
                const downloaded = getDownloadedMusic();
                return downloaded.some(d => String(d.id) === String(trackId));
            }
            function addToDownloaded(track) {
                const downloaded = getDownloadedMusic();
                if (!downloaded.find(d => String(d.id) === String(track.id))) {
                    downloaded.push(track);
                    setDownloadedMusic(downloaded);
                    return true;
                }
                return false;
            }
            function removeFromDownloaded(trackId) {
                // Ensure type-safe comparison so numeric vs string IDs don't break removal
                const downloaded = getDownloadedMusic().filter(d => String(d.id) !== String(trackId));
                setDownloadedMusic(downloaded);
            }

            // Reconcile local downloaded list with actual files on disk
            async function reconcileDownloadedMusicWithDisk() {
                try {
                    const list = getDownloadedMusic();
                    if (!Array.isArray(list) || list.length === 0) return [];
                    const filePaths = Array.from(new Set(list.map(d => d && d.filePath).filter(Boolean)));
                    if (filePaths.length === 0) return list;
                    const res = await fetch('/api/music/exists-batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filePaths })
                    });
                    if (!res.ok) return list;
                    const data = await res.json();
                    const existsMap = (data && data.results) || {};
                    const filtered = list.filter(item => item && item.filePath && existsMap[item.filePath]);
                    if (filtered.length !== list.length) {
                        setDownloadedMusic(filtered);
                    }
                    return filtered;
                } catch (e) {
                    console.warn('[Music] Reconcile with disk failed:', e);
                    return getDownloadedMusic();
                }
            }

            // Track current download for cancellation
            let currentDownloadController = null;
            let currentDownloadFilePath = null;
            let currentDownloadId = null;
            let currentDownloadPoll = null;
            let currentDownloadCancelled = false;
            let isDownloadMinimized = false;
            
            // Download queue system
            let downloadQueue = [];
            let isProcessingQueue = false;

            // Update queue display
            function updateQueueDisplay() {
                const queueInfo = document.getElementById('music-download-queue-info');
                const queueCount = document.getElementById('music-download-queue-count');
                
                if (downloadQueue.length > 0) {
                    if (queueInfo) queueInfo.style.display = 'block';
                    if (queueCount) queueCount.textContent = downloadQueue.length;
                } else {
                    if (queueInfo) queueInfo.style.display = 'none';
                }
            }

            // Process download queue
            async function processDownloadQueue() {
                if (isProcessingQueue || downloadQueue.length === 0) {
                    return;
                }
                
                isProcessingQueue = true;
                
                // Process only ONE item from the queue
                const item = downloadQueue.shift();
                updateQueueDisplay();
                
                try {
                    await downloadMusicTrackInternal(item.trackId, item.title, item.artistName, item.coverSrc);
                } catch (error) {
                    console.error('Queue download error:', error);
                    showNotification(`Failed to download "${item.title}"`, 'error');
                }
                
                isProcessingQueue = false;
            }

            // Helper: fetch image and return as data URL for offline cover storage
            async function fetchImageAsDataURL(url) {
                try {
                    if (!url || url.startsWith('data:')) return url || '';
                    const res = await fetch(url);
                    if (!res.ok) throw new Error('Image fetch failed');
                    const blob = await res.blob();
                    return await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (e) {
                    console.warn('Cover to dataURL failed, keeping URL:', e?.message || e);
                    return url || '';
                }
            }

            function updateBothProgressBars(width, status) {
                // Update modal progress
                const progressBar = document.getElementById('music-download-progress-fill');
                const statusText = document.getElementById('music-download-status');
                if (progressBar) progressBar.style.width = width;
                if (statusText) statusText.textContent = status;
                
                // Update minimized progress
                const minProgressBar = document.getElementById('music-download-minimized-progress');
                const minStatusText = document.getElementById('music-download-minimized-status');
                if (minProgressBar) minProgressBar.style.width = width;
                if (minStatusText) minStatusText.textContent = status;
            }

            // Download music track function
            async function downloadMusicTrackInternal(trackId, title, artistName, coverSrc) {
                // Guard: only one download at a time
                if (currentDownloadId || currentDownloadController) {
                    // Should not happen with queue system, but just in case
                    console.warn('Download already in progress, skipping');
                    return;
                }
                // Create new AbortController for this download
                currentDownloadController = new AbortController();
                currentDownloadFilePath = null;
                isDownloadMinimized = false;
                // Assign a downloadId immediately so cancel works even before network calls
                currentDownloadId = Date.now().toString();
                
                try {
                    // Show download modal
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    const songNameEl = document.getElementById('music-download-song-name');
                    const artistNameEl = document.getElementById('music-download-artist-name');
                    const minSongEl = document.getElementById('music-download-minimized-song');
                    const minArtistEl = document.getElementById('music-download-minimized-artist');
                    
                    // Immediately show minimized notification instead of full modal
                    modal.style.display = 'none';
                    minimized.style.display = 'block';
                    isDownloadMinimized = true;
                    if (songNameEl) songNameEl.textContent = title;
                    if (artistNameEl) artistNameEl.textContent = artistName;
                    if (minSongEl) minSongEl.textContent = title;
                    if (minArtistEl) minArtistEl.textContent = artistName;

                    updateBothProgressBars('0%', 'Starting download...');

                    // Use the pre-assigned unique download ID
                    const downloadId = currentDownloadId;
                    currentDownloadCancelled = false;

                    // Poll for progress updates BEFORE and during download
                    const pollProgress = setInterval(async () => {
                        try {
                            const progressRes = await fetch(`/api/music/download/progress/${downloadId}`);
                            if (progressRes.ok) {
                                const progressData = await progressRes.json();
                                if (typeof progressData.progress === 'number') {
                                    const pct = Math.max(0, Math.min(100, progressData.progress));
                                    updateBothProgressBars(`${pct}%`, `Converting... ${pct}%  (If it looks stuck, please wait a bit longer)`);
                                }
                                if (progressData.filePath) {
                                    currentDownloadFilePath = progressData.filePath;
                                }
                                if (progressData.complete) {
                                    clearInterval(pollProgress);
                                    currentDownloadPoll = null;
                                }
                            }
                        } catch (e) {
                            console.error('Progress poll error:', e);
                        }
                    }, 300);
                    currentDownloadPoll = pollProgress;

                    // Start download (non-blocking with progress polling)
                    fetch('/api/music/download', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            trackId,
                            songName: title,
                            artistName,
                            downloadId,
                            cover: coverSrc
                        }),
                        signal: currentDownloadController.signal
                    }).then(async (downloadRes) => {
                        if (!downloadRes.ok) {
                            const err = await downloadRes.json();
                            throw new Error(err.error || 'Download failed');
                        }
                        const result = await downloadRes.json();
                        // Save file path from immediate response
                        if (result && result.filePath) {
                            currentDownloadFilePath = result.filePath;
                        }
                        // Wait until progress indicates completion
                        const waitForComplete = async () => {
                            while (true) {
                                const progRes = await fetch(`/api/music/download/progress/${downloadId}`);
                                if (progRes.ok) {
                                    const progData = await progRes.json();
                                    if (progData.complete) {
                                        if (progData.filePath) currentDownloadFilePath = progData.filePath;
                                        break;
                                    }
                                }
                                await new Promise(r => setTimeout(r, 300));
                            }
                        };
                        await waitForComplete();
                        // Add to downloaded list with cover image (stored as data URL for offline when possible)
                        let coverToStore = coverSrc;
                        try { coverToStore = await fetchImageAsDataURL(coverSrc); } catch(_) {}
                        addToDownloaded({
                            id: String(trackId),
                            title,
                            artist: artistName,
                            cover: coverToStore,
                            filePath: currentDownloadFilePath
                        });

                        // Update UI
                        updateBothProgressBars('100%', ' Download complete!');

                        setTimeout(() => {
                            const modal = document.getElementById('music-download-modal');
                            const minimized = document.getElementById('music-download-minimized');
                            modal.style.display = 'none';
                            minimized.style.display = 'none';
                            currentDownloadController = null;
                            currentDownloadFilePath = null;
                            currentDownloadId = null;
                            // Return focus to the music search bar so user can continue searching
                            try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                            // Process next item in queue
                            if (downloadQueue.length > 0) {
                                setTimeout(() => processDownloadQueue(), 500);
                            }
                        }, 1500);
                        showNotification(`Downloaded "${title}"`, 'success');
                        // Re-render music results to update button
                        const currentResults = window.currentMusicResults || [];
                        const currentQuery = window.currentMusicQuery || '';
                        if (currentResults.length > 0) {
                            displayMusicResults(currentResults, currentQuery);
                        }
                    }).catch((error) => {
                        clearInterval(pollProgress);
                        currentDownloadPoll = null;
                        console.error('Download error:', error);
                        const modal = document.getElementById('music-download-modal');
                        const minimized = document.getElementById('music-download-minimized');
                        modal.style.display = 'none';
                        minimized.style.display = 'none';
                        // Delete partial file if download was cancelled or failed
                        if (!currentDownloadCancelled && currentDownloadFilePath) {
                            fetch('/api/music/delete', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ filePath: currentDownloadFilePath })
                            }).catch(e => console.error('Failed to delete partial file:', e));
                        }
                        currentDownloadController = null;
                        currentDownloadFilePath = null;
                        currentDownloadId = null;
                        // Ensure user can interact and refocus the search bar after failure
                        try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                        if (error.name === 'AbortError') {
                            showNotification('Download cancelled', 'info');
                        } else {
                            showNotification(`Download failed: ${error.message}`, 'error');
                        }
                        // Process next item in queue after error/cancellation
                        if (downloadQueue.length > 0) {
                            setTimeout(() => processDownloadQueue(), 1000);
                        }
                    });

                } catch (error) {
                    console.error('Initial download error:', error);
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    modal.style.display = 'none';
                    minimized.style.display = 'none';
                    currentDownloadController = null;
                    showNotification(`Failed to start download: ${error.message}`, 'error');
                    // Ensure focus returns to the search bar on error
                    try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                    // Process next item in queue after initial error
                    if (downloadQueue.length > 0) {
                        setTimeout(() => processDownloadQueue(), 1000);
                    }
                }
            }

            // Public download function - handles queue
            async function downloadMusicTrack(trackId, title, artistName, coverSrc) {
                // Check if already downloaded
                const downloaded = getDownloadedMusic();
                if (downloaded.some(d => d.id === String(trackId))) {
                    showNotification(`"${title}" is already downloaded`, 'info');
                    return;
                }
                
                // Check if already in queue
                if (downloadQueue.some(item => item.trackId === trackId)) {
                    showNotification(`"${title}" is already in queue`, 'info');
                    return;
                }
                
                // If currently downloading
                if (currentDownloadId || currentDownloadController) {
                    // Add to queue
                    downloadQueue.push({ trackId, title, artistName, coverSrc });
                    updateQueueDisplay();
                    showNotification(`"${title}" added to download queue (position ${downloadQueue.length})`, 'info');
                    return;
                }
                
                // Start downloading immediately (completion handler will process queue)
                await downloadMusicTrackInternal(trackId, title, artistName, coverSrc);
            }

            // Minimize download button handler
            const minimizeDownloadBtn = document.getElementById('music-download-minimize-btn');
            if (minimizeDownloadBtn) {
                minimizeDownloadBtn.addEventListener('click', () => {
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    modal.style.display = 'none';
                    minimized.style.display = 'block';
                    isDownloadMinimized = true;
                });
            }

            // Restore download button handler
            const restoreDownloadBtn = document.getElementById('music-download-restore-btn');
            if (restoreDownloadBtn) {
                restoreDownloadBtn.addEventListener('click', () => {
                    const modal = document.getElementById('music-download-modal');
                    const minimized = document.getElementById('music-download-minimized');
                    modal.style.display = 'flex';
                    minimized.style.display = 'none';
                    isDownloadMinimized = false;
                });
            }

            // Cancel download button handler (modal)
            const cancelDownloadBtn = document.getElementById('music-download-cancel-btn');
            if (cancelDownloadBtn) {
                cancelDownloadBtn.addEventListener('click', async () => {
                    try {
                        currentDownloadCancelled = true;
                        if (currentDownloadPoll) { clearInterval(currentDownloadPoll); currentDownloadPoll = null; }
                        if (currentDownloadController) {
                            try { currentDownloadController.abort(); } catch(_) {}
                        }
                        if (currentDownloadId) {
                            await fetch('/api/music/download/cancel', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ downloadId: currentDownloadId })
                            }).catch(()=>{});
                        }
                    } finally {
                        const modal = document.getElementById('music-download-modal');
                        const minimized = document.getElementById('music-download-minimized');
                        if (modal) modal.style.display = 'none';
                        if (minimized) minimized.style.display = 'none';
                        currentDownloadController = null;
                        currentDownloadFilePath = null;
                        currentDownloadId = null;
                        updateBothProgressBars('0%', '');
                        showNotification('Download cancelled', 'info');
                        // Refocus search for quick next query
                        try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                    }
                });
            }

            // Cancel download button handler (minimized)
            const cancelDownloadMinBtn = document.getElementById('music-download-cancel-minimized-btn');
            if (cancelDownloadMinBtn) {
                cancelDownloadMinBtn.addEventListener('click', async () => {
                    try {
                        currentDownloadCancelled = true;
                        if (currentDownloadPoll) { clearInterval(currentDownloadPoll); currentDownloadPoll = null; }
                        if (currentDownloadController) {
                            try { currentDownloadController.abort(); } catch(_) {}
                        }
                        if (currentDownloadId) {
                            await fetch('/api/music/download/cancel', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ downloadId: currentDownloadId })
                            }).catch(()=>{});
                        }
                    } finally {
                        const modal = document.getElementById('music-download-modal');
                        const minimized = document.getElementById('music-download-minimized');
                        if (modal) modal.style.display = 'none';
                        if (minimized) minimized.style.display = 'none';
                        currentDownloadController = null;
                        currentDownloadFilePath = null;
                        currentDownloadId = null;
                        updateBothProgressBars('0%', '');
                        showNotification('Download cancelled', 'info');
                        // Refocus search for quick next query
                        try { musicSearchInput && musicSearchInput.focus && musicSearchInput.focus(); } catch(_) {}
                    }
                });
            }

            function renderPlaylists() {
                const wrap = document.getElementById('music-playlists');
                if (!wrap) return;
                const list = document.getElementById('playlists-list');
                const empty = document.getElementById('playlists-empty');
                const pls = getPlaylists();
                list.innerHTML = '';
                if (!pls.length) {
                    empty.style.display = '';
                    return;
                }
                empty.style.display = 'none';
                pls.forEach(pl => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.innerHTML = `
                        <div class="music-info">
                            <div class="music-title">${pl.name}</div>
                            <div class="music-artist">${(pl.tracks?.length||0)} track${(pl.tracks?.length||0)!==1?'s':''}</div>
                            <div class="music-actions">
                                <button class="playlist-open-btn" data-id="${pl.id}"><i class="fas fa-folder-open"></i> Open</button>
                                <button class="playlist-export-btn" data-id="${pl.id}" title="Export playlist"><i class="fas fa-file-export"></i> Export</button>
                                <button class="playlist-delete-btn" data-id="${pl.id}"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    list.appendChild(card);
                });
                // open
                list.querySelectorAll('.playlist-open-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.getAttribute('data-id');
                        openPlaylist(id);
                    });
                });
                // export
                list.querySelectorAll('.playlist-export-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.getAttribute('data-id');
                        exportPlaylist(id);
                    });
                });
                // delete
                list.querySelectorAll('.playlist-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.getAttribute('data-id');
                        const pls = getPlaylists().filter(p => p.id !== id);
                        setPlaylists(pls);
                        renderPlaylists();
                        showNotification('Playlist deleted', 'info');
                    });
                });
            }

            function openPlaylist(id) {
                const pls = getPlaylists();
                const pl = pls.find(p => p.id === id);
                if (!pl) return;
                // Reuse results grid to show playlist content
                const resSec = document.getElementById('music-results');
                const empty = document.getElementById('music-empty');
                const mySec = document.getElementById('my-music');
                mySec.style.display = 'none';
                resSec.style.display = 'block'; empty.style.display = 'none';
                musicResultsTitle.textContent = `Playlist: ${pl.name}`;
                // mark playlist-open on page for CSS tweaks
                const musicPage = document.getElementById('music-page');
                if (musicPage) musicPage.classList.add('playlist-open');
                // Add Close Playlist button in the header
                const header = resSec.querySelector('.books-results-header');
                if (header && !header.querySelector('#playlist-close-btn')) {
                    // Add Play All button first
                    const playAllBtn = document.createElement('button');
                    playAllBtn.id = 'playlist-play-all-btn';
                    playAllBtn.className = 'action-btn';
                    playAllBtn.style.background = 'linear-gradient(135deg, #ec4899, #a855f7)';
                    playAllBtn.innerHTML = '<i class="fas fa-play"></i><span>Play All</span>';
                    header.appendChild(playAllBtn);
                    playAllBtn.addEventListener('click', () => {
                        const tracks = pl.tracks || [];
                        if (tracks.length === 0) {
                            showNotification('No tracks in this playlist', 'info');
                            return;
                        }
                        playAllTracks(tracks);
                    });
                    // Add Shuffle button next to Play All
                    const shuffleBtn = document.createElement('button');
                    shuffleBtn.id = 'playlist-shuffle-btn';
                    shuffleBtn.className = 'action-btn';
                    shuffleBtn.title = 'Shuffle and play this playlist';
                    shuffleBtn.innerHTML = '<i class="fas fa-random"></i><span>Shuffle</span>';
                    header.appendChild(shuffleBtn);
                    shuffleBtn.addEventListener('click', () => {
                        const tracks = (pl.tracks || []).slice();
                        if (tracks.length === 0) {
                            showNotification('No tracks in this playlist', 'info');
                            return;
                        }
                        for (let i = tracks.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [tracks[i], tracks[j]] = [tracks[j], tracks[i]];
                        }
                        playAllTracks(tracks);
                    });
                    
                    const closeBtn = document.createElement('button');
                    closeBtn.id = 'playlist-close-btn';
                    closeBtn.className = 'playlist-close-btn';
                    closeBtn.style.marginLeft = 'auto';
                    closeBtn.innerHTML = '<i class="fas fa-times"></i><span>Close Playlist</span>';
                    header.appendChild(closeBtn);
                    closeBtn.addEventListener('click', () => {
                        // Clear playlist-open mode and header buttons
                        if (musicPage) musicPage.classList.remove('playlist-open');
                        const pBtn = document.getElementById('playlist-play-all-btn');
                        const sBtn = document.getElementById('playlist-shuffle-btn');
                        const cBtn = document.getElementById('playlist-close-btn');
                        if (pBtn) pBtn.remove();
                        if (sBtn) sBtn.remove();
                        if (cBtn) cBtn.remove();
                        // Go back to Playlists view explicitly
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        const plsSec = document.getElementById('music-playlists');
                        if (plsSec) {
                            plsSec.style.display = 'block';
                            try { renderPlaylists(); } catch(_) {}
                        }
                    });
                }
                const tracks = pl.tracks || [];
                musicResultsCount.textContent = `${tracks.length} track${tracks.length!==1?'s':''}`;
                musicResultsGrid.innerHTML = '';
                tracks.forEach(t => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    const isDownloaded = isTrackDownloaded(t.id);
                    const downloadBtnHTML = isDownloaded 
                        ? `<button class="music-download-btn downloaded" title="Downloaded" data-id="${t.id}" data-title="${t.title.replace(/\"/g,'&quot;')}" data-artist="${t.artist.replace(/\"/g,'&quot;')}" data-cover="${t.cover}"><i class="fas fa-check-circle"></i></button>`
                        : `<button class="music-download-btn" title="Download" data-id="${t.id}" data-title="${t.title.replace(/\"/g,'&quot;')}" data-artist="${t.artist.replace(/\"/g,'&quot;')}" data-cover="${t.cover}"><i class="fas fa-download"></i></button>`;
                    card.innerHTML = `
                        <div class="music-cover"><img loading="lazy" src="${t.cover}" alt="${t.title}"></div>
                        <div class="music-info">
                            <div class="music-title">${t.title}</div>
                            <div class="music-artist">${t.artist}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${t.id}" data-title="${t.title}" data-artist="${t.artist}" data-cover="${t.cover}"><i class="fas fa-play"></i> Play</button>
                                ${downloadBtnHTML}
                                <button class="playlist-delete-btn playlist-remove-btn" data-id="${t.id}" data-pl="${id}" title="Remove from Playlist"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    musicResultsGrid.appendChild(card);
                });
                musicResultsGrid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        // When inside a playlist, set queue to that playlist's tracks
                        const tracks = (pl.tracks || []).map(t => ({ id: String(t.id), title: t.title, artist: t.artist, cover: t.cover }));
                        const idx = tracks.findIndex(t => String(t.id) === String(el.getAttribute('data-id')));
                        if (idx >= 0 && tracks.length) {
                            setPlayQueue(tracks, idx);
                        } else {
                            playMusicTrack({
                                trackId: el.getAttribute('data-id'),
                                title: el.getAttribute('data-title'),
                                artistName: el.getAttribute('data-artist'),
                                coverSrc: el.getAttribute('data-cover')
                            });
                        }
                    });
                });
                // wire download buttons
                musicResultsGrid.querySelectorAll('.music-download-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const btn = e.currentTarget;
                        const trackId = btn.getAttribute('data-id');
                        const title = btn.getAttribute('data-title');
                        const artist = btn.getAttribute('data-artist');
                        const cover = btn.getAttribute('data-cover');
                        
                        if (isTrackDownloaded(trackId)) {
                            showNotification('Track already downloaded', 'info');
                            return;
                        }
                        
                        await downloadMusicTrack(trackId, title, artist, cover);
                        // Re-render to update button state
                        openPlaylist(id);
                    });
                });
                musicResultsGrid.querySelectorAll('.playlist-remove-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const idTrack = e.currentTarget.getAttribute('data-id');
                        const pid = e.currentTarget.getAttribute('data-pl');
                        const pls = getPlaylists();
                        const pl2 = pls.find(p => p.id === pid);
                        if (pl2) {
                            pl2.tracks = (pl2.tracks||[]).filter(t => t.id !== idTrack);
                            setPlaylists(pls);
                            openPlaylist(pid);
                            showNotification('Removed from playlist', 'info');
                        }
                    });
                });
            }

            function showPlaylistChooser(track) {
                // Open the modal chooser and list playlists to add into (supports single track or array)
                playlistChooserTrack = track;
                const pls = getPlaylists();
                if (!playlistChooser || !playlistChooserList || !playlistChooserEmpty) return;
                playlistChooserList.innerHTML = '';
                if (!pls.length) {
                    playlistChooserEmpty.style.display = '';
                } else {
                    playlistChooserEmpty.style.display = 'none';
                    pls.forEach(pl => {
                        const row = document.createElement('div');
                        row.className = 'music-card';
                        row.innerHTML = `
                            <div class="music-info">
                                <div class="music-title">${pl.name}</div>
                                <div class="music-artist">${(pl.tracks?.length||0)} track${(pl.tracks?.length||0)!==1?'s':''}</div>
                                <div class="music-actions">
                                    <button class="playlist-open-btn playlist-choose-btn" data-id="${pl.id}"><i class="fas fa-check"></i><span>Add Here</span></button>
                                </div>
                            </div>`;
                        playlistChooserList.appendChild(row);
                    });
                    playlistChooserList.querySelectorAll('.playlist-choose-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const pid = btn.getAttribute('data-id');
                            const name = (getPlaylists().find(p => p.id===pid)?.name) || 'playlist';
                            if (Array.isArray(playlistChooserTrack)) {
                                const { added, total } = addTracksToPlaylist(pid, playlistChooserTrack);
                                if (added > 0) {
                                    showNotification(`Added ${added} of ${total} to ${name}`,'success');
                                } else {
                                    showNotification('All tracks already in playlist','info');
                                }
                            } else {
                                const ok = addTrackToPlaylist(pid, playlistChooserTrack);
                                showNotification(ok ? `Added to ${name}` : 'Already in playlist', ok ? 'success' : 'info');
                            }
                            closePlaylistChooser();
                        });
                    });
                }
                playlistChooser.style.display = 'flex';
            }

            function closePlaylistChooser() {
                if (playlistChooser) playlistChooser.style.display = 'none';
                playlistChooserTrack = null;
                if (playlistChooserNewName) playlistChooserNewName.value = '';
            }

            // Export playlist to JSON file
            async function exportPlaylist(playlistId) {
                try {
                    const playlists = getPlaylists();
                    const playlist = playlists.find(p => p.id === playlistId);
                    
                    if (!playlist) {
                        showNotification('Playlist not found', 'error');
                        return;
                    }

                    // Prepare playlist data for export
                    const exportData = {
                        name: playlist.name,
                        tracks: playlist.tracks || [],
                        exportedAt: new Date().toISOString(),
                        version: '1.0'
                    };

                    const jsonData = JSON.stringify(exportData, null, 2);

                    // Show save dialog
                    if (!window.electronAPI?.showSaveDialog) {
                        // Fallback: download as file in browser
                        const blob = new Blob([jsonData], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${playlist.name.replace(/[^a-z0-9]/gi, '_')}_playlist.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        showNotification('Playlist exported', 'success');
                        return;
                    }

                    const result = await window.electronAPI.showSaveDialog({
                        title: 'Export Playlist',
                        defaultPath: `${playlist.name.replace(/[^a-z0-9]/gi, '_')}_playlist.json`,
                        filters: [
                            { name: 'JSON Files', extensions: ['json'] },
                            { name: 'All Files', extensions: ['*'] }
                        ]
                    });

                    if (result.canceled || !result.filePath) {
                        return;
                    }

                    // Write file
                    const writeResult = await window.electronAPI.writeFile(result.filePath, jsonData);
                    
                    if (writeResult.success) {
                        showNotification('Playlist exported successfully', 'success');
                    } else {
                        showNotification('Failed to export playlist: ' + (writeResult.error || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Export error:', error);
                    showNotification('Failed to export playlist', 'error');
                }
            }

            // Helper to process imported playlist data
            function processPlaylistImport(importData) {
                // Validate data
                if (!importData.name || !Array.isArray(importData.tracks)) {
                    showNotification('Invalid playlist data', 'error');
                    return;
                }

                // Check if playlist with same name exists
                const playlists = getPlaylists();
                let playlistName = importData.name;
                let counter = 1;
                
                while (playlists.find(p => p.name.toLowerCase() === playlistName.toLowerCase())) {
                    playlistName = `${importData.name} (${counter})`;
                    counter++;
                }

                // Create new playlist
                const newPlaylist = {
                    id: 'pl_' + Math.random().toString(36).slice(2, 10),
                    name: playlistName,
                    tracks: importData.tracks
                };

                playlists.push(newPlaylist);
                setPlaylists(playlists);
                renderPlaylists();

                showNotification(`Playlist "${playlistName}" imported with ${importData.tracks.length} track${importData.tracks.length !== 1 ? 's' : ''}`, 'success');
            }

            // Import playlist from JSON file
            async function importPlaylist() {
                try {
                    if (!window.electronAPI?.showOpenDialog) {
                        // Fallback for web/missing API: use input type=file
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '.json';
                        input.style.display = 'none';
                        document.body.appendChild(input);
                        
                        input.onchange = (e) => {
                            const file = e.target.files[0];
                            if (!file) {
                                document.body.removeChild(input);
                                return;
                            }
                            
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                try {
                                    const importData = JSON.parse(event.target.result);
                                    processPlaylistImport(importData);
                                } catch (err) {
                                    showNotification('Invalid playlist file format', 'error');
                                }
                                document.body.removeChild(input);
                            };
                            reader.onerror = () => {
                                showNotification('Failed to read file', 'error');
                                document.body.removeChild(input);
                            };
                            reader.readAsText(file);
                        };
                        
                        input.click();
                        return;
                    }

                    const result = await window.electronAPI.showOpenDialog({
                        title: 'Import Playlist',
                        filters: [
                            { name: 'JSON Files', extensions: ['json'] },
                            { name: 'All Files', extensions: ['*'] }
                        ],
                        properties: ['openFile']
                    });

                    if (result.canceled || !result.filePaths || result.filePaths.length === 0) {
                        return;
                    }

                    // Read file
                    const readResult = await window.electronAPI.readFile(result.filePaths[0]);
                    
                    if (!readResult.success) {
                        showNotification('Failed to read file: ' + (readResult.error || 'Unknown error'), 'error');
                        return;
                    }

                    // Parse JSON
                    let importData;
                    try {
                        importData = JSON.parse(readResult.data);
                    } catch (e) {
                        showNotification('Invalid playlist file format', 'error');
                        return;
                    }

                    processPlaylistImport(importData);
                } catch (error) {
                    console.error('Import error:', error);
                    showNotification('Failed to import playlist', 'error');
                }
            }

            function renderDownloadedMusic() {
                const wrap = document.getElementById('music-downloaded');
                if (!wrap) return;
                const grid = document.getElementById('music-downloaded-grid');
                const empty = document.getElementById('music-downloaded-empty');
                const countEl = document.getElementById('music-downloaded-count');
                const playAllBtn = document.getElementById('downloaded-play-all-btn');
                const shuffleBtn = document.getElementById('downloaded-shuffle-btn');
                const downloaded = getDownloadedMusic();
                grid.innerHTML = '';
                if (!downloaded.length) {
                    if (countEl) countEl.textContent = '0 items';
                    empty.style.display = '';
                    if (playAllBtn) playAllBtn.style.display = 'none';
                    if (shuffleBtn) shuffleBtn.style.display = 'none';
                    return;
                }
                empty.style.display = 'none';
                if (countEl) countEl.textContent = `${downloaded.length} item${downloaded.length !== 1 ? 's' : ''}`;
                if (playAllBtn) playAllBtn.style.display = '';
                if (shuffleBtn) shuffleBtn.style.display = '';
                downloaded.forEach(track => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    card.innerHTML = `
                        <div class="music-cover"><img loading="lazy" src="${track.cover}" alt="${track.title}"></div>
                        <div class="music-info">
                            <div class="music-title">${track.title}</div>
                            <div class="music-artist">${track.artist}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${track.id}" data-title="${track.title}" data-artist="${track.artist}" data-cover="${track.cover}"><i class="fas fa-play"></i> Play</button>
                                <button class="music-folder-btn" data-path="${track.filePath}" title="Open Folder"><i class="fas fa-folder-open"></i></button>
                                <button class="music-delete-downloaded-btn" data-id="${track.id}" data-path="${track.filePath}" title="Delete"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    grid.appendChild(card);
                });

                // Play button handler
                grid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const el = e.currentTarget;
                        const tracks = downloaded.map(t => ({ id: String(t.id), title: t.title, artist: t.artist, cover: t.cover }));
                        const idx = tracks.findIndex(t => String(t.id) === String(el.getAttribute('data-id')));
                        if (idx >= 0 && tracks.length) {
                            setPlayQueue(tracks, idx);
                        } else {
                            playMusicTrack({
                                trackId: el.getAttribute('data-id'),
                                title: el.getAttribute('data-title'),
                                artistName: el.getAttribute('data-artist'),
                                coverSrc: el.getAttribute('data-cover')
                            });
                        }
                    });
                });

                // Open folder button handler
                grid.querySelectorAll('.music-folder-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const filePath = e.currentTarget.getAttribute('data-path');
                        if (filePath && window.electronAPI?.showFolderInExplorer) {
                            try {
                                // Get the directory path from file path (cross-platform)
                                const lastSlash = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\'));
                                const dirPath = lastSlash > 0 ? filePath.substring(0, lastSlash) : filePath;
                                await window.electronAPI.showFolderInExplorer(dirPath);
                            } catch (error) {
                                console.error('Failed to open folder:', error);
                                showNotification('Failed to open folder', 'error');
                            }
                        }
                    });
                });

                // Delete button handler
                grid.querySelectorAll('.music-delete-downloaded-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const trackId = e.currentTarget.getAttribute('data-id');
                        const filePath = e.currentTarget.getAttribute('data-path');
                        
                        if (!confirm('Delete this downloaded track?')) return;

                        try {
                            // Delete file from disk
                            const res = await fetch('/api/music/delete', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ filePath })
                            });

                            if (!res.ok) {
                                const err = await res.json();
                                throw new Error(err.error || 'Delete failed');
                            }

                            // Remove from downloaded list and any active play queue
                            removeFromDownloaded(trackId);
                            if (Array.isArray(window.currentPlayQueue)) {
                                window.currentPlayQueue = window.currentPlayQueue.filter(t => String(t.id) !== String(trackId));
                                if (typeof window.currentQueueIndex === 'number') {
                                    window.currentQueueIndex = Math.min(window.currentQueueIndex, Math.max(0, window.currentPlayQueue.length - 1));
                                }
                            }
                            
                            // Re-render
                            renderDownloadedMusic();
                            showNotification('Track deleted', 'success');

                            // Re-render current music results if showing to update button
                            const currentResults = window.currentMusicResults || [];
                            const currentQuery = window.currentMusicQuery || '';
                            if (currentResults.length > 0) {
                                displayMusicResults(currentResults, currentQuery);
                            }

                        } catch (error) {
                            console.error('Delete error:', error);
                            showNotification(`Delete failed: ${error.message}`, 'error');
                        }
                    });
                });
            }

            // Playlist chooser events
            if (playlistChooserBack && playlistChooser) {
                playlistChooserBack.addEventListener('click', closePlaylistChooser);
                playlistChooser.addEventListener('click', (e) => {
                    if (e.target === playlistChooser) closePlaylistChooser();
                });
            }
            if (playlistChooserCreate) {
                playlistChooserCreate.addEventListener('click', () => {
                    const name = (playlistChooserNewName.value || '').trim();
                    if (!name) { showNotification('Enter a playlist name', 'warning'); return; }
                    const pls = getPlaylists();
                    if (pls.find(p => p.name.toLowerCase() === name.toLowerCase())) { showNotification('Playlist exists', 'info'); return; }
                    const id = 'pl_' + Math.random().toString(36).slice(2,10);
                    pls.push({ id, name, tracks: [] });
                    setPlaylists(pls);
                    playlistChooserNewName.value = '';
                    // Refresh chooser list
                    showPlaylistChooser(playlistChooserTrack || null);
                    showNotification('Playlist created', 'success');
                });
            }

            // Removed offline rendering and related actions

            // Render My Music grid
            function renderMyMusic() {
                const list = getMyMusic();
                const grid = document.getElementById('my-music-grid');
                const count = document.getElementById('my-music-count');
                const empty = document.getElementById('my-music-empty');
                grid.innerHTML = '';
                if (!list.length) {
                    count.textContent = '0 items';
                    empty.style.display = '';
                    return;
                }
                empty.style.display = 'none';
                count.textContent = `${list.length} item${list.length!==1?'s':''}`;
                list.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'music-card';
                    const isDownloaded = isTrackDownloaded(item.id);
                    const downloadBtnHTML = isDownloaded 
                        ? `<button class="music-download-btn downloaded" title="Downloaded" data-id="${item.id}" data-title="${item.title.replace(/\"/g,'&quot;')}" data-artist="${item.artist.replace(/\"/g,'&quot;')}" data-cover="${item.cover}"><i class="fas fa-check-circle"></i></button>`
                        : `<button class="music-download-btn" title="Download" data-id="${item.id}" data-title="${item.title.replace(/\"/g,'&quot;')}" data-artist="${item.artist.replace(/\"/g,'&quot;')}" data-cover="${item.cover}"><i class="fas fa-download"></i></button>`;
                    card.innerHTML = `
                        <div class="music-cover"><img loading="lazy" src="${item.cover}" alt="${item.title}"></div>
                        <div class="music-info">
                            <div class="music-title">${item.title}</div>
                            <div class="music-artist">${item.artist}</div>
                            <div class="music-actions">
                                <button class="music-play-btn" data-id="${item.id}"><i class="fas fa-play"></i> Play</button>
                                ${downloadBtnHTML}
                                <button class="music-add-btn" title="Remove from My Music" data-remove="true" data-id="${item.id}"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`;
                    grid.appendChild(card);
                });
                // wire play/open
                grid.querySelectorAll('.music-play-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const id = String(e.currentTarget.getAttribute('data-id'));
                        const list = getMyMusic().map(x => ({ id: String(x.id), title: x.title, artist: x.artist, cover: x.cover }));
                        const idx = list.findIndex(x => String(x.id) === id);
                        if (idx >= 0 && list.length) {
                            setPlayQueue(list, idx);
                        } else {
                            const card = e.currentTarget.closest('.music-card');
                            const title = card.querySelector('.music-title')?.textContent || 'Unknown Title';
                            const artistName = card.querySelector('.music-artist')?.textContent || 'Unknown Artist';
                            const coverSrc = card.querySelector('img')?.src || '';
                            await playMusicTrack({ trackId: id, title, artistName, coverSrc });
                        }
                    });
                });
                // wire download buttons
                grid.querySelectorAll('.music-download-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const btn = e.currentTarget;
                        const trackId = btn.getAttribute('data-id');
                        const title = btn.getAttribute('data-title');
                        const artist = btn.getAttribute('data-artist');
                        const cover = btn.getAttribute('data-cover');
                        
                        if (isTrackDownloaded(trackId)) {
                            showNotification('Track already downloaded', 'info');
                            return;
                        }
                        
                        await downloadMusicTrack(trackId, title, artist, cover);
                        // Re-render to update button state
                        renderMyMusic();
                    });
                });
                grid.querySelectorAll('.music-add-btn[data-remove="true"]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.getAttribute('data-id');
                        const list2 = getMyMusic().filter(x => x.id !== id);
                        setMyMusic(list2);
                        renderMyMusic();
                        showNotification('Removed from My Music', 'info');
                    });
                });
            }

            // Toggle My Music section
            const myBtn = document.getElementById('music-my-btn');
            if (myBtn) {
                myBtn.addEventListener('click', () => {
                    const mySec = document.getElementById('my-music');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const plsSec = document.getElementById('music-playlists');
                    const downloadedSec = document.getElementById('music-downloaded');
                    const myAlbumsSec2 = document.getElementById('my-albums');
                    const albumListSec2 = document.getElementById('music-albums');
                    const albumViewSec2 = document.getElementById('music-album-view');
                    const showing = mySec.style.display !== 'none';
                    if (showing) {
                        mySec.style.display = 'none';
                        // Restore last state: show results if present else empty
                        if (musicResultsGrid && musicResultsGrid.children.length) {
                            resSec.style.display = 'block';
                            empty.style.display = 'none';
                        } else {
                            resSec.style.display = 'none';
                            empty.style.display = '';
                        }
                        plsSec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (myAlbumsSec2) myAlbumsSec2.style.display = 'none';
                        if (albumListSec2) albumListSec2.style.display = 'none';
                        if (albumViewSec2) albumViewSec2.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    } else {
                        renderMyMusic();
                        mySec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        plsSec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (myAlbumsSec2) myAlbumsSec2.style.display = 'none';
                        if (albumListSec2) albumListSec2.style.display = 'none';
                        if (albumViewSec2) albumViewSec2.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    }
                });
            }

            // Toggle Playlists
            const playlistsBtn = document.getElementById('music-playlists-btn');
            if (playlistsBtn) {
                playlistsBtn.addEventListener('click', () => {
                    const sec = document.getElementById('music-playlists');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const mySec = document.getElementById('my-music');
                    const downloadedSec = document.getElementById('music-downloaded');
                    const myAlbumsSec3 = document.getElementById('my-albums');
                    const showing = sec.style.display !== 'none';
                    if (showing) {
                        sec.style.display = 'none';
                        if (musicResultsGrid && musicResultsGrid.children.length) { resSec.style.display = 'block'; empty.style.display = 'none'; }
                        else { resSec.style.display = 'none'; empty.style.display = ''; }
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                        if (myAlbumsSec3) myAlbumsSec3.style.display = 'none';
                    } else {
                        renderPlaylists();
                        sec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        mySec.style.display = 'none';
                        if (downloadedSec) downloadedSec.style.display = 'none';
                        if (myAlbumsSec3) myAlbumsSec3.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    }
                });
            }

            // Toggle Downloaded
            const downloadedBtn = document.getElementById('music-downloaded-btn');
            if (downloadedBtn) {
                downloadedBtn.addEventListener('click', async () => {
                    const sec = document.getElementById('music-downloaded');
                    const resSec = document.getElementById('music-results');
                    const empty = document.getElementById('music-empty');
                    const mySec = document.getElementById('my-music');
                    const plsSec = document.getElementById('music-playlists');
                    const myAlbumsSec = document.getElementById('my-albums');
                    const showing = sec.style.display !== 'none';
                    if (showing) {
                        sec.style.display = 'none';
                        if (musicResultsGrid && musicResultsGrid.children.length) { resSec.style.display = 'block'; empty.style.display = 'none'; }
                        else { resSec.style.display = 'none'; empty.style.display = ''; }
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                        if (myAlbumsSec) myAlbumsSec.style.display = 'none';
                    } else {
                        // Reconcile with disk before showing the list
                        try { await reconcileDownloadedMusicWithDisk(); } catch(_){ }
                        renderDownloadedMusic();
                        sec.style.display = 'block';
                        resSec.style.display = 'none';
                        empty.style.display = 'none';
                        mySec.style.display = 'none';
                        if (plsSec) plsSec.style.display = 'none';
                        if (myAlbumsSec) myAlbumsSec.style.display = 'none';
                        const musicPage = document.getElementById('music-page');
                        if (musicPage) musicPage.classList.remove('playlist-open');
                    }
                });
            }

            // Downloaded Music Play All button
            const downloadedPlayAllBtn = document.getElementById('downloaded-play-all-btn');
            if (downloadedPlayAllBtn) {
                downloadedPlayAllBtn.addEventListener('click', () => {
                    const downloaded = getDownloadedMusic();
                    if (downloaded.length === 0) {
                        showNotification('No tracks to play', 'info');
                        return;
                    }
                    const tracks = downloaded.map(t => ({
                        id: String(t.id),
                        title: t.title,
                        artist: t.artist,
                        cover: t.cover
                    }));
                    playAllTracks(tracks);
                });
            }

            // Downloaded Music Shuffle button
            const downloadedShuffleBtn = document.getElementById('downloaded-shuffle-btn');
            if (downloadedShuffleBtn) {
                downloadedShuffleBtn.addEventListener('click', () => {
                    const downloaded = getDownloadedMusic();
                    if (downloaded.length === 0) {
                        showNotification('No tracks to play', 'info');
                        return;
                    }
                    const tracks = downloaded.map(t => ({
                        id: String(t.id),
                        title: t.title,
                        artist: t.artist,
                        cover: t.cover
                    }));
                    // Shuffle the tracks array using Fisher-Yates algorithm
                    for (let i = tracks.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [tracks[i], tracks[j]] = [tracks[j], tracks[i]];
                    }
                    playAllTracks(tracks);
                });
            }

            const createPlBtn = document.getElementById('playlist-create-btn');
            const plNameInput = document.getElementById('playlist-name-input');
            if (createPlBtn) {
                createPlBtn.addEventListener('click', () => {
                    const name = (plNameInput.value || '').trim();
                    if (!name) { showNotification('Enter a playlist name', 'warning'); return; }
                    const pls = getPlaylists();
                    if (pls.find(p => p.name.toLowerCase() === name.toLowerCase())) { showNotification('Playlist exists', 'info'); return; }
                    const id = 'pl_' + Math.random().toString(36).slice(2,10);
                    pls.push({ id, name, tracks: [] });
                    setPlaylists(pls);
                    plNameInput.value = '';
                    renderPlaylists();
                    showNotification('Playlist created', 'success');
                });
            }

            // Import playlist button
            const importPlBtn = document.getElementById('playlist-import-btn');
            if (importPlBtn) {
                importPlBtn.addEventListener('click', () => {
                    importPlaylist();
                });
            }

            // Offline removed

            async function playMusicTrack({ trackId, title, artistName, coverSrc }) {
                if (!trackId) {
                    showNotification('Missing track ID', 'error');
                    return;
                }
                
                // Flag to track if this playback request is still valid
                let isPlaybackCancelled = false;
                
                try {
                    // Check if this track is already downloaded
                    const downloaded = getDownloadedMusic();
                    const downloadedTrack = downloaded.find(t => String(t.id) === String(trackId));
                    
                    if (downloadedTrack && downloadedTrack.filePath) {
                        // Play from downloaded file
                        console.log('[MUSIC] Playing downloaded file:', downloadedTrack.filePath);
                        
                        // Show modal or mini player based on current state
                        if (isPlayerMinimized) {
                            miniPlayer.style.display = 'block';
                            musicModal.style.display = 'none';
                        } else {
                            musicModal.style.display = 'flex';
                            miniPlayer.style.display = 'none';
                        }
                        
                        musicModalTitle.textContent = 'Now Playing (Offline)';
                        musicSongTitle.textContent = title;
                        musicArtist.textContent = artistName;
                        if (coverSrc) musicCover.src = coverSrc;
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                        
                        // Update mini player info
                        if (miniPlayerSongTitle) miniPlayerSongTitle.textContent = title;
                        if (miniPlayerArtist) miniPlayerArtist.textContent = artistName;
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                        // Clear existing sources
                        while (musicAudio.firstChild) musicAudio.removeChild(musicAudio.firstChild);
                        
                        // Use local file endpoint
                        const source = document.createElement('source');
                        source.src = `/api/music/serve/${encodeURIComponent(downloadedTrack.filePath)}`;
                        // Our downloaded files are MP3s, so specify the correct MIME type
                        source.type = 'audio/mpeg';
                        musicAudio.appendChild(source);

                        // Load then check if player is still open before playing
                        musicAudio.load();
                        
                        // Check if player is still visible before playing
                        if (musicModal.style.display === 'none' && miniPlayer.style.display === 'none') {
                            console.log('[MUSIC] Player was closed, aborting playback');
                            return;
                        }
                        
                        try {
                            await musicAudio.play();
                        } catch (err) {
                            // Check again after retry delay
                            await new Promise(r => setTimeout(r, 150));
                            if (musicModal.style.display === 'none' && miniPlayer.style.display === 'none') {
                                console.log('[MUSIC] Player was closed during retry, aborting playback');
                                return;
                            }
                            await musicAudio.play();
                        }
                        
                        // Final check before updating UI
                        if (musicModal.style.display === 'none' && miniPlayer.style.display === 'none') {
                            musicAudio.pause();
                            return;
                        }
                        
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        updateTimeDisplays();
                        
                        // Update Discord presence for music
                        updateDiscordForMusic(title, artistName, '');
                        return;
                    }
                    
                    // Not downloaded - stream from TIDAL
                    // Show modal or mini player based on current state
                    if (isPlayerMinimized) {
                        miniPlayer.style.display = 'block';
                        musicModal.style.display = 'none';
                    } else {
                        musicModal.style.display = 'flex';
                        miniPlayer.style.display = 'none';
                    }
                    
                    musicModalTitle.textContent = 'Now Playing';
                    musicSongTitle.textContent = title;
                    musicArtist.textContent = artistName;
                    if (coverSrc) musicCover.src = coverSrc;
                    musicPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    
                    // Update mini player info
                    if (miniPlayerSongTitle) miniPlayerSongTitle.textContent = title;
                    if (miniPlayerArtist) miniPlayerArtist.textContent = artistName;
                    if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                    // Obtain stream URL via our API (using Deezer metadata) instead of hardcoded proxy
                    const apiResp = await musicApiFetch(`/api/stream-url?trackId=${encodeURIComponent(trackId)}`);
                    const streamUrl = apiResp && apiResp.streamUrl ? apiResp.streamUrl : '';
                    if (!streamUrl) {
                        console.error('[MUSIC] Failed to get stream URL');
                        showNotification('Failed to get stream URL', 'error');
                        musicModal.style.display = 'none';
                        miniPlayer.style.display = 'none';
                        return;
                    }
                    // Check if player was closed before preparing source
                    if (musicModal.style.display === 'none' && miniPlayer.style.display === 'none') {
                        console.log('[MUSIC] Player was closed before stream, aborting playback');
                        return;
                    }
                    // Clear existing sources
                    while (musicAudio.firstChild) musicAudio.removeChild(musicAudio.firstChild);
                    // Assign stream URL directly to audio element
                    musicAudio.src = streamUrl;
                    // Load then check if player is still open before playing
                    musicAudio.load();
                    // Check if player is still visible before playing
                    if (musicModal.style.display === 'none' && miniPlayer.style.display === 'none') {
                        console.log('[MUSIC] Player was closed before playback, aborting');
                        return;
                    }
                    try {
                        await musicAudio.play();
                    } catch (err) {
                        // Check again after retry delay
                        await new Promise(r => setTimeout(r, 150));
                        if (musicModal.style.display === 'none' && miniPlayer.style.display === 'none') {
                            console.log('[MUSIC] Player was closed during retry, aborting playback');
                            return;
                        }
                        await musicAudio.play();
                    }
                    // Final check before updating UI
                    if (musicModal.style.display === 'none' && miniPlayer.style.display === 'none') {
                        musicAudio.pause();
                        return;
                    }
                    
                    musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    updateTimeDisplays();
                    
                    // Update Discord presence for music
                    updateDiscordForMusic(title, artistName, '');
                } catch (e) {
                    console.error('[MUSIC] Play error', e);
                    showNotification('Failed to play track', 'error');
                    // Only close if player is still visible
                    if (musicModal.style.display !== 'none' || miniPlayer.style.display !== 'none') {
                        musicModal.style.display = 'none';
                        miniPlayer.style.display = 'none';
                    }
                }
            }

            // Fully close/stop music modal and unload audio
            function closeMusicModal() {
                // Clear Discord presence when music stops
                if (discordMusicActive) {
                    clearDiscordPresence();
                }
                
                try {
                    if (musicAudio) {
                        try { musicAudio.pause(); } catch(_) {}
                        // Clear source(s) to stop network streaming
                        musicAudio.removeAttribute('src');
                        while (musicAudio.firstChild) musicAudio.removeChild(musicAudio.firstChild);
                        musicAudio.load();
                    }
                } catch(_) {}
                if (musicProgressFill) musicProgressFill.style.width = '0%';
                if (musicCurrentTime) musicCurrentTime.textContent = '0:00';
                if (musicTotalTime) musicTotalTime.textContent = '0:00';
                if (musicPlayPauseBtn) musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                if (musicModal) musicModal.style.display = 'none';
                if (miniPlayer) miniPlayer.style.display = 'none';
                isPlayerMinimized = false;
            }

            // Play All functionality and queue management
            let currentPlayQueue = [];
            let currentQueueIndex = 0;
            const MUSIC_AUTOPLAY_KEY = 'pt_music_autoplay_next_v1';
            let musicAutoPlayNext = false;
            let isPlayerMinimized = false; // Track if player is minimized

            // hydrate autoplay setting
            try {
                const savedAuto = localStorage.getItem(MUSIC_AUTOPLAY_KEY);
                musicAutoPlayNext = savedAuto === '1';
            } catch(_) {}

            function updateAutoplayToggleUI() {
                if (!musicAutoplayToggle) return;
                if (musicAutoPlayNext) {
                    musicAutoplayToggle.style.background = 'linear-gradient(135deg, rgba(236,72,153,0.25), rgba(168,85,247,0.25))';
                    musicAutoplayToggle.style.borderColor = 'rgba(236,72,153,0.55)';
                    musicAutoplayToggle.style.color = '#fff';
                } else {
                    musicAutoplayToggle.style.background = 'rgba(236,72,153,0.08)';
                    musicAutoplayToggle.style.borderColor = 'rgba(236,72,153,0.35)';
                    musicAutoplayToggle.style.color = '#ec4899';
                }
            }
            updateAutoplayToggleUI();
            if (musicAutoplayToggle) {
                musicAutoplayToggle.addEventListener('click', () => {
                    musicAutoPlayNext = !musicAutoPlayNext;
                    try { localStorage.setItem(MUSIC_AUTOPLAY_KEY, musicAutoPlayNext ? '1' : '0'); } catch(_) {}
                    updateAutoplayToggleUI();
                    showNotification(`Autoplay ${musicAutoPlayNext ? 'enabled' : 'disabled'}`, 'info');
                });
            }

            function setPlayQueue(tracks, startIndex) {
                if (!Array.isArray(tracks) || tracks.length === 0) {
                    currentPlayQueue = [];
                    currentQueueIndex = 0;
                    return false;
                }
                currentPlayQueue = tracks;
                currentQueueIndex = Math.max(0, Math.min(startIndex || 0, tracks.length - 1));
                const t = currentPlayQueue[currentQueueIndex];
                playMusicTrack({ trackId: t.id, title: t.title, artistName: t.artist, coverSrc: t.cover });
                return true;
            }

            function playAllTracks(tracks) {
                if (!tracks || tracks.length === 0) {
                    showNotification('No tracks to play', 'info');
                    return;
                }
                // Ensure Autoplay Next is ON for Play All so it advances through the queue
                musicAutoPlayNext = true;
                try { localStorage.setItem(MUSIC_AUTOPLAY_KEY, '1'); } catch(_) {}
                updateAutoplayToggleUI();
                
                // Store the queue
                currentPlayQueue = tracks;
                currentQueueIndex = 0;
                
                // Play the first track
                const firstTrack = tracks[0];
                playMusicTrack({
                    trackId: firstTrack.id,
                    title: firstTrack.title,
                    artistName: firstTrack.artist,
                    coverSrc: firstTrack.cover
                });
                
                showNotification(`Playing ${tracks.length} track${tracks.length !== 1 ? 's' : ''}`, 'success');
            }

            function playNextInQueue() {
                if (currentPlayQueue.length === 0) return;
                
                currentQueueIndex++;
                
                if (currentQueueIndex >= currentPlayQueue.length) {
                    // Queue finished
                    currentPlayQueue = [];
                    currentQueueIndex = 0;
                    showNotification('Queue finished', 'info');
                    if (musicAutoPlayNext) {
                        // exit the player when autoplay is on and queue ends
                        closeMusicModal();
                    }
                    return;
                }
                
                // Play next track
                const nextTrack = currentPlayQueue[currentQueueIndex];
                playMusicTrack({
                    trackId: nextTrack.id,
                    title: nextTrack.title,
                    artistName: nextTrack.artist,
                    coverSrc: nextTrack.cover
                });
            }

            function playPreviousInQueue() {
                if (currentPlayQueue.length === 0) return;
                // If we're >3s into the current track, just restart it
                if ((musicAudio?.currentTime || 0) > 3) {
                    try { musicAudio.currentTime = 0; } catch(_) {}
                    return;
                }
                if (currentQueueIndex <= 0) return;
                currentQueueIndex--;
                const prev = currentPlayQueue[currentQueueIndex];
                playMusicTrack({
                    trackId: prev.id,
                    title: prev.title,
                    artistName: prev.artist,
                    coverSrc: prev.cover
                });
            }

            // Modal Controls
            function updateTimeDisplays() {
                musicCurrentTime.textContent = fmtTime(musicAudio.currentTime || 0);
                musicTotalTime.textContent = fmtTime(musicAudio.duration || 0);
                const p = (musicAudio.currentTime || 0) / (musicAudio.duration || 1) * 100;
                musicProgressFill.style.width = `${p}%`;
                
                // Update mini player displays too
                if (miniCurrentTime) miniCurrentTime.textContent = fmtTime(musicAudio.currentTime || 0);
                if (miniTotalTime) miniTotalTime.textContent = fmtTime(musicAudio.duration || 0);
                if (miniProgressFill) miniProgressFill.style.width = `${p}%`;
            }
            
            // Minimize/Maximize functions
            function minimizeMusicPlayer() {
                if (musicModal) musicModal.style.display = 'none';
                if (miniPlayer) miniPlayer.style.display = 'block';
                isPlayerMinimized = true;
                // Sync play/pause state
                if (miniPlayPauseBtn) {
                    miniPlayPauseBtn.innerHTML = musicAudio.paused ? '<i class="fas fa-play"></i>' : '<i class="fas fa-pause"></i>';
                }
            }
            
            function maximizeMusicPlayer() {
                if (miniPlayer) miniPlayer.style.display = 'none';
                if (musicModal) musicModal.style.display = 'flex';
                isPlayerMinimized = false;
            }

            if (musicAudio) {
                musicAudio.addEventListener('timeupdate', updateTimeDisplays);
                musicAudio.addEventListener('loadedmetadata', updateTimeDisplays);
                musicAudio.addEventListener('ended', () => {
                    musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    // Auto-play next track in queue if available and enabled
                    if (musicAutoPlayNext) {
                        if (currentPlayQueue.length > 0 && currentQueueIndex < currentPlayQueue.length - 1) {
                            setTimeout(() => playNextInQueue(), 400);
                            return;
                        }
                        // If queue is empty or finished, exit player when autoplay is enabled
                        if (currentPlayQueue.length === 0 || currentQueueIndex >= currentPlayQueue.length - 1) {
                            setTimeout(() => closeMusicModal(), 250);
                        }
                    }
                });
            }

            if (musicPlayPauseBtn) {
                musicPlayPauseBtn.addEventListener('click', async () => {
                    if (musicAudio.paused) {
                        try { await musicAudio.play(); } catch(_) {}
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        musicAudio.pause();
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
            }

            if (musicBackwardBtn) {
                musicBackwardBtn.addEventListener('click', () => {
                    musicAudio.currentTime = Math.max(0, (musicAudio.currentTime || 0) - 10);
                    updateTimeDisplays();
                });
            }

            if (musicForwardBtn) {
                musicForwardBtn.addEventListener('click', () => {
                    const dur = musicAudio.duration || 0;
                    musicAudio.currentTime = Math.min(dur, (musicAudio.currentTime || 0) + 10);
                    updateTimeDisplays();
                });
            }

            if (musicNextTrackBtn) {
                musicNextTrackBtn.addEventListener('click', () => {
                    if (currentPlayQueue.length === 0) return;
                    // Jump to next or finish
                    if (currentQueueIndex < currentPlayQueue.length - 1) playNextInQueue();
                    else closeMusicModal();
                });
            }

            if (musicPrevTrackBtn) {
                musicPrevTrackBtn.addEventListener('click', () => {
                    playPreviousInQueue();
                });
            }

            if (musicProgressBar) {
                musicProgressBar.addEventListener('click', (e) => {
                    const rect = musicProgressBar.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const ratio = Math.min(1, Math.max(0, x / rect.width));
                    musicAudio.currentTime = ratio * (musicAudio.duration || 0);
                    updateTimeDisplays();
                });
            }

            if (musicVolumeSlider) {
                const setVolumeFromEvent = (clientX) => {
                    const rect = musicVolumeSlider.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const ratio = Math.min(1, Math.max(0, x / rect.width));
                    musicAudio.volume = ratio;
                    musicVolumeFill.style.width = `${ratio * 100}%`;
                };
                musicVolumeSlider.addEventListener('click', (e) => setVolumeFromEvent(e.clientX));
            }

            if (musicModalBack && musicModal) {
                musicModalBack.addEventListener('click', closeMusicModal);
                musicModal.addEventListener('click', (e) => {
                    if (e.target === musicModal) closeMusicModal();
                });
            }
            
            // Minimize/Maximize button handlers
            if (musicModalMinimize) {
                musicModalMinimize.addEventListener('click', () => {
                    minimizeMusicPlayer();
                    // Update mini player info
                    if (miniPlayerSongTitle) miniPlayerSongTitle.textContent = musicSongTitle.textContent;
                    if (miniPlayerArtist) miniPlayerArtist.textContent = musicArtist.textContent;
                });
            }
            
            if (miniPlayerMaximize) {
                miniPlayerMaximize.addEventListener('click', maximizeMusicPlayer);
            }
            
            // Mini player controls
            if (miniPlayPauseBtn) {
                miniPlayPauseBtn.addEventListener('click', async () => {
                    if (musicAudio.paused) {
                        try { await musicAudio.play(); } catch(_) {}
                        miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        musicAudio.pause();
                        miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
            }
            
            if (miniBackwardBtn) {
                miniBackwardBtn.addEventListener('click', () => {
                    musicAudio.currentTime = Math.max(0, (musicAudio.currentTime || 0) - 10);
                    updateTimeDisplays();
                });
            }
            
            if (miniForwardBtn) {
                miniForwardBtn.addEventListener('click', () => {
                    const dur = musicAudio.duration || 0;
                    musicAudio.currentTime = Math.min(dur, (musicAudio.currentTime || 0) + 10);
                    updateTimeDisplays();
                });
            }
            
            if (miniPrevTrackBtn) {
                miniPrevTrackBtn.addEventListener('click', () => {
                    if (currentPlayQueue.length > 0 && currentQueueIndex > 0) {
                        playPreviousInQueue();
                    }
                });
            }
            
            if (miniNextTrackBtn) {
                miniNextTrackBtn.addEventListener('click', () => {
                    if (currentPlayQueue.length > 0 && currentQueueIndex < currentPlayQueue.length - 1) {
                        playNextInQueue();
                    }
                });
            }
            
            if (miniProgressBar) {
                miniProgressBar.addEventListener('click', (e) => {
                    const rect = miniProgressBar.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const ratio = Math.min(1, Math.max(0, x / rect.width));
                    musicAudio.currentTime = ratio * (musicAudio.duration || 0);
                    updateTimeDisplays();
                });
            }

            // Keyboard controls when modal open
            document.addEventListener('keydown', (e) => {
                if (!musicModal || musicModal.style.display === 'none') return;
                const tag = (document.activeElement && document.activeElement.tagName) || '';
                const isTyping = ['INPUT', 'TEXTAREA'].includes(tag);
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeMusicModal();
                } else if (e.key === ' ' && !isTyping) {
                    e.preventDefault();
                    if (musicAudio.paused) {
                        musicAudio.play();
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        musicAudio.pause();
                        musicPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        if (miniPlayPauseBtn) miniPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                }
            });

            // Wire search input/button
            if (musicSearchBtn && musicSearchInput) {
                musicSearchBtn.addEventListener('click', () => searchMusic(musicSearchInput.value));
                musicSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') searchMusic(musicSearchInput.value);
                });
            }
            
            function openBookReader(readLink, title) {
                console.log('[BOOKS] Opening reader for:', title, readLink);
                booksReaderTitle.textContent = title;
                booksReaderFrame.src = readLink;
                booksReaderModal.style.display = 'flex';
                document.body.classList.add('books-reader-open');
            }
            
            function closeBooksReader() {
                booksReaderModal.style.display = 'none';
                booksReaderFrame.src = '';
                document.body.classList.remove('books-reader-open');
            }
            
            // Event listeners for books
            if (booksSearchBtn) {
                booksSearchBtn.addEventListener('click', () => {
                    const query = booksSearchInput.value;
                    searchBooks(query);
                });
            }
            
            if (booksSearchInput) {
                booksSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const query = booksSearchInput.value;
                        searchBooks(query);
                    }
                });
            }
            
            if (booksReaderBack) {
                booksReaderBack.addEventListener('click', closeBooksReader);
            }
            
            // Close reader modal when clicking outside
            booksReaderModal?.addEventListener('click', (e) => {
                if (e.target === booksReaderModal) {
                    closeBooksReader();
                }
            });

            // Streaming Server Configuration
            const serverConfig = [
                {
                    name: 'Vidlink',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidlink.pro/movie/${id}`
                            : `https://vidlink.pro/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'Videasy',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.videasy.net/movie/${id}`
                            : `https://player.videasy.net/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'LunaStream',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://lunastream.fun/watch/movie/${id}`
                            : `https://lunastream.fun/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'VidRock',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidrock.net/movie/${id}`
                            : `https://vidrock.net/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'HexaWatch',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://hexa.watch/watch/movie/${id}`
                            : `https://hexa.watch/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'FMovies',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://www.fmovies.gd/watch/movie/${id}`
                            : `https://www.fmovies.gd/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'Xprime',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://xprime.tv/watch/${id}`
                            : `https://xprime.tv/watch/${id}/${season}/${episode}`
                },
                {
                    name: 'Vidnest',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidnest.fun/movie/${id}`
                            : `https://vidnest.fun/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'veloratv',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://veloratv.ru/watch/movie/${id}`
                            : `https://veloratv.ru/watch/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'Vidfast 1',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.pro/movie/${id}`
                            : `https://vidfast.pro/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'Vidfast 2',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.to/embed/movie/${id}`
                            : `https://vidfast.to/embed/tv/${id}/${season}/${episode}`
                },
                {
                    name: '111Movies',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://111movies.com/movie/${id}`
                            : `https://111movies.com/tv/${id}/${season}/${episode}`
                },
                
                {
                    name: 'MovieClub',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://moviesapi.club/movie/${id}`
                            : `https://moviesapi.club/tv/${id}-${season}-${episode}`
                },
                {
                    name: 'MapleTV',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://mapple.uk/watch/movie/${id}`
                            : `https://mapple.uk/watch/tv/${id}-${season}-${episode}`
                },
                {
                    name: '2Embed',
                    getUrl: (type, id, season, episode) =>
                        `https://multiembed.mov/?video_id=${id}&tmdb=1&media_type=${type}${type === 'tv' ? `&season=${season}&episode=${episode}` : ''}`
                },
                {
                    name: 'SmashyStream',
                    getUrl: (type, id, season, episode) =>
                        (type === 'movie'
                            ? `https://player.smashy.stream/movie/${id}`
                            : `https://player.smashy.stream/tv/${id}?s=${season}&e=${episode}`)
                },
                {
                    name: 'Autoembed',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.autoembed.cc/embed/movie/${id}`
                            : `https://player.autoembed.cc/embed/tv/${id}/${season}/${episode}`
                },
                {
                    name: 'GoDrivePlayer',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://godriveplayer.com/player.php?imdb=${id}`
                            : `https://godriveplayer.com/player.php?type=tv&tmdb=${id}&season=${season}&episode=${episode}`
                },
                {
                    name: 'VidWTF Premium',
                    getUrl: (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/4/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/4/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`
                }
            ];

            // Server Selection Modal Elements
            const serverSelectionModal = document.getElementById('server-selection-modal');
            const serverSelectionBack = document.getElementById('server-selection-back');
            const serverSelectionTitle = document.getElementById('server-selection-title');
            const serverMediaPoster = document.getElementById('server-media-poster');
            const serverMediaTitle = document.getElementById('server-media-title');
            const serverMediaSubtitle = document.getElementById('server-media-subtitle');
            const serverMediaYear = document.getElementById('server-media-year');
            const serverMediaRating = document.getElementById('server-media-rating');
            const serverDropdown = document.getElementById('server-dropdown');
            const serverWatchBtn = document.getElementById('server-watch-btn');
            const serverTorrentBtn = document.getElementById('server-torrent-btn');

            // Video Player Modal Elements
            const videoPlayerModal = document.getElementById('video-player-modal');
            const videoPlayerBack = document.getElementById('video-player-back');
            const videoPlayerTitle = document.getElementById('video-player-title');
            const videoPlayerFrame = document.getElementById('video-player-frame');
            const videoPlayerFullscreen = document.getElementById('video-player-fullscreen');

            // Media Data
            let currentMediaData = null;

            // Initialize server dropdown
            function initServerDropdown() {
                serverDropdown.innerHTML = '';
                serverConfig.forEach(server => {
                    const option = document.createElement('option');
                    option.value = server.name;
                    option.textContent = server.name;
                    if (server.name === selectedServer) {
                        option.selected = true;
                    }
                    serverDropdown.appendChild(option);
                });
            }

            // Show server selection modal
            function showServerSelection(mediaData) {
                currentMediaData = mediaData;
                console.log('[SERVERS] Showing server selection for:', mediaData);

                // Populate media info
                serverMediaTitle.textContent = mediaData.title;
                serverMediaSubtitle.textContent = mediaData.subtitle || '';
                serverMediaYear.textContent = mediaData.year || '';
                serverMediaRating.textContent = mediaData.rating ? ` ${mediaData.rating}` : '';
                serverMediaPoster.src = mediaData.poster || '';

                // Initialize dropdown
                initServerDropdown();

                // Show modal
                serverSelectionModal.style.display = 'flex';
                document.body.classList.add('server-modal-open');
            }

            // Hide server selection modal
            function hideServerSelection() {
                console.log('[SERVERS] Hiding server selection modal');
                
                // Close any active video player first
                const serverVideoSection = document.getElementById('server-video-section');
                if (serverVideoSection && serverVideoSection.style.display !== 'none') {
                    console.log('[SERVERS] Closing active video player before hiding modal');
                    closeVideoPlayer();
                }
                
                // Hide the modal
                serverSelectionModal.style.display = 'none';
                document.body.classList.remove('server-modal-open');
                currentMediaData = null;
                
                console.log('[SERVERS] Server selection modal hidden and video stopped');
            }
            
            // Debug: Test if showServerSelection is accessible
            console.log('[DEBUG] showServerSelection function exists:', typeof showServerSelection);

            // Show embedded video player
            function showVideoPlayer(url, title) {
                console.log('[SERVERS] Opening embedded video player for:', title, url);
                
                // Update Discord presence for streaming
                // Use TMDB title from currentContent, not the passed title parameter
                const tmdbTitle = currentContent?.title || currentContent?.name || title;
                
                // Determine provider based on selectedProvider setting
                let provider;
                if (selectedProvider === 'jackett') {
                    provider = 'Jackett';
                } else if (selectedProvider === 'nuvio') {
                    provider = 'Nuvio';
                } else if (selectedProvider === 'comet') {
                    provider = 'Comet';
                } else if (selectedProvider === '111477') {
                    provider = '111477';
                } else if (selectedProvider === 'moviebox') {
                    provider = 'MovieBox';
                } else if (selectedProvider === 'torrentio') {
                    provider = 'Torrentio';
                } else if (selectedProvider === 'torrentless') {
                    provider = 'PlayTorrio';
                } else {
                    provider = 'App Sources';  // Default fallback
                }
                
                // For TV shows, pass the season number
                const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
                updateDiscordForStreaming(tmdbTitle, provider, seasonNum);
                
                // Get embedded video elements
                const serverVideoSection = document.getElementById('server-video-section');
                const serverVideoTitle = document.getElementById('server-video-title');
                const serverVideoFrame = document.getElementById('server-video-frame');
                
                if (serverVideoSection && serverVideoTitle && serverVideoFrame) {
                    // Update title and URL
                    serverVideoTitle.textContent = title;
                    serverVideoFrame.removeAttribute('sandbox');
                    
                    // Store the expected URL pattern for monitoring
                    serverVideoFrame.expectedUrl = url;
                    serverVideoFrame.originalDomain = new URL(url).origin;
                    
                    // Set up URL monitoring
                    setupUrlMonitoring(serverVideoFrame, url);
                    
                    // Set the iframe source
                    serverVideoFrame.src = url;
                    
                    // Show the video section
                    serverVideoSection.style.display = 'block';
                    
                    // Auto-scroll to video player after a brief delay
                    setTimeout(() => {
                        serverVideoSection.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start' 
                        });
                    }, 500);
                    
                    console.log('[SERVERS] Embedded video player displayed successfully');
                } else {
                    console.error('[SERVERS] Embedded video elements not found, falling back to fullscreen');
                    // Fallback to original fullscreen method
                    videoPlayerTitle.textContent = title;
                    videoPlayerFrame.removeAttribute('sandbox');
                    videoPlayerFrame.src = url;
                    videoPlayerModal.style.display = 'flex';
                    document.body.classList.add('video-modal-open');
                    hideServerSelection();
                }
            }

            // Setup URL monitoring for iframe
            function setupUrlMonitoring(iframe, expectedUrl) {
                // Extract expected URL patterns for validation - STRICT MATCHING
                const urlPatterns = {
                    'vidrock.net': /^https:\/\/vidrock\.net\/(movie|tv)\/\d+(\?.*)?$/,
                    'hexa.watch': /^https:\/\/hexa\.watch\/watch\/(movie|tv)\/\d+(\?.*)?$/,
                    'www.fmovies.gd': /^https:\/\/www\.fmovies\.gd\/watch\/(movie|tv)\/\d+(\?.*)?$/,
                    'xprime.tv': /^https:\/\/xprime\.tv\/watch\/\d+(\?.*)?$/,
                    'vidnest.fun': /^https:\/\/vidnest\.fun\/(movie|tv)\/\d+(\?.*)?$/,
                    'vidlink.pro': /^https:\/\/vidlink\.pro\/(movie|tv)\/\d+(\?.*)?$/,
                    'player.videasy.net': /^https:\/\/player\.videasy\.net\/(movie|tv)\/\d+(\?.*)?$/,
                    'lunastream.fun': /^https:\/\/lunastream\.fun\/watch\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    'veloratv.ru': /^https:\/\/veloratv\.ru\/watch\/(movie|tv)\/\d+(\?.*)?$/,
                    'vidfast.pro': /^https:\/\/vidfast\.pro\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    'vidfast.to': /^https:\/\/vidfast\.to\/embed\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    '111movies.com': /^https:\/\/111movies\.com\/(movie\/\d+|tv\/\d+\/\d+\/\d+)(\?.*)?$/,
                    'moviesapi.club': /^https:\/\/moviesapi\.club\/(movie\/\d+|tv\/\d+-\d+-\d+)(\?.*)?$/,
                    'mapple.uk': /^https:\/\/mapple\.uk\/watch\/(movie\/\d+|tv\/\d+-\d+-\d+)(\?.*)?$/,
                    'multiembed.mov': /^https:\/\/multiembed\.mov\/\?video_id=\d+&tmdb=1&media_type=(movie|tv)(\&.*)?$/,
                    'player.smashy.stream': /^https:\/\/player\.smashy\.stream\/(movie\/\d+|tv\/\d+\?s=\d+&e=\d+)(\?.*)?$/,
                    'player.autoembed.cc': /^https:\/\/player\.autoembed\.cc\/embed\/(movie|tv)\/\d+(\?.*)?$/,
                    'godriveplayer.com': /^https:\/\/godriveplayer\.com\/player\.php\?(imdb=\d+|type=tv&tmdb=\d+&season=\d+&episode=\d+)(\&.*)?$/,
                    'databasegdriveplayer.xyz': /^https:\/\/databasegdriveplayer\.xyz\/+player\.php\?tmdb=\d+(\&.*)?$/,
                    'database.gdriveplayer.us': /^https:\/\/database\.gdriveplayer\.us\/player\.php\?type=series&tmdb=\d+&season=\d+&episode=\d+(\&.*)?$/,
                    'cinemaos.tech': /^https:\/\/cinemaos\.tech\/player\/\d+(?:\/\d+\/\d+)?(\?.*)?$/,
                    'primesrc.me': /^https:\/\/primesrc\.me\/embed\/(movie|tv)\?tmdb=\d+(?:&season=\d+&episode=\d+)?(\&.*)?$/,
                    'vidsrc.wtf': /^https:\/\/vidsrc\.wtf\/api\/(1|2|3|4)\/(movie|tv)\/\?id=\d+(\&.*)?$/
                };
                
                // Get the domain from the expected URL
                const expectedDomain = new URL(expectedUrl).hostname;
                const pattern = urlPatterns[expectedDomain];
                
                if (!pattern) {
                    console.warn('[SERVERS] No URL pattern defined for domain:', expectedDomain);
                    return;
                }
                
                console.log('[SERVERS] Setting up URL monitoring for domain:', expectedDomain);
                console.log('[SERVERS] Expected URL pattern:', pattern);
                console.log('[SERVERS] Initial URL:', expectedUrl);
                
                // Monitor iframe load events
                iframe.addEventListener('load', function() {
                    try {
                        // Try to access iframe location (may be blocked by CORS)
                        const currentUrl = iframe.contentWindow.location.href;
                        console.log('[SERVERS] Iframe loaded URL:', currentUrl);
                        
                        // Check if current URL matches expected pattern
                        if (!pattern.test(currentUrl)) {
                            console.error('[SERVERS]  URL VIOLATION DETECTED!');
                            console.error('[SERVERS] Current URL:', currentUrl);
                            console.error('[SERVERS] Expected pattern:', pattern.toString());
                            console.error('[SERVERS] Closing player immediately!');
                            
                            closeVideoPlayer();
                            return;
                        } else {
                            console.log('[SERVERS]  URL pattern valid:', currentUrl);
                        }
                    } catch (e) {
                        // CORS restriction - iframe is on different domain
                        console.log('[SERVERS] Iframe access blocked (CORS) - this is normal for streaming sites');
                    }
                });
                
                // More aggressive monitoring - check on any iframe activity
                iframe.addEventListener('beforeunload', function() {
                    console.log('[SERVERS] Iframe beforeunload detected - page changing');
                });
                
                // Periodic URL checking (backup method) - more frequent
                const monitorInterval = setInterval(() => {
                    try {
                        if (!iframe || !iframe.contentWindow || !iframe.parentNode) {
                            console.log('[SERVERS] Iframe no longer exists, clearing monitor');
                            clearInterval(monitorInterval);
                            return;
                        }
                        
                        const currentUrl = iframe.contentWindow.location.href;
                        
                        // If we can access the URL and it doesn't match pattern, close player
                        if (currentUrl && !pattern.test(currentUrl)) {
                            console.error('[SERVERS]  PERIODIC CHECK: URL violation detected!');
                            console.error('[SERVERS] Current URL:', currentUrl);
                            console.error('[SERVERS] Expected pattern:', pattern.toString());
                            
                            clearInterval(monitorInterval);
                            
                            // Close player silently when navigation is detected
                            console.log('[SERVERS] Player closed: Detected navigation away from streaming content');
                            closeVideoPlayer();
                            return;
                        }
                        
                        console.log('[SERVERS]  Periodic check: URL monitoring active');
                    } catch (e) {
                        // Expected - CORS protection means iframe is still on streaming site
                        console.log('[SERVERS]  Periodic check: CORS blocked (streaming site active)');
                    }
                }, 1000); // Check every 1 second (more frequent)
                
                // Store interval for cleanup
                iframe.monitorInterval = monitorInterval;
            }

            // Close video player function
            function closeVideoPlayer() {
                console.log('[SERVERS] Closing video player due to URL violation');
                
                // Clear Discord presence when video closes
                if (discordStreamingActive) {
                    clearDiscordPresence();
                }
                
                const serverVideoSection = document.getElementById('server-video-section');
                const serverVideoFrame = document.getElementById('server-video-frame');
                
                if (serverVideoSection) {
                    // Hide the video player box
                    serverVideoSection.style.display = 'none';
                    console.log('[SERVERS] Video player box hidden');
                }
                
                if (serverVideoFrame) {
                    // Clear monitoring interval
                    if (serverVideoFrame.monitorInterval) {
                        clearInterval(serverVideoFrame.monitorInterval);
                        console.log('[SERVERS] URL monitoring interval cleared');
                    }
                    
                    // Remove the server content from iframe
                    serverVideoFrame.src = 'about:blank';
                    serverVideoFrame.removeAttribute('expectedUrl');
                    serverVideoFrame.removeAttribute('originalDomain');
                    
                    console.log('[SERVERS] Iframe cleared and server removed');
                }
                
                // Also clear the video title
                const serverVideoTitle = document.getElementById('server-video-title');
                if (serverVideoTitle) {
                    serverVideoTitle.textContent = 'Player Closed';
                }
                
                console.log('[SERVERS] Video player completely shut down');
            }

            // Hide video player
            function hideVideoPlayer() {
                videoPlayerModal.style.display = 'none';
                videoPlayerFrame.src = '';
                document.body.classList.remove('video-modal-open');
            }

            // Get streaming URL for current media
            function getStreamingUrl(mediaData, serverName) {
                console.log('[SERVERS] Generating URL for server:', serverName, 'media:', mediaData);
                
                // Define server configurations inline (serverConfig not accessible from this scope)
                const servers = {
                    'CinemaOS': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://cinemaos.tech/player/${id}`
                            : `https://cinemaos.tech/player/${id}/${season}/${episode}`,
                    'Videasy': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.videasy.net/movie/${id}`
                            : `https://player.videasy.net/tv/${id}/${season}/${episode}`,
                    'Vidlink': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidlink.pro/movie/${id}`
                            : `https://vidlink.pro/tv/${id}/${season}/${episode}`,                            
                    'LunaStream': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://lunastream.fun/watch/movie/${id}`
                            : `https://lunastream.fun/watch/tv/${id}/${season}/${episode}`,
                    'VidRock': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidrock.net/movie/${id}`
                            : `https://vidrock.net/tv/${id}/${season}/${episode}`,
                    'HexaWatch': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://hexa.watch/watch/movie/${id}`
                            : `https://hexa.watch/watch/tv/${id}/${season}/${episode}`,
                    'FMovies': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://www.fmovies.gd/watch/movie/${id}`
                            : `https://www.fmovies.gd/watch/tv/${id}/${season}/${episode}`,
                    'Xprime': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://xprime.tv/watch/${id}`
                            : `https://xprime.tv/watch/${id}/${season}/${episode}`,
                    'Vidnest': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidnest.fun/movie/${id}`
                            : `https://vidnest.fun/tv/${id}/${season}/${episode}`,
                    'veloratv': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://veloratv.ru/watch/movie/${id}`
                            : `https://veloratv.ru/watch/tv/${id}/${season}/${episode}`,
                    'Vidfast 1': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.pro/movie/${id}`
                            : `https://vidfast.pro/tv/${id}/${season}/${episode}`,
                    'Vidfast 2': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidfast.to/embed/movie/${id}`
                            : `https://vidfast.to/embed/tv/${id}/${season}/${episode}`,
                    '111Movies': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://111movies.com/movie/${id}`
                            : `https://111movies.com/tv/${id}/${season}/${episode}`,
                    'VidSrc 1': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/1/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/1/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'VidSrc 2': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/2/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/2/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'VidSrc 3': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/3/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/3/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'VidSrc 4': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/4/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/4/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    'PrimeSrc': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://primesrc.me/embed/movie?tmdb=${id}`
                            : `https://primesrc.me/embed/tv?tmdb=${id}&season=${season}&episode=${episode}`,
                    'MovieClub': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://moviesapi.club/movie/${id}`
                            : `https://moviesapi.club/tv/${id}-${season}-${episode}`,
                    'MapleTV': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://mapple.uk/watch/movie/${id}`
                            : `https://mapple.uk/watch/tv/${id}-${season}-${episode}`,
                    '2Embed': (type, id, season, episode) =>
                        `https://multiembed.mov/?video_id=${id}&tmdb=1&media_type=${type}${type === 'tv' ? `&season=${season}&episode=${episode}` : ''}`,
                    'SmashyStream': (type, id, season, episode) =>
                        (type === 'movie'
                            ? `https://player.smashy.stream/movie/${id}`
                            : `https://player.smashy.stream/tv/${id}?s=${season}&e=${episode}`),
                    'Autoembed': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://player.autoembed.cc/embed/movie/${id}`
                            : `https://player.autoembed.cc/embed/tv/${id}/${season}/${episode}`,
                    'GoDrivePlayer': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://godriveplayer.com/player.php?imdb=${id}`
                            : `https://godriveplayer.com/player.php?type=tv&tmdb=${id}&season=${season}&episode=${episode}`,
                    'VidWTF Premium': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.wtf/api/4/movie/?id=${id}&color=e01621`
                            : `https://vidsrc.wtf/api/4/tv/?id=${id}&s=${season}&e=${episode}&color=e01621`,
                    // New additional servers
                    'CinemaOS Embed': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://cinemaos.tech/embed/movie/${id}`
                            : `https://cinemaos.tech/embed/tv/${id}/${season}/${episode}`,
                    
                    'GDrivePlayer API': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://databasegdriveplayer.xyz/player.php?tmdb=${id}`
                            : `https://database.gdriveplayer.us/player.php?type=series&tmdb=${id}&season=${season}&episode=${episode}`,
                    'Nontongo': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://nontongo.win/embed/movie/${id}`
                            : `https://nontongo.win/embed/tv/${id}/${season}/${episode}`,
                    
                    'SpencerDevs': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://spencerdevs.xyz/movie/${id}`
                            : `https://spencerdevs.xyz/tv/${id}/${season}/${episode}`,
                    'VidAPI': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidapi.xyz/embed/movie/${id}`
                            : `https://vidapi.xyz/embed/tv/${id}/${season}/${episode}`,
                    'Vidify': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidify.top/embed/movie/${id}`
                            : `https://vidify.top/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc CX': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.cx/embed/movie/${id}`
                            : `https://vidsrc.cx/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc ME': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.me/embed/movie/${id}`
                            : `https://vidsrc.me/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc TO': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.to/embed/movie/${id}`
                            : `https://vidsrc.to/embed/tv/${id}/${season}/${episode}`,
                    'VidSrc VIP': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vidsrc.vip/embed/movie/${id}`
                            : `https://vidsrc.vip/embed/tv/${id}/${season}/${episode}`,
                    'VixSrc': (type, id, season, episode) =>
                        type === 'movie'
                            ? `https://vixsrc.to/movie/${id}/`
                            : `https://vixsrc.to/tv/${id}/${season}/${episode}/`
                };

                const serverFunction = servers[serverName];
                if (!serverFunction) {
                    console.error('[SERVERS] Server not found:', serverName);
                    return null;
                }

                const url = serverFunction(
                    mediaData.type,
                    mediaData.id,
                    mediaData.season,
                    mediaData.episode
                );
                
                console.log('[SERVERS] Generated URL:', url);
                return url;
            }

            // Event listeners for server selection
            if (serverSelectionBack) {
                serverSelectionBack.addEventListener('click', hideServerSelection);
            }

            if (serverDropdown) {
                serverDropdown.addEventListener('change', (e) => {
                    selectedServer = e.target.value;
                    localStorage.setItem('selectedServer', selectedServer);
                    console.log('[SERVERS] Selected server:', selectedServer);
                });
            }

            if (serverWatchBtn) {
                serverWatchBtn.addEventListener('click', () => {
                    console.log('[SERVERS] Start Watching button clicked!');
                    
                    // Try to get media data from multiple sources
                    const mediaData = currentMediaData || window.currentMediaData;
                    console.log('[SERVERS] currentMediaData:', currentMediaData);
                    console.log('[SERVERS] window.currentMediaData:', window.currentMediaData);
                    console.log('[SERVERS] Using mediaData:', mediaData);
                    
                    if (!mediaData) {
                        console.error('[SERVERS] No media data available');
                        alert('No media selected. Please select a movie or show first.');
                        return;
                    }
                    
                    // Get current selected server from dropdown
                    const currentSelectedServer = serverDropdown ? serverDropdown.value : (localStorage.getItem('selectedServer') || 'Videasy');
                    console.log('[SERVERS] Selected server:', currentSelectedServer);
                    
                    const streamUrl = getStreamingUrl(mediaData, currentSelectedServer);
                    console.log('[SERVERS] Generated stream URL:', streamUrl);
                    
                    if (streamUrl) {
                        const title = `${mediaData.title} - ${currentSelectedServer}`;
                        console.log('[SERVERS] Calling showVideoPlayer with:', title);
                        showVideoPlayer(streamUrl, title);
                    } else {
                        showNotification('Failed to generate streaming URL', 'error');
                    }
                });
            }

            if (serverTorrentBtn) {
                serverTorrentBtn.addEventListener('click', () => {
                    console.log('[SERVERS] Use Torrent Instead button clicked!');
                    
                    // Turn off streaming servers mode
                    localStorage.setItem('useStreamingServers', 'false');
                    console.log('[SERVERS] Disabled streaming servers mode');
                    
                    // Update toggle in settings for ALL instances
                    const useStreamingServersToggles = document.querySelectorAll('#useStreamingServersToggle');
                    useStreamingServersToggles.forEach(toggle => {
                        toggle.checked = false;
                    });
                    
                    // Update button text
                    updateWatchButtonText();
                    
                    // Hide server selection modal
                    hideServerSelection();
                    
                    // Fall back to torrent mode
                    if (currentMediaData && currentMediaData.fallbackToTorrent) {
                        console.log('[SERVERS] Calling fallback function');
                        currentMediaData.fallbackToTorrent();
                    } else {
                        console.log('[SERVERS] No fallback function, manually showing torrents');
                        // Manually trigger torrent display
                        const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
                        console.log('[SERVERS] Streaming mode after toggle:', streamingMode);
                        if (!streamingMode && typeof showTorrents === 'function') {
                            showTorrents(null, currentMediaData?.season, currentMediaData?.episode);
                        }
                    }
                });
            }

            // Embedded video player event handlers
            const serverVideoClose = document.getElementById('server-video-close');
            const serverVideoFrame = document.getElementById('server-video-frame');

            if (serverVideoClose) {
                serverVideoClose.addEventListener('click', () => {
                    closeVideoPlayer();
                });
            }

            // Server switching while watching
            if (serverDropdown) {
                serverDropdown.addEventListener('change', (e) => {
                    const newServer = e.target.value;
                    const serverVideoSection = document.getElementById('server-video-section');
                    
                    // Only switch if video is currently playing
                    if (serverVideoSection && serverVideoSection.style.display !== 'none' && currentMediaData) {
                        console.log('[SERVERS] Switching to server:', newServer);
                        
                        // Update selected server
                        localStorage.setItem('selectedServer', newServer);
                        
                        // Generate new streaming URL
                        const newStreamUrl = getStreamingUrl(currentMediaData, newServer);
                        
                        if (newStreamUrl && serverVideoFrame) {
                            // Update iframe source
                            serverVideoFrame.src = newStreamUrl;
                            
                            // Update title to show new server
                            const serverVideoTitle = document.getElementById('server-video-title');
                            if (serverVideoTitle) {
                                serverVideoTitle.textContent = `${currentMediaData.title} - ${newServer}`;
                            }
                            
                            console.log('[SERVERS] Successfully switched to:', newServer);
                        } else {
                            console.error('[SERVERS] Failed to generate URL for server:', newServer);
                            // Revert dropdown selection
                            const oldServer = localStorage.getItem('selectedServer') || 'Videasy';
                            e.target.value = oldServer;
                        }
                    }
                });
            }

            // Video player event listeners
            if (videoPlayerBack) {
                videoPlayerBack.addEventListener('click', () => {
                    hideVideoPlayer();
                    if (currentMediaData) {
                        showServerSelection(currentMediaData);
                    }
                });
            }

            if (videoPlayerFullscreen) {
                videoPlayerFullscreen.addEventListener('click', () => {
                    const frame = videoPlayerFrame;
                    if (frame.requestFullscreen) {
                        frame.requestFullscreen();
                    } else if (frame.webkitRequestFullscreen) {
                        frame.webkitRequestFullscreen();
                    } else if (frame.msRequestFullscreen) {
                        frame.msRequestFullscreen();
                    }
                });
            }

            // Disable closing server selection when clicking on the backdrop
            // Absorb clicks on the empty area so they don't close or trigger anything behind
            serverSelectionModal?.addEventListener('click', (e) => {
                if (e.target === serverSelectionModal) {
                    e.stopPropagation();
                    // Intentionally do nothing: require explicit Back button to close
                }
            });
            // Also stop click propagation inside the content
            const serverSelectionContent = document.querySelector('#server-selection-modal .server-selection-content');
            serverSelectionContent?.addEventListener('click', (e) => e.stopPropagation());

            videoPlayerModal?.addEventListener('click', (e) => {
                if (e.target === videoPlayerModal) {
                    hideVideoPlayer();
                }
            });

            // Update watch button text based on streaming mode
            function updateWatchButtonText() {
                const watchBtn = document.getElementById('watchNowBtn');
                const note = document.getElementById('watchNowNote');
                const toggleBtn = document.getElementById('useStreamsBtn');
                const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
                
                if (watchBtn) {
                    if (streamingMode) {
                        // For TV shows in streaming mode, hide the button and show hint
                        if (currentMediaType === 'tv') {
                            watchBtn.style.display = 'none';
                            if (note) note.style.display = '';
                        } else {
                            // For MOVIES in streaming mode, always show Watch Now
                            watchBtn.style.display = '';
                            watchBtn.innerHTML = '<i class="fas fa-play"></i> Watch Now';
                            if (note) note.style.display = 'none';
                        }
                    } else {
                        // Torrent mode - show Find Media for both movies and TV
                        watchBtn.style.display = '';
                        watchBtn.innerHTML = '<i class="fas fa-play"></i> Find Media';
                        if (note) note.style.display = 'none';
                    }
                }

                // Update the toggle button label between Streams/Torrents
                if (toggleBtn) {
                    if (streamingMode) {
                        toggleBtn.innerHTML = '<i class="fas fa-magnet"></i> Use Torrents instead';
                    } else {
                        toggleBtn.innerHTML = '<i class="fas fa-broadcast-tower"></i> Use Streams instead';
                    }
                }
            }

            // Initialize streaming servers setting for ALL instances
            const useStreamingServersToggles = document.querySelectorAll('#useStreamingServersToggle');
            if (useStreamingServersToggles.length > 0) {
                const currentSetting = localStorage.getItem('useStreamingServers') === 'true';
                
                useStreamingServersToggles.forEach(toggle => {
                    toggle.checked = currentSetting;
                    toggle.addEventListener('change', (e) => {
                        const newValue = e.target.checked;
                        localStorage.setItem('useStreamingServers', newValue);
                        console.log('[SERVERS] Streaming servers mode:', newValue ? 'enabled' : 'disabled');
                        
                        // Update ALL other toggles to match
                        useStreamingServersToggles.forEach(t => t.checked = newValue);
                        
                        updateWatchButtonText(); // Update button text when mode changes
                    });
                });
            }

            // Set initial button text
            updateWatchButtonText();

            // Downloader wiring (top-level)
            const downloaderQuery = document.getElementById('downloaderQuery');
            const downloaderBtn = document.getElementById('downloaderSearchBtn');
            const downloaderResults = document.getElementById('downloaderResults');
            const downloaderEmpty = document.getElementById('downloaderEmpty');
            const filterMoviesBtn = document.getElementById('downloaderFilterMovies');
            const filterTvBtn = document.getElementById('downloaderFilterTV');
            let downloaderType = 'movies'; // 'movies' | 'tv'
            async function runDownloaderSearch(q) {
                if (!downloaderResults || !downloaderEmpty) return;
                const query = (q || '').trim();
                downloaderResults.innerHTML = '';
                downloaderResults.classList.remove('single');
                if (!query) { downloaderEmpty.style.display = ''; downloaderEmpty.textContent = 'Type a search above to see results.'; return; }
                downloaderEmpty.style.display = 'none';
                try {
                    // Try local 111477 service first
                    let results = [];
                    try {
                        const res = await fetch(`http://localhost:6987/111477/api/tmdb/search/${encodeURIComponent(query)}`);
                        if (res.ok) {
                            const data = await res.json();
                            results = Array.isArray(data?.results) ? data.results : [];
                        }
                    } catch (_) {}
                    if (!results.length) {
                        // Fallback: direct TMDB (movies + TV)
                        const [mRes, tvRes] = await Promise.all([
                            fetch(`https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`),
                            fetch(`https://api.themoviedb.org/3/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`)
                        ]);
                        const [mData, tvData] = [await mRes.json(), await tvRes.json()];
                        const mResults = Array.isArray(mData?.results) ? mData.results.map(r => ({
                            title: r.title,
                            posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                            releaseDate: r.release_date || '',
                            year: r.release_date ? String(r.release_date).slice(0,4) : '',
                            tmdbId: r.id,
                            mediaType: 'movie'
                        })) : [];
                        const tvResults = Array.isArray(tvData?.results) ? tvData.results.map(r => ({
                            title: r.name,
                            posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                            releaseDate: r.first_air_date || '',
                            year: r.first_air_date ? String(r.first_air_date).slice(0,4) : '',
                            tmdbId: r.id,
                            mediaType: 'tv'
                        })) : [];
                        results = [...mResults, ...tvResults];
                    }
                    // Filter by selected type
                    const filtered = results.filter((item) => {
                        const mt = (item.mediaType || item.media_type || (item.firstAirDate || item.name ? 'tv' : 'movie')).toLowerCase();
                        return downloaderType === 'movies' ? mt === 'movie' : mt === 'tv';
                    });
                    if (!filtered.length) {
                        // Fallback fetch type-specific from TMDB if none after filtering
                        if (downloaderType === 'tv') {
                            const tvRes = await fetch(`https://api.themoviedb.org/3/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`);
                            const tvData = await tvRes.json();
                            results = Array.isArray(tvData?.results) ? tvData.results.map(r => ({
                                title: r.name,
                                posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                                releaseDate: r.first_air_date || '',
                                year: r.first_air_date ? String(r.first_air_date).slice(0,4) : '',
                                tmdbId: r.id,
                                mediaType: 'tv'
                            })) : [];
                        } else {
                            const mRes2 = await fetch(`https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1&include_adult=false`);
                            const mData2 = await mRes2.json();
                            results = Array.isArray(mData2?.results) ? mData2.results.map(r => ({
                                title: r.title,
                                posterPath: r.poster_path ? `https://image.tmdb.org/t/p/w500${r.poster_path}` : '',
                                releaseDate: r.release_date || '',
                                year: r.release_date ? String(r.release_date).slice(0,4) : '',
                                tmdbId: r.id,
                                mediaType: 'movie'
                            })) : [];
                        }
                    } else {
                        results = filtered;
                    }
                    results = results.slice(0, 10);
                    if (!results.length) {
                        downloaderEmpty.style.display = '';
                        downloaderEmpty.textContent = downloaderType === 'movies' ? 'No movies found.' : 'No TV shows found.';
                        return;
                    }
                    const frag = document.createDocumentFragment();
                    results.forEach((item) => {
                        const card = document.createElement('div');
                        card.className = 'downloader-item';
                        card.tabIndex = 0;
                        const poster = item.posterPath || '';
                        const title = item.title || item.name || item.constructedName || 'Untitled';
                        const year = item.year || (item.releaseDate ? String(item.releaseDate).slice(0,4) : '');
                        const tmdbId = item.tmdbId || item.id || item.tmdb_id || '';
                        const mediaType = item.mediaType || item.media_type || (item.firstAirDate || item.name ? 'tv' : 'movie');
                        if (tmdbId) card.dataset.tmdbId = String(tmdbId);
                        if (mediaType) card.dataset.mediaType = String(mediaType);
                        card.innerHTML = `
                            <img loading="lazy" class="downloader-thumb" src="${poster}" alt="${title.replace(/"/g,'&quot;')}" onerror="this.style.opacity=0;" />
                            <div class="downloader-meta">
                                <div class="downloader-title">${title}</div>
                                <div class="downloader-year">${year || ''}</div>
                            </div>`;
                        card.addEventListener('click', (e) => {
                            e.preventDefault(); e.stopPropagation();
                            // Remove other cards and center the selected one
                            const container = downloaderResults;
                            document.querySelectorAll('.downloader-item').forEach(el => { if (el !== card) el.remove(); });
                            container.classList.add('single');
                            document.querySelectorAll('.downloader-item.selected').forEach(el => el.classList.remove('selected'));
                            card.classList.add('selected');
                            const id = card.dataset.tmdbId;
                            const type = (card.dataset.mediaType || 'movie').toLowerCase();
                            // Remove any previous blocks (files, tv controls)
                            container.querySelectorAll('.downloader-files-card, .downloader-tv-controls').forEach(el => el.remove());
                            if (id) {
                                if (type === 'tv') {
                                    fetchAndRenderTvSelectors(id, container);
                                } else {
                                    fetchDownloaderFilesByTmdb(id, container);
                                }
                            }
                        });
                        frag.appendChild(card);
                    });
                    downloaderResults.appendChild(frag);
                } catch (err) {
                    console.error('Downloader search failed:', err);
                    downloaderEmpty.style.display = '';
                    downloaderEmpty.textContent = 'Search failed.';
                }
            }
            function renderFilesCard(files, container, loadKey) {
                // If a key is provided but doesn't match the latest, skip (prevents duplicates)
                if (loadKey && container.dataset.filesLoadKey && container.dataset.filesLoadKey !== loadKey) return;
                const filesWrap = document.createElement('div');
                filesWrap.className = 'trakt-card downloader-files-card';
                filesWrap.style.maxWidth = '900px';
                filesWrap.style.width = '100%';
                const inner = document.createElement('div');
                inner.className = 'trakt-card-body';
                inner.innerHTML = `<h3 style="margin-bottom:0.75rem;">Available files (${files.length})</h3>`;
                if (!files.length) {
                    const empty = document.createElement('div');
                    empty.className = 'downloader-empty';
                    empty.textContent = 'No files found for this title.';
                    inner.appendChild(empty);
                } else {
                    const list = document.createElement('div');
                    list.style.display = 'flex';
                    list.style.flexDirection = 'column';
                    list.style.gap = '0.5rem';
                    // Show up to 100 files (increased from 50 due to multiple variants)
                    files.slice(0, 100).forEach(f => {
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.justifyContent = 'space-between';
                        row.style.alignItems = 'center';
                        row.style.background = 'rgba(255,255,255,0.06)';
                        row.style.border = '1px solid rgba(255,255,255,0.08)';
                        row.style.borderRadius = '10px';
                        row.style.padding = '0.6rem 0.8rem';
                        const name = document.createElement('div');
                        name.style.flex = '1';
                        name.style.marginRight = '0.75rem';
                        name.style.overflow = 'hidden';
                        name.style.whiteSpace = 'nowrap';
                        name.style.textOverflow = 'ellipsis';
                        name.textContent = f.name || 'File';
                        const size = document.createElement('div');
                        size.style.color = '#9ca3af';
                        size.style.marginRight = '0.75rem';
                        size.style.minWidth = '80px';
                        size.style.textAlign = 'right';
                        size.textContent = f.sizeFormatted || '';
                        const btn = document.createElement('button');
                        btn.className = 'api-btn api-btn-primary';
                        btn.innerHTML = '<i class="fas fa-download"></i> Download';
                        btn.addEventListener('click', async (ev) => {
                            ev.preventDefault(); ev.stopPropagation();
                            const href = f.url || '';
                            if (!href) return;
                            try {
                                if (window.electronAPI?.openExternal) {
                                    await window.electronAPI.openExternal(href);
                                } else {
                                    window.open(href, '_blank', 'noopener');
                                }
                            } catch (_) { window.open(href, '_blank'); }
                        });
                        row.appendChild(name);
                        row.appendChild(size);
                        row.appendChild(btn);
                        list.appendChild(row);
                    });
                    inner.appendChild(list);
                    
                    // If there are more files than displayed, show a note
                    if (files.length > 100) {
                        const moreNote = document.createElement('div');
                        moreNote.style.marginTop = '0.5rem';
                        moreNote.style.color = '#9ca3af';
                        moreNote.style.fontSize = '0.9rem';
                        moreNote.style.textAlign = 'center';
                        moreNote.textContent = `Showing first 100 of ${files.length} files`;
                        inner.appendChild(moreNote);
                    }
                }
                filesWrap.appendChild(inner);
                // Remove any previous files card before appending (last-writer-wins)
                container.querySelectorAll('.downloader-files-card').forEach(el => el.remove());
                container.appendChild(filesWrap);
            }

            function startFilesLoad(container) {
                const key = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
                container.dataset.filesLoadKey = key;
                return key;
            }

            async function fetchDownloaderFilesByTmdb(tmdbId, container) {
                try {
                    const loadKey = startFilesLoad(container);
                    const res = await fetch(`http://localhost:6987/111477/api/tmdb/movie/${encodeURIComponent(tmdbId)}`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const data = await res.json();
                    
                    // Handle new multi-result format from 111477 API
                    let allFiles = [];
                    if (Array.isArray(data?.results)) {
                        // New format: extract files from all successful results
                        data.results.forEach(result => {
                            if (result.success && Array.isArray(result.files)) {
                                allFiles = allFiles.concat(result.files);
                            }
                        });
                    } else if (Array.isArray(data?.files)) {
                        // Old format: direct files array
                        allFiles = data.files;
                    }
                    
                    renderFilesCard(allFiles, container, loadKey);
                } catch (e) {
                    console.error('Failed to load files by TMDB id', e);
                    showNotification('Failed to load files for this title');
                }
            }

            async function fetchAndRenderTvSelectors(tmdbId, container) {
                // Controls card
                const ctrl = document.createElement('div');
                ctrl.className = 'trakt-card downloader-tv-controls';
                ctrl.style.maxWidth = '900px';
                ctrl.style.width = '100%';
                const body = document.createElement('div');
                body.className = 'trakt-card-body';
                body.innerHTML = '<h3 style="margin-bottom:0.75rem;">Pick season and episode</h3>';

                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '0.75rem';
                row.style.alignItems = 'center';
                row.style.flexWrap = 'wrap';

                const seasonLabel = document.createElement('label');
                seasonLabel.textContent = 'Season';
                seasonLabel.style.marginRight = '0.25rem';
                const seasonSel = document.createElement('select');
                seasonSel.style.padding = '0.5rem 0.6rem';
                seasonSel.style.borderRadius = '8px';
                seasonSel.style.border = '1px solid rgba(255,255,255,0.15)';
                seasonSel.style.background = 'rgba(0,0,0,0.25)';
                seasonSel.style.color = '#fff';

                const episodeLabel = document.createElement('label');
                episodeLabel.textContent = 'Episode';
                episodeLabel.style.marginRight = '0.25rem';
                const episodeSel = document.createElement('select');
                episodeSel.style.padding = '0.5rem 0.6rem';
                episodeSel.style.borderRadius = '8px';
                episodeSel.style.border = '1px solid rgba(255,255,255,0.15)';
                episodeSel.style.background = 'rgba(0,0,0,0.25)';
                episodeSel.style.color = '#fff';
                episodeSel.disabled = true;

                row.appendChild(seasonLabel);
                row.appendChild(seasonSel);
                row.appendChild(episodeLabel);
                row.appendChild(episodeSel);
                body.appendChild(row);
                ctrl.appendChild(body);
                container.appendChild(ctrl);

                // Fetch TMDB TV info for seasons
                try {
                    const infoRes = await fetch(`https://api.themoviedb.org/3/tv/${encodeURIComponent(tmdbId)}?api_key=${TMDB_API_KEY}`);
                    const info = await infoRes.json();
                    const numberOfSeasons = info?.number_of_seasons || (Array.isArray(info?.seasons) ? info.seasons.length : 0);
                    const seasons = [];
                    for (let s = 1; s <= numberOfSeasons; s++) seasons.push(s);
                    if (!seasons.length) {
                        showNotification('No seasons found for this show');
                        return;
                    }
                    seasonSel.innerHTML = seasons.map(s => `<option value="${s}">S${String(s).padStart(2,'0')}</option>`).join('');

                    seasonSel.addEventListener('change', async () => {
                        const sVal = Number(seasonSel.value);
                        episodeSel.disabled = true;
                        episodeSel.innerHTML = '';
                        // Remove prior files card if any
                        container.querySelectorAll('.downloader-files-card').forEach(el => el.remove());
                        try {
                            const seasonRes = await fetch(`https://api.themoviedb.org/3/tv/${encodeURIComponent(tmdbId)}/season/${encodeURIComponent(sVal)}?api_key=${TMDB_API_KEY}`);
                            const seasonData = await seasonRes.json();
                            const eps = Array.isArray(seasonData?.episodes) ? seasonData.episodes.map(e => e.episode_number) : [];
                            if (!eps.length && Number.isFinite(seasonData?.episode_count)) {
                                for (let e = 1; e <= seasonData.episode_count; e++) eps.push(e);
                            }
                            episodeSel.innerHTML = eps.map(e => `<option value="${e}">E${String(e).padStart(2,'0')}</option>`).join('');
                            episodeSel.disabled = eps.length === 0;
                        } catch (err) {
                            console.error('Failed to fetch episodes list', err);
                            showNotification('Failed to load episodes');
                        }
                    });

                    episodeSel.addEventListener('change', async () => {
                        const sVal = Number(seasonSel.value);
                        const eVal = Number(episodeSel.value);
                        // Remove prior files card if any
                        container.querySelectorAll('.downloader-files-card').forEach(el => el.remove());
                        try {
                            const loadKey = startFilesLoad(container);
                            const res = await fetch(`http://localhost:6987/111477/api/tmdb/tv/${encodeURIComponent(tmdbId)}/season/${encodeURIComponent(sVal)}/episode/${encodeURIComponent(eVal)}`);
                            if (!res.ok) throw new Error(`HTTP ${res.status}`);
                            const data = await res.json();
                            
                            // Handle new multi-result format from 111477 API
                            let allFiles = [];
                            if (Array.isArray(data?.results)) {
                                // New format: extract files from all successful results
                                data.results.forEach(result => {
                                    if (result.success && Array.isArray(result.files)) {
                                        allFiles = allFiles.concat(result.files);
                                    }
                                });
                            } else if (Array.isArray(data?.files)) {
                                // Old format: direct files array
                                allFiles = data.files;
                            }
                            
                            renderFilesCard(allFiles, container, loadKey);
                        } catch (err) {
                            console.error('Failed to load TV episode files', err);
                            showNotification('Failed to load files for this episode');
                        }
                    });

                    // Trigger initial season load to populate episodes
                    seasonSel.dispatchEvent(new Event('change'));
                } catch (err) {
                    console.error('Failed to fetch TV info', err);
                    showNotification('Failed to load TV seasons');
                }
            }

            if (filterMoviesBtn && filterTvBtn) {
                filterMoviesBtn.addEventListener('click', () => {
                    if (downloaderType !== 'movies') {
                        downloaderType = 'movies';
                        filterMoviesBtn.classList.add('active');
                        filterTvBtn.classList.remove('active');
                        if (downloaderQuery.value.trim()) runDownloaderSearch(downloaderQuery.value);
                    }
                });
                filterTvBtn.addEventListener('click', () => {
                    if (downloaderType !== 'tv') {
                        downloaderType = 'tv';
                        filterTvBtn.classList.add('active');
                        filterMoviesBtn.classList.remove('active');
                        if (downloaderQuery.value.trim()) runDownloaderSearch(downloaderQuery.value);
                    }
                });
            }

            // [START] AcerMovies Integration
            const provider111477 = document.getElementById('provider111477');
            const providerAcermovies = document.getElementById('providerAcermovies');
            const downloaderTypeToggle = document.querySelector('.downloader-type-toggle');
            
            function setActiveDownloaderProvider(provider) {
                provider111477.classList.remove('active');
                providerAcermovies.classList.remove('active');
                const queryInput = document.getElementById('downloaderQuery');
                const resultsContainer = document.getElementById('downloaderResults');
                const emptyContainer = document.getElementById('downloaderEmpty');
                const moviesFilterBtn = document.getElementById('downloaderFilterMovies');
                const tvFilterBtn = document.getElementById('downloaderFilterTV');

                if(resultsContainer) resultsContainer.innerHTML = '';
                if(resultsContainer) resultsContainer.classList.remove('single');
                if(emptyContainer) emptyContainer.style.display = 'none';

                if (provider === 'acermovies') {
                    providerAcermovies.classList.add('active');
                    if (moviesFilterBtn) moviesFilterBtn.style.display = 'none';
                    if (tvFilterBtn) tvFilterBtn.style.display = 'none';
                    if (queryInput) queryInput.placeholder = 'Search acermovies...';
                } else { // Default to 111477
                    provider111477.classList.add('active');
                    if (moviesFilterBtn) moviesFilterBtn.style.display = 'flex';
                    if (tvFilterBtn) tvFilterBtn.style.display = 'flex';
                    if (queryInput) queryInput.placeholder = 'Search movies or shows (e.g., Superman)';
                }
            }

            if (provider111477 && providerAcermovies) {
                provider111477.addEventListener('click', () => setActiveDownloaderProvider('111477'));
                providerAcermovies.addEventListener('click', () => setActiveDownloaderProvider('acermovies'));
                setActiveDownloaderProvider('111477'); // Initial state
            }
            
            async function searchAcerMovies(query) {
                const downloaderResults = document.getElementById('downloaderResults');
                const downloaderEmpty = document.getElementById('downloaderEmpty');
                if (!downloaderResults || !downloaderEmpty || !query.trim()) {
                    if (downloaderResults) downloaderResults.innerHTML = '';
                    if (downloaderEmpty) downloaderEmpty.style.display = 'block';
                    if (downloaderEmpty) downloaderEmpty.textContent = 'Please enter a search term.';
                    return;
                };

                downloaderResults.innerHTML = '';
                downloaderResults.classList.remove('single');
                downloaderEmpty.style.display = 'none';

                try {
                    const res = await fetch(`/api/acermovies/search/${encodeURIComponent(query)}`);
                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                    const data = await res.json();
                    const results = (data && data.searchResult) ? data.searchResult : [];

                    if (results.length === 0) {
                        downloaderEmpty.style.display = 'block';
                        downloaderEmpty.textContent = 'No results found on acermovies.';
                        return;
                    }

                    const frag = document.createDocumentFragment();
                    results.slice(0, 20).forEach((item) => {
                        const card = document.createElement('div');
                        card.className = 'downloader-item';
                        card.tabIndex = 0;
                        card.dataset.url = item.url;

                        card.innerHTML = `
                            <img loading="lazy" class="downloader-thumb" src="${item.image || ''}" alt="${(item.title || '').replace(/"/g,'&quot;')}" onerror="this.style.opacity=0;" />
                            <div class="downloader-meta">
                                <div class="downloader-title">${item.title || 'Untitled'}</div>
                            </div>`;

                        card.addEventListener('click', (e) => {
                            e.preventDefault(); e.stopPropagation();
                            downloaderResults.querySelectorAll('.downloader-item').forEach(el => { if (el !== card) el.remove(); });
                            downloaderResults.classList.add('single');
                            document.querySelectorAll('.downloader-item.selected').forEach(el => el.classList.remove('selected'));
                            card.classList.add('selected');
                            getAcerMovieQualities(card.dataset.url, downloaderResults);
                        });
                        frag.appendChild(card);
                    });
                    downloaderResults.appendChild(frag);

                } catch (err) {
                    console.error('acermovies search failed:', err);
                    downloaderEmpty.style.display = 'block';
                    downloaderEmpty.textContent = 'acermovies search failed.';
                }
            }

            async function getAcerMovieQualities(movieUrl, container) {
                let currentSeriesType = "movie";

                try {
                    const res = await fetch(`/api/acermovies/sourceQuality?url=${encodeURIComponent(movieUrl)}`);
                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                    const data = await res.json();
                    const qualities = (data && data.sourceQualityList) ? data.sourceQualityList : [];
                    const meta = data.meta || {};
                    currentSeriesType = meta.type || "movie";
                    
                    renderAcerFilesCard(qualities, container, currentSeriesType);
                } catch (e) {
                    console.error('Failed to load acermovies qualities', e);
                    if(typeof showNotification === 'function') showNotification('Failed to load qualities for this title', 'error');
                }
            }

            function renderAcerFilesCard(qualities, container, seriesType) {
                const filesWrap = document.createElement('div');
                filesWrap.className = 'trakt-card downloader-files-card';
                filesWrap.style.maxWidth = '900px';
                filesWrap.style.width = '100%';
                const inner = document.createElement('div');
                inner.className = 'trakt-card-body';
                inner.innerHTML = `<h3 style="margin-bottom:0.75rem;">Available Qualities (${qualities.length})</h3>`;

                if (!qualities.length) {
                    inner.innerHTML += '<div class="downloader-empty" style="display:block;">No qualities found for this title.</div>';
                } else {
                    const list = document.createElement('div');
                    list.style.display = 'flex';
                    list.style.flexDirection = 'column';
                    list.style.gap = '0.5rem';

                    qualities.forEach(qItem => {
                        // Fix for episodes having .link instead of .url
                        if (qItem.link && !qItem.url) qItem.url = qItem.link;

                        const row = document.createElement('div');
                        row.style.cssText = 'display:flex; justify-content:space-between; align-items:center; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08); border-radius:10px; padding:0.6rem 0.8rem;';
                        
                        const name = document.createElement('div');
                        name.style.cssText = 'flex:1; margin-right:0.75rem; white-space:normal; word-break:break-word;';
                        name.textContent = qItem.title || 'Unknown Quality';

                        const btnContainer = document.createElement('div');
                        btnContainer.style.display = "flex";
                        btnContainer.style.gap = "8px";
                        btnContainer.style.flexWrap = "wrap";

                        const hasBatch = qItem.batchUrl && qItem.batchUrl.trim() !== "";
                        const hasEpisodes = qItem.episodesUrl && qItem.episodesUrl.trim() !== "";
                        const hasDirectUrl = qItem.url && qItem.url.trim() !== "";

                        if (seriesType === "movie" || seriesType === "episode" || hasDirectUrl) {
                            const pick = document.createElement("button");
                            pick.textContent = "Select";
                            pick.className = 'api-btn api-btn-primary';
                            pick.addEventListener("click", async (ev) => {
                                ev.stopPropagation();
                                pick.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                                pick.disabled = true;
                                await handleQualitySelect(qItem, pick, "direct", container, seriesType === 'episode' ? 'episode' : 'movie');
                            });
                            btnContainer.appendChild(pick);
                        } else {
                            if (hasBatch) {
                                const batchBtn = document.createElement("button");
                                batchBtn.textContent = "Season Pack";
                                batchBtn.className = 'api-btn api-btn-primary';
                                batchBtn.addEventListener("click", async (ev) => {
                                    ev.stopPropagation();
                                        batchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                                    batchBtn.disabled = true;
                                    await handleQualitySelect(qItem, batchBtn, "batch", container);
                                });
                                btnContainer.appendChild(batchBtn);
                            }

                            if (hasEpisodes) {
                                const episodesBtn = document.createElement("button");
                                episodesBtn.textContent = "Individual Episodes";
                                episodesBtn.className = 'api-btn api-btn-primary';
                                episodesBtn.addEventListener("click", async (ev) => {
                                    ev.stopPropagation();
                                        episodesBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                                    episodesBtn.disabled = true;
                                    await handleQualitySelect(qItem, episodesBtn, "episodes", container);
                                });
                                btnContainer.appendChild(episodesBtn);
                            }
                        }

                        row.appendChild(name);
                        row.appendChild(btnContainer);
                        list.appendChild(row);
                    });
                    inner.appendChild(list);
                }
                filesWrap.appendChild(inner);
                container.querySelectorAll('.downloader-files-card').forEach(el => el.remove());
                container.appendChild(filesWrap);
            }

            async function handleQualitySelect(qItem, buttonEl, selectType, container, itemType) {
                if (selectType === "direct" || qItem.url) {
                    await resolveFinal(qItem.url, itemType || "movie", buttonEl);
                } else if (selectType === "batch" && qItem.batchUrl) {
                    await resolveFinal(qItem.batchUrl, "batch", buttonEl);
                } else if (selectType === "episodes" && qItem.episodesUrl) {
                    await showEpisodes(qItem, container);
                } else {
                    buttonEl.innerHTML = "Select";
                    buttonEl.disabled = false;
                    alert("No download URL found.");
                }
            }

            async function showEpisodes(qItem, container) {
                try {
                    const res = await fetch(`/api/acermovies/sourceEpisodes?url=${encodeURIComponent(qItem.episodesUrl)}`);
                    const data = await res.json();
                    const episodes = (data && data.sourceEpisodes) ? data.sourceEpisodes : [];
                    
                    if (!episodes.length) {
                        alert("No episodes found.");
                        return;
                    }
                    
                    renderAcerFilesCard(episodes, container, "episode");

                } catch (e) {
                    console.error(e);
                    alert("Failed to load episodes.");
                }
            }

            async function resolveFinal(url, seriesType, buttonEl) {
                try {
                    const res = await fetch(`/api/acermovies/sourceUrl?url=${encodeURIComponent(url)}&seriesType=${seriesType}`);
                    const data = await res.json();
                    const finalUrl = data && data.sourceUrl ? data.sourceUrl : "";

                    if (!finalUrl) {
                        buttonEl.innerHTML = "Select";
                        buttonEl.disabled = false;
                        alert("No final link returned.");
                        return;
                    }
                    
                    buttonEl.innerHTML = "Download";
                    buttonEl.disabled = false;
                    buttonEl.onclick = () => {
                        if (window.electronAPI?.openExternal) {
                            window.electronAPI.openExternal(finalUrl);
                        } else {
                            window.open(finalUrl, "_blank");
                        }
                    };

                } catch (e) {
                    console.error(e);
                    buttonEl.innerHTML = "Select";
                    buttonEl.disabled = false;
                    alert("Failed to resolve final link.");
                }
            }
            // [END] AcerMovies Integration

            if (downloaderBtn && downloaderQuery) {
                // Clone the button to remove any old listeners that might exist.
                const newDownloaderBtn = downloaderBtn.cloneNode(true);
                downloaderBtn.parentNode.replaceChild(newDownloaderBtn, downloaderBtn);

                const searchHandler = () => {
                    const acermoviesProviderActive = providerAcermovies?.classList.contains('active');
                    if (acermoviesProviderActive) {
                        searchAcerMovies(downloaderQuery.value);
                    } else {
                        runDownloaderSearch(downloaderQuery.value);
                    }
                };

                newDownloaderBtn.addEventListener('click', searchHandler);
                downloaderQuery.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault(); // Prevent form submission if it's in a form
                        searchHandler();
                    }
                });
            }
            
            // Quick refresh button
            const quickRefresh = document.getElementById('quickRefresh');
            if (quickRefresh) {
                quickRefresh.addEventListener('click', () => {
                    window.location.reload();
                });
            }
            
            // Sort and Filter buttons (NEW UI)
            const sortBtn = document.getElementById('sortBtn');
            const filterBtn = document.getElementById('filterBtn');
            if (sortBtn) {
                sortBtn.addEventListener('click', () => {
                    // Cycle through sort options
                    if (currentSort === 'popularity') {
                        currentSort = 'rating';
                        showNotification('Sorted by Rating ');
                    } else if (currentSort === 'rating') {
                        currentSort = 'date';
                        showNotification('Sorted by Release Date ');
                    } else {
                        currentSort = 'popularity';
                        showNotification('Sorted by Popularity ');
                    }
                    refreshDisplay();
                });
            }
            if (filterBtn) {
                filterBtn.addEventListener('click', () => {
                    // Cycle through filter options
                    if (currentFilter === 'all') {
                        currentFilter = 'hd';
                        showNotification('Filter: HD Quality (7+ rating) ');
                    } else if (currentFilter === 'hd') {
                        currentFilter = '4k';
                        showNotification('Filter: 4K Quality (8+ rating) ');
                    } else {
                        currentFilter = 'all';
                        showNotification('Filter: All Content ');
                    }
                    refreshDisplay();
                });
            }
            
            // Live TV Event Listeners
            const liveTvCategorySelect = document.getElementById('livetv-category-select');
            if (liveTvCategorySelect) {
                liveTvCategorySelect.addEventListener('change', () => {
                    loadLiveTvMatches(liveTvCategorySelect.value);
                });
            }
            
            const liveTvSearchInput = document.getElementById('livetv-search-input');
            if (liveTvSearchInput) {
                // Debounce search to avoid too many updates
                let searchTimeout;
                liveTvSearchInput.addEventListener('input', () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        loadLiveTvMatches(liveTvCategorySelect ? liveTvCategorySelect.value : 'football');
                    }, 300);
                });
            }
            
            const liveTvStreamsClose = document.getElementById('livetv-streams-close');
            if (liveTvStreamsClose) {
                liveTvStreamsClose.addEventListener('click', () => {
                    const modal = document.getElementById('livetv-streams-modal');
                    if (modal) modal.style.display = 'none';
                });
            }
            
            const liveTvModalBack = document.getElementById('livetv-modal-back');
            if (liveTvModalBack) {
                liveTvModalBack.addEventListener('click', () => {
                    const modal = document.getElementById('livetv-stream-modal');
                    const iframe = document.getElementById('livetv-stream-iframe');
                    if (modal) modal.style.display = 'none';
                    if (iframe) iframe.src = ''; // Stop stream
                });
            }
            
            const liveTvCopyBtn = document.getElementById('livetv-copy-stream-btn');
            if (liveTvCopyBtn) {
                liveTvCopyBtn.addEventListener('click', async () => {
                    const modal = document.getElementById('livetv-stream-modal');
                    const streamUrl = modal?.dataset.currentStreamUrl;
                    
                    if (streamUrl) {
                        try {
                            await navigator.clipboard.writeText(streamUrl);
                            const originalText = liveTvCopyBtn.innerHTML;
                            liveTvCopyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                            liveTvCopyBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                            
                            setTimeout(() => {
                                liveTvCopyBtn.innerHTML = originalText;
                                liveTvCopyBtn.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy:', err);
                            showNotification('Failed to copy link', 'error');
                        }
                    }
                });
            }
            
            // Close modals on background click
            const liveTvStreamsModal = document.getElementById('livetv-streams-modal');
            if (liveTvStreamsModal) {
                liveTvStreamsModal.addEventListener('click', (e) => {
                    if (e.target === liveTvStreamsModal) {
                        liveTvStreamsModal.style.display = 'none';
                    }
                });
            }
        }

        // Router handler
        async function handleRoute() {
            const hash = window.location.hash || '#/';
            // Default route
            if (hash === '#/' || hash === '#') {
                activeRoute = 'home';
                showSection('home');
                // Load home content if first time or if grid empty
                if (moviesGrid.children.length === 0) {
                    currentPage = 1;
                    moviesGrid.innerHTML = '';
                    await loadMovies(currentCategory);
                }
                return;
            }

            if (hash.startsWith('#/genre/')) {
    const genreName = decodeURIComponent(hash.slice('#/genre/'.length)).trim();
    activeRoute = 'genreDetails';
    showSection('genreDetails');
    await ensureGenresLoaded();
    await openGenreDetails(genreName);
    return;
} else if (hash === '#/genres') {
    activeRoute = 'genres';
    showSection('genres');
    await ensureGenresLoaded();
    renderGenres();
    return;
} else if (hash === '#/my-list') {
    activeRoute = 'my-list';
    showSection('my-list');
    await displayMyList();
    return;
} else if (hash === '#/done-watching') {
    activeRoute = 'done-watching';
    showSection('done-watching');
    await displayDoneWatching();
    return;
} else if (hash === '#/trakt') {
    activeRoute = 'trakt';
    showSection('trakt');
    return;
} else if (hash === '#/livetv') {
    activeRoute = 'livetv';
    showSection('livetv');
    await initLiveTv();
    return;
} else if (hash === '#/iptv') {
    activeRoute = 'iptv';
    showSection('iptv');
    reloadIptvPage();
    return;
} else if (hash === '#/games-downloader') {
    activeRoute = 'games-downloader';
    showSection('games-downloader');
    return;
} else if (hash === '#/minigames') {
    activeRoute = 'minigames';
    showSection('minigames');
    reloadMiniGamesPage();
    return;
            } else if (hash === '#/books') {
                activeRoute = 'books';
                showSection('books');
                // startBooks(); - Reverted auto-load
                startBooks(); 
                return;
            } else if (hash === '#/audiobooks') {    activeRoute = 'audiobooks';
    showSection('audiobooks');
    return;
} else if (hash === '#/music') {
    activeRoute = 'music';
    showSection('music');
    return;
} else if (hash === '#/booktorrio') {
    activeRoute = 'booktorrio';
    showSection('booktorrio');
    return;
} else if (hash === '#/anime') {
    activeRoute = 'anime';
    showSection('anime');
    return;
} else if (hash === '#/comics') {
    activeRoute = 'comics';
    showSection('comics');
    return;
} else if (hash === '#/manga') {
    activeRoute = 'manga';
    showSection('manga');
    return;
} else if (hash === '#/downloader') {
    activeRoute = 'downloader';
    showSection('downloader');
    return;
} else if (hash === '#/settings') {
    activeRoute = 'settings';
    showSection('settings');
    await loadSettingsData();
    return;
}

            // Fallback
            activeRoute = 'home';
            showSection('home');
        }

        function showSection(section) {
            // Hide ALL known top-level pages first to avoid stacking
            const allPageIds = [
                'homePage','genresPage','genreDetailsPage','myListPage','doneWatchingPage',
                'trakt-page','livetv-page','iptv-page','games-downloader-page','minigames-page','books-page','music-page',
                'audiobooks-page','booktorrio-page','anime-page','comics-page','comics-reader-page','manga-page','manga-reader-page','downloader-page','settings-page'
            ];
            allPageIds.forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });

            // Special leave-behavior
            // Stop music if we are not showing the music page AND player is not minimized
            if (section !== 'music') {
                const audio = document.getElementById('music-player-audio');
                const modal = document.getElementById('music-player-modal');
                const miniPlayer = document.getElementById('music-mini-player');
                
                // Only pause if mini player is not visible (not minimized)
                const isMiniPlayerVisible = miniPlayer && miniPlayer.style.display !== 'none';
                if (!isMiniPlayerVisible) {
                    if (audio) { try { audio.pause(); } catch(_) {} }
                    if (modal) modal.style.display = 'none';
                }
            }
            // Clear IPTV iframe if not on IPTV page
            if (section !== 'iptv') {
                try { clearIptvPage(); } catch(_) {}
            }
            // Clear MiniGames iframe if not on MiniGames page
            if (section !== 'minigames') {
                try { clearMiniGamesPage(); } catch(_) {}
            }

            // Map route section to element id
            const map = {
                'home': 'homePage',
                'genres': 'genresPage',
                'genreDetails': 'genreDetailsPage',
                'my-list': 'myListPage',
                'done-watching': 'doneWatchingPage',
                'trakt': 'trakt-page',
                'livetv': 'livetv-page',
                'iptv': 'iptv-page',
                'games-downloader': 'games-downloader-page',
                'minigames': 'minigames-page',
                'books': 'books-page',
                'music': 'music-page',
                'audiobooks': 'audiobooks-page',
                'booktorrio': 'booktorrio-page',
                'anime': 'anime-page',
                'comics': 'comics-page',
                'comics-reader': 'comics-reader-page',
                'manga': 'manga-page',
                'manga-reader': 'manga-reader-page',
                'downloader': 'downloader-page',
                'settings': 'settings-page'
            };
            const targetId = map[section];
            if (targetId) {
                const el = document.getElementById(targetId);
                if (el) el.style.display = '';
                // Init Trakt page once, but always refresh status on navigation
                if (section === 'trakt' && el) {
                    if (!el.dataset.initialized) {
                        initializeTraktPage();
                        el.dataset.initialized = 'true';
                    } else {
                        // Ensure status is fresh after actions elsewhere (e.g., Settings disconnect)
                        try { updateTraktPageStatus(); } catch(_) {}
                    }
                }
                
                // Initialize Comics when showing comics page
                if (section === 'comics' && el) {
                    try { initializeComics(); } catch(err) { console.error('Error initializing comics:', err); }
                } else {
                    // Deactivate comics when switching to another page
                    console.log('[COMICS] Deactivating comics page');
                    comicsPageActive = false;
                }
                
                // Auto-load games when showing games downloader page
                if (section === 'games-downloader' && el) {
                    if (!el.dataset.gamesLoaded) {
                        try {
                            // Small delay to ensure DOM is ready
                            setTimeout(() => {
                                loadGameCategories();
                                browseAllGames();
                            }, 100);
                            el.dataset.gamesLoaded = 'true';
                        } catch(err) { 
                            console.error('Error loading games:', err); 
                        }
                    }
                }
                
                // Update Discord presence for MiniGames
                if (section === 'minigames') {
                    if (window.electronAPI?.updateDiscordPresence) {
                        window.electronAPI.updateDiscordPresence({
                            details: 'Playing mini games',
                            state: 'PlayTorrio MiniGames',
                            largeImageKey: 'playtorrio',
                            largeImageText: 'PlayTorrio',
                            smallImageKey: 'gaming',
                            smallImageText: 'Gaming'
                        }).catch(err => console.error('Discord presence error:', err));
                    }
                }
                
                // Update Discord presence for Games Downloader
                if (section === 'games-downloader') {
                    if (window.electronAPI?.updateDiscordPresence) {
                        window.electronAPI.updateDiscordPresence({
                            details: 'Browsing PC games',
                            state: 'Games Downloader',
                            largeImageKey: 'playtorrio',
                            largeImageText: 'PlayTorrio',
                            smallImageKey: 'download',
                            smallImageText: 'Downloading'
                        }).catch(err => console.error('Discord presence error:', err));
                    }
                }
            }

            // Update nav/fab, reset load flag, scroll to top
            updateNavigationStates(section);
            updateFloatingSettingsButton(section);
            isLoading = false;
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function updateFloatingSettingsButton(section) {
            const floatingNav = document.getElementById('floatingNavContainer');
            if (floatingNav) {
                // Show only on home page in old UI
                if (section === 'home') {
                    floatingNav.classList.add('show-on-home');
                } else {
                    floatingNav.classList.remove('show-on-home');
                    floatingNav.classList.remove('active'); // Close menu when leaving home
                }
            }
        }

        function updateNavigationStates(activeSection) {
            // Update sidebar navigation (new UI)
            const sidebarNavItems = document.querySelectorAll('.nav-item[data-page]');
            sidebarNavItems.forEach(item => {
                item.classList.remove('active');
                if (item.dataset.page === activeSection || 
                    (activeSection === 'genreDetails' && item.dataset.page === 'genres')) {
                    item.classList.add('active');
                }
            });

            // Update header buttons (classic UI)
            const headerButtons = {
                'home': null, // No specific home button
                'genres': document.getElementById('genresBtn'),
                'my-list': document.getElementById('myListBtn'),
                'done-watching': document.getElementById('doneWatchingBtn'),
                'trakt': null // Trakt is only in new UI sidebar
            };

            // Reset all header button active states
            Object.values(headerButtons).forEach(btn => {
                if (btn) btn.classList.remove('active');
            });

            // Set active header button
            const activeBtn = headerButtons[activeSection];
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        async function ensureGenresLoaded() {
            if (genresLoaded) return;
            try {
                genresLoading.style.display = 'block';
                // Fetch movie and tv genres
                const [movieRes, tvRes] = await Promise.all([
                    fetch(`https://api.themoviedb.org/3/genre/movie/list?api_key=${TMDB_API_KEY}`),
                    fetch(`https://api.themoviedb.org/3/genre/tv/list?api_key=${TMDB_API_KEY}`)
                ]);
                const [movieData, tvData] = await Promise.all([movieRes.json(), tvRes.json()]);
                const map = new Map();
                (movieData.genres || []).forEach(g => {
                    const key = g.name.toLowerCase();
                    map.set(key, { name: g.name, movieId: g.id, tvId: null });
                });
                (tvData.genres || []).forEach(g => {
                    const key = g.name.toLowerCase();
                    if (map.has(key)) {
                        map.get(key).tvId = g.id;
                    } else {
                        map.set(key, { name: g.name, movieId: null, tvId: g.id });
                    }
                });
                genresMap = map;
                genresLoaded = true;
            } catch (e) {
                console.error('Error loading genres:', e);
            } finally {
                genresLoading.style.display = 'none';
            }
        }

        function renderGenres() {
            genresGrid.innerHTML = '';
            const entries = Array.from(genresMap.values()).sort((a, b) => a.name.localeCompare(b.name));
            entries.forEach(g => {
                const card = document.createElement('div');
                card.className = 'genre-card';
                card.innerHTML = `
                    <div class="genre-info">
                        <div class="genre-title">${g.name}</div>
                        <div class="genre-availability">
                            ${g.movieId ? '<span class="genre-chip"><i class="fas fa-film"></i> Movie</span>' : ''}
                            ${g.tvId ? '<span class="genre-chip"><i class="fas fa-tv"></i> TV</span>' : ''}
                        </div>
                    </div>
                `;
                card.addEventListener('click', () => {
                    window.location.hash = `#/genre/${encodeURIComponent(g.name)}`;
                });
                genresGrid.appendChild(card);
            });
        }

        function setGenreToggleActive() {
            toggleMoviesBtn.classList.toggle('active', currentGenreType === 'movie');
            toggleTVBtn.classList.toggle('active', currentGenreType === 'tv');
        }

        async function openGenreDetails(genreName) {
            const key = genreName.toLowerCase();
            currentGenre = genresMap.get(key);
            if (!currentGenre) {
                // If genre map not found (edge case), reload genres and try again
                await ensureGenresLoaded();
                currentGenre = genresMap.get(key);
            }
            if (!currentGenre) {
                genreTitleEl.textContent = genreName;
                genreResultsGrid.innerHTML = '';
                genreEmptyMessage.style.display = 'block';
                return;
            }

            genreTitleEl.textContent = currentGenre.name;

            // Default type preference: movie if available, else tv
            currentGenreType = currentGenre.movieId ? 'movie' : 'tv';
            setGenreToggleActive();

            // Reset results grid
            genreResultsGrid.innerHTML = '';
            genreEmptyMessage.style.display = 'none';
            genreCurrentPage = 1;

            await loadGenreItems();
        }

        function setGenreType(type) {
            currentGenreType = type;
            setGenreToggleActive();
            // Reset and reload
            genreResultsGrid.innerHTML = '';
            genreEmptyMessage.style.display = 'none';
            genreCurrentPage = 1;
            isLoading = false;
            loadGenreItems();
        }

        async function loadGenreItems() {
            if (isLoading) return;
            const genreId = currentGenreType === 'movie' ? currentGenre.movieId : currentGenre.tvId;
            if (!genreId) {
                genreEmptyMessage.style.display = 'block';
                return;
            }
            isLoading = true;
            genreLoadingIndicator.style.display = 'block';
            try {
                const url = `https://api.themoviedb.org/3/discover/${currentGenreType}?api_key=${TMDB_API_KEY}&with_genres=${genreId}&sort_by=popularity.desc&page=${genreCurrentPage}`;
                const res = await fetch(url);
                const data = await res.json();
                const items = data.results || [];
                if (genreCurrentPage === 1 && items.length === 0) {
                    genreEmptyMessage.style.display = 'block';
                } else {
                    displayGenreItems(items, currentGenreType);
                    genreCurrentPage++;
                }
            } catch (e) {
                console.error('Error loading genre items:', e);
            } finally {
                isLoading = false;
                genreLoadingIndicator.style.display = 'none';
            }
        }

        function displayGenreItems(items, mediaType) {
            items.forEach(item => {
                if (!item.poster_path) return;
                const card = document.createElement('div');
                card.className = 'movie-card';
                const title = item.title || item.name || 'Untitled';
                const year = (item.release_date || item.first_air_date || '').substring(0, 4);
                const rating = (item.vote_average || 0).toFixed(1);
                // Only show Done Watching button for movies (not TV shows)
                const doneBtnHTML = mediaType === 'movie'
                    ? `<button class="done-watching-btn" onclick="toggleDoneWatching(event, ${item.id}, '${mediaType}', '${title.replace(/'/g, "\\'")}', '${item.poster_path}', '${year}', ${item.vote_average || 0})">
                        <i class="fas fa-check"></i>
                      </button>`
                    : '';
                card.innerHTML = `
                    <button class="add-to-list-btn" onclick="toggleMyList(event, ${item.id}, '${mediaType}', '${title.replace(/'/g, "\\'")}', '${item.poster_path}', '${year}', ${item.vote_average || 0})">
                        <i class="fas fa-plus"></i>
                    </button>
                    ${doneBtnHTML}
                    <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${title}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${title}</h3>
                        <p class="movie-year">${year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${rating}
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(item, mediaType));
                genreResultsGrid.appendChild(card);
            });
        }

        // Load movies from TMDB (home)
        async function loadMovies(category = 'all') {
            if (isLoading) return;
            isLoading = true;
            loadingIndicator.style.display = 'block';
            
            // Reset cache if it's the first page
            if (currentPage === 1) {
                allMoviesCache = [];
            }
            
            try {
                let url;
                if (category === 'all') {
                    url = `https://api.themoviedb.org/3/trending/all/week?api_key=${TMDB_API_KEY}&page=${currentPage}`;
                } else {
                    url = `https://api.themoviedb.org/3/trending/${category}/week?api_key=${TMDB_API_KEY}&page=${currentPage}`;
                }
                const response = await fetch(url);
                const data = await response.json();
                displayMovies(data.results, currentPage > 1);
                currentPage++;
            } catch (error) {
                console.error('Error fetching movies:', error);
            }

            isLoading = false;
            loadingIndicator.style.display = 'none';
        }

        // Search for movies and shows
        async function searchMovies(query) {
            if (isLoading) return;
            isLoading = true;
            
            // Hide sliders and show grid for search results (new UI)
            if (document.body.classList.contains('ui-new')) {
                const slidersContainer = document.getElementById('slidersContainer');
                const heroSection = document.getElementById('heroSection');
                const backBtn = document.getElementById('backToHomeBtn');
                if (slidersContainer) slidersContainer.style.display = 'none';
                if (heroSection) heroSection.style.display = 'none';
                if (backBtn) backBtn.style.display = 'block';
                moviesGrid.style.display = 'grid';
            }
            
            moviesGrid.innerHTML = '';
            loadingIndicator.style.display = 'block';

            try {
                const response = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&page=1`);
                const data = await response.json();
                
                // Store search results and set search mode
                lastSearchResults = data.results || [];
                lastSearchQuery = query;
                isSearchMode = true;
                
                displayMovies(data.results);
            } catch (error) {
                console.error('Error searching movies:', error);
            }

            isLoading = false;
            loadingIndicator.style.display = 'none';
        }

        // Display movies in the grid (chunked + capped for performance)
        function displayMovies(movies, append = true) {
            // Cache movies for sorting/filtering
            if (!append) {
                allMoviesCache = [...movies];
            } else {
                allMoviesCache = [...allMoviesCache, ...movies];
            }
            
            // Apply current sort and filter
            let filteredMovies = applySortAndFilter([...movies]);
            // Build in a fragment to minimize reflows
            const frag = document.createDocumentFragment();
            for (const movie of filteredMovies) {
                if (!movie.poster_path) continue;
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.dataset.rating = movie.vote_average || 0;
                card.dataset.date = movie.release_date || movie.first_air_date || '';
                const mediaType = movie.media_type || 'movie';
                const doneBtnHTML = mediaType === 'movie'
                    ? `<button class="done-watching-btn" onclick="toggleDoneWatching(event, ${movie.id}, '${mediaType}', '${(movie.title || movie.name || '').replace(/'/g, "\\'")}', '${movie.poster_path}', '${(movie.release_date || movie.first_air_date || '').substring(0, 4)}', ${movie.vote_average || 0})">
                        <i class="fas fa-check"></i>
                      </button>`
                    : '';
                const year = (movie.release_date || movie.first_air_date || '').substring(0, 4);
                const titleSafe = (movie.title || movie.name || '').replace(/'/g, "\\'");
                const posterUrl = `https://image.tmdb.org/t/p/w342${movie.poster_path}`; // lighter grid thumbs
                card.innerHTML = `
                    <button class="add-to-list-btn" onclick="toggleMyList(event, ${movie.id}, '${mediaType}', '${titleSafe}', '${movie.poster_path}', '${year}', ${movie.vote_average || 0})">
                        <i class="fas fa-plus"></i>
                    </button>
                    ${doneBtnHTML}
                    <img loading="lazy" decoding="async" src="${posterUrl}" alt="${titleSafe}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${movie.title || movie.name}</h3>
                        <p class="movie-year">${year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${Number(movie.vote_average || 0).toFixed(1)}
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(movie, movie.media_type || null));
                frag.appendChild(card);
            }
            moviesGrid.appendChild(frag);

            // Cap total DOM nodes in perf-mode to keep things snappy on low-end machines
            try {
                if (document.body.classList.contains('perf-mode')) {
                    const MAX_CARDS = 300; // adjustable
                    while (moviesGrid.children.length > MAX_CARDS) {
                        moviesGrid.removeChild(moviesGrid.firstElementChild);
                    }
                }
            } catch(_) {}
        }
        
        // Apply sort and filter to movies
        function applySortAndFilter(movies) {
            let filtered = [...movies];
            
            // Apply filter
            if (currentFilter === 'hd') {
                filtered = filtered.filter(m => (m.vote_average || 0) >= 7);
            } else if (currentFilter === '4k') {
                filtered = filtered.filter(m => (m.vote_average || 0) >= 8);
            }
            
            // Apply sort
            if (currentSort === 'rating') {
                filtered.sort((a, b) => (b.vote_average || 0) - (a.vote_average || 0));
            } else if (currentSort === 'date') {
                filtered.sort((a, b) => {
                    const dateA = new Date(a.release_date || a.first_air_date || 0);
                    const dateB = new Date(b.release_date || b.first_air_date || 0);
                    return dateB - dateA;
                });
            }
            // popularity is default (no sorting needed as TMDB returns sorted by popularity)
            
            return filtered;
        }
        
        // Refresh display with current sort/filter
        function refreshDisplay() {
            moviesGrid.innerHTML = '';
            displayMovies(allMoviesCache, false);
        }
        
        // ==== NEW UI: HERO SECTION AND SLIDERS ====
        async function initializeNewUI() {
            if (!document.body.classList.contains('ui-new')) return;
            
            // Show hero and sliders, hide grid
            const heroSection = document.getElementById('heroSection');
            const slidersContainer = document.getElementById('slidersContainer');
            const moviesGrid = document.getElementById('moviesGrid');
            
            if (heroSection) heroSection.style.display = 'block';
            if (slidersContainer) slidersContainer.style.display = 'block';
            if (moviesGrid) moviesGrid.style.display = 'none';
            
            // Load data for hero and sliders
            await Promise.all([
                loadHeroContent(),
                loadSliders()
            ]);
            
            // Setup slider navigation
            setupSliderNavigation();
        }
        
        async function loadHeroContent() {
            try {
                const response = await fetch(`https://api.themoviedb.org/3/trending/all/day?api_key=${TMDB_API_KEY}`);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    // Pick a random item from top 5 for variety
                    const heroItem = data.results[Math.floor(Math.random() * Math.min(5, data.results.length))];
                    displayHero(heroItem);
                }
            } catch (error) {
                console.error('Error loading hero content:', error);
            }
        }
        
        function displayHero(item) {
            const heroBackdrop = document.getElementById('heroBackdrop');
            const heroTitle = document.getElementById('heroTitle');
            const heroOverview = document.getElementById('heroOverview');
            const heroYear = document.getElementById('heroYear');
            const heroRating = document.getElementById('heroRating');
            const heroRatingValue = document.getElementById('heroRatingValue');
            const heroRuntime = document.getElementById('heroRuntime');
            const heroPlayBtn = document.getElementById('heroPlayBtn');
            const heroInfoBtn = document.getElementById('heroInfoBtn');
            
            if (item.backdrop_path) {
                heroBackdrop.src = `https://image.tmdb.org/t/p/original${item.backdrop_path}`;
            }
            
            heroTitle.textContent = item.title || item.name;
            heroOverview.textContent = item.overview || 'No description available.';
            
            const year = (item.release_date || item.first_air_date || '').substring(0, 4);
            heroYear.textContent = year;
            
            if (item.vote_average) {
                heroRating.style.display = 'flex';
                heroRatingValue.textContent = Number(item.vote_average).toFixed(1);
            }
            
            // Store media type for click handlers
            const mediaType = item.media_type || 'movie';
            
            heroPlayBtn.onclick = () => openDetailsModal(item, mediaType);
            heroInfoBtn.onclick = () => openDetailsModal(item, mediaType);
        }
        
        async function loadSliders() {
            try {
                const [trending, popular, topRated, tvShows] = await Promise.all([
                    fetch(`https://api.themoviedb.org/3/trending/all/week?api_key=${TMDB_API_KEY}`).then(r => r.json()),
                    fetch(`https://api.themoviedb.org/3/movie/popular?api_key=${TMDB_API_KEY}`).then(r => r.json()),
                    fetch(`https://api.themoviedb.org/3/movie/top_rated?api_key=${TMDB_API_KEY}`).then(r => r.json()),
                    fetch(`https://api.themoviedb.org/3/tv/popular?api_key=${TMDB_API_KEY}`).then(r => r.json())
                ]);
                
                populateSlider('trendingSlider', trending.results.slice(0, 20));
                populateSlider('popularSlider', popular.results.slice(0, 20));
                populateSlider('topratedSlider', topRated.results.slice(0, 20));
                populateSlider('tvshowsSlider', tvShows.results.slice(0, 20));
            } catch (error) {
                console.error('Error loading sliders:', error);
            }
        }
        
        function populateSlider(sliderId, items) {
            const slider = document.getElementById(sliderId);
            if (!slider) return;
            
            slider.innerHTML = '';
            
            items.forEach(item => {
                if (!item.poster_path) return;
                
                const sliderItem = document.createElement('div');
                sliderItem.className = 'slider-item';
                
                const year = (item.release_date || item.first_air_date || '').substring(0, 4);
                const mediaType = item.media_type || (sliderId.includes('tv') ? 'tv' : 'movie');
                
                sliderItem.innerHTML = `
                    <img src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${item.title || item.name}" class="slider-poster">
                    <div class="slider-info">
                        <div class="slider-item-title">${item.title || item.name}</div>
                        <div class="slider-item-meta">
                            <span class="slider-rating">
                                <i class="fas fa-star"></i>
                                ${Number(item.vote_average || 0).toFixed(1)}
                            </span>
                            <span class="slider-year">${year}</span>
                        </div>
                    </div>
                `;
                
                sliderItem.onclick = () => openDetailsModal(item, mediaType);
                slider.appendChild(sliderItem);
            });
        }
        
        function setupSliderNavigation() {
            const arrows = document.querySelectorAll('.slider-arrow');
            
            arrows.forEach(arrow => {
                arrow.addEventListener('click', () => {
                    const sliderName = arrow.dataset.slider;
                    const isLeft = arrow.classList.contains('slider-arrow-left');
                    const sliderContainer = document.querySelector(`#${sliderName}Slider`).parentElement;
                    
                    if (!sliderContainer) return;
                    
                    const scrollAmount = 810; // 3 items (270 each including gap)
                    const currentScroll = sliderContainer.scrollLeft;
                    const newScroll = isLeft ? currentScroll - scrollAmount : currentScroll + scrollAmount;
                    
                    sliderContainer.scrollTo({
                        left: newScroll,
                        behavior: 'smooth'
                    });
                });
            });
            
            // Update arrow states based on scroll position
            const sliderContainers = document.querySelectorAll('.slider-container');
            sliderContainers.forEach(container => {
                container.addEventListener('scroll', () => {
                    updateArrowStates(container);
                });
                updateArrowStates(container);
            });
        }
        
        function updateArrowStates(container) {
            const slider = container.querySelector('.slider-track');
            if (!slider) return;
            
            const section = container.closest('.slider-section');
            if (!section) return;
            
            const leftArrow = section.querySelector('.slider-arrow-left');
            const rightArrow = section.querySelector('.slider-arrow-right');
            
            const scrollLeft = container.scrollLeft;
            const scrollWidth = container.scrollWidth;
            const clientWidth = container.clientWidth;
            
            if (leftArrow) {
                leftArrow.classList.toggle('disabled', scrollLeft <= 0);
            }
            
            if (rightArrow) {
                rightArrow.classList.toggle('disabled', scrollLeft + clientWidth >= scrollWidth - 10);
            }
        }

        // Handle infinite scroll - route aware
        function handleScroll(e) {
            let shouldLoad = false;
            
            // Disable infinite scroll ONLY on Home "All" in new UI (uses sliders)
            // Keep infinite scroll enabled for other routes like genreDetails
            if (document.body.classList.contains('ui-new') && activeRoute === 'home') {
                if (currentCategory === 'all') {
                    return; // No infinite scroll for Home "All" section
                }
            }
            
            // Check if we're in NEW UI mode (scrolling inside main element)
            if (document.body.classList.contains('ui-new')) {
                const mainElement = document.querySelector('.app-main main');
                if (mainElement) {
                    const scrollTop = mainElement.scrollTop;
                    const scrollHeight = mainElement.scrollHeight;
                    const clientHeight = mainElement.clientHeight;
                    
                    if (activeRoute === 'books') {
                        shouldLoad = scrollTop + clientHeight >= scrollHeight - 500 && !booksIsLoading;
                    } else {
                        shouldLoad = scrollTop + clientHeight >= scrollHeight - 500 && !isLoading;
                    }
                }
            } else {
                // OLD UI mode (scrolling on window)
                if (activeRoute === 'books') {
                    shouldLoad = window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && !booksIsLoading;
                } else {
                    shouldLoad = window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && !isLoading;
                }
            }
            
            if (shouldLoad) {
                if (activeRoute === 'home') {
                    loadMovies(currentCategory);
                } else if (activeRoute === 'genreDetails') {
                    loadGenreItems();
                }
            }
        }

        // Open details modal (accept optional forced type)
        async function openDetailsModal(movie, forcedType = null) {
            currentContent = movie;
            // Determine media type FIRST before any UI updates
            if (forcedType) {
                currentMediaType = forcedType === 'tv' ? 'tv' : 'movie';
            } else {
                if (movie.media_type) {
                    currentMediaType = movie.media_type === 'tv' ? 'tv' : 'movie';
                } else {
                    // Infer by presence of 'name' vs 'title'
                    currentMediaType = movie.name && !movie.title ? 'tv' : 'movie';
                }
            }
            
            console.log('[MODAL] Opening modal for:', movie.title || movie.name, 'Type:', currentMediaType);
            
            torrentsLoaded = false;
            torrentsContainer.style.display = 'none';
            torrentsList.innerHTML = '';

            modalBackdrop.src = (movie.backdrop_path && movie.backdrop_path.startsWith('http')) ? movie.backdrop_path : `https://image.tmdb.org/t/p/w1280${movie.backdrop_path || movie.poster_path || ''}`;
            modalPoster.src = (movie.poster_path && movie.poster_path.startsWith('http')) ? movie.poster_path : `https://image.tmdb.org/t/p/w342${movie.poster_path || movie.backdrop_path || ''}`;
            modalTitle.textContent = movie.title || movie.name || 'Untitled';
            modalRating.textContent = Number(movie.vote_average || 0).toFixed(1);
            modalYear.textContent = (movie.release_date || movie.first_air_date || '').substring(0, 4);
            modalOverview.textContent = movie.overview || '';

            // Store current movie data for Trakt
            currentMovie = movie;

            // Set up Trakt watchlist button
            setupTraktWatchlistButton();

            // Set up Done Watching button in modal
            try {
                await loadDoneWatching();
            } catch (_) {}
            const modalDoneBtn = document.getElementById('modalDoneWatchingBtn');
            if (modalDoneBtn) {
                const mediaType = currentMediaType;
                const titleSafe = (movie.title || movie.name || '').replace(/'/g, "\\'");
                const poster = movie.poster_path || '';
                const year = (movie.release_date || movie.first_air_date || '').substring(0, 4);
                const rating = movie.vote_average || 0;
                // Wire click via inline so global updater functions can detect id/mediaType
                modalDoneBtn.setAttribute('onclick', `toggleDoneWatching(event, ${movie.id}, '${mediaType}', '${titleSafe}', '${poster}', '${year}', ${rating})`);
                // Initialize icon state
                const isDone = (Array.isArray(doneWatchingCache) ? doneWatchingCache : []).some(item =>
                    item.id === movie.id && item.media_type === mediaType && (!item.season && !item.episode)
                );
                modalDoneBtn.classList.toggle('is-done', !!isDone);
                modalDoneBtn.innerHTML = `<i class="fas ${isDone ? 'fa-check-circle' : 'fa-check'}"></i>`;
                modalDoneBtn.title = isDone ? 'Remove from Done Watching' : 'Mark as Done Watching';
            }

            // Fetch additional details
            const detailsUrl = `https://api.themoviedb.org/3/${currentMediaType}/${movie.id}?api_key=${TMDB_API_KEY}&append_to_response=credits,similar`;
            try {
                const response = await fetch(detailsUrl);
                const details = await response.json();
                modalRuntime.textContent = details.runtime ? `${details.runtime} min` : (details.episode_run_time && details.episode_run_time.length ? `${details.episode_run_time[0]} min` : '');
                modalTagline.textContent = details.tagline || '';
                displayCast(details.credits?.cast || []);
                displaySimilar(details.similar?.results || [], currentMediaType);

                if (currentMediaType === 'tv') {
                    seasonsContainer.style.display = 'block';
                    displaySeasons(details.seasons || []);
                    // Load episodes for the first usable season by default
                    const firstSeason = (details.seasons || []).find(s => s.season_number !== 0);
                    if (firstSeason) {
                        currentSeason = firstSeason.season_number;
                        loadEpisodes(firstSeason.season_number);
                    }
                } else {
                    seasonsContainer.style.display = 'none';
                }

            } catch (error) {
                console.error('Error fetching details:', error);
            }

            detailsModal.classList.add('active');
            document.body.style.overflow = 'hidden';

            // Ensure the Watch Now UI reflects current mode and media type when opening
            try { updateWatchButtonText(); } catch(_) {}
        }

        // Close details modal
        function closeModal() {
            detailsModal.classList.remove('active');
            document.body.style.overflow = 'auto';
            
            // Reset provider selection to default
            selectedProvider = 'playtorrio';
            document.querySelectorAll('.provider-btn').forEach(btn => {
                if (btn.dataset.provider === 'playtorrio') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Reset tracked search parameters
            lastSearchedSeason = null;
            lastSearchedEpisode = null;
        }

        // Display cast
        function displayCast(cast) {
            castGrid.innerHTML = '';
            (cast || []).slice(0, 10).forEach(member => {
                const card = document.createElement('div');
                card.className = 'cast-card';
                card.innerHTML = `
                    <img src="${member.profile_path ? `https://image.tmdb.org/t/p/w185${member.profile_path}` : 'https://via.placeholder.com/185x278'}" alt="${member.name}" class="cast-img">
                    <p class="cast-name">${member.name}</p>
                    <p class="cast-character">${member.character || ''}</p>
                `;
                castGrid.appendChild(card);
            });
        }

        // Display similar content (force the same media type for correct behavior)
        function displaySimilar(similar, mediaType) {
            similarGrid.innerHTML = '';
            (similar || []).slice(0, 5).forEach(item => {
                if (!item.poster_path) return;
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.innerHTML = `
                    <img src="https://image.tmdb.org/t/p/w300${item.poster_path}" alt="${item.title || item.name}" class="movie-poster" style="height: 225px;">
                    <div class="movie-info">
                        <h3 class="movie-title">${item.title || item.name}</h3>
                    </div>
                `;
                card.addEventListener('click', () => openDetailsModal(item, mediaType));
                similarGrid.appendChild(card);
            });
        }

        // Display seasons for TV shows
        function displaySeasons(seasons) {
            seasonSelector.innerHTML = '';
            seasons.forEach(season => {
                if (season.season_number === 0) return; // Skip specials
                const btn = document.createElement('button');
                btn.className = 'season-btn';
                btn.textContent = season.name;
                btn.dataset.seasonNumber = season.season_number;
                if (season.season_number === currentSeason) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    currentSeason = season.season_number;
                    document.querySelectorAll('.season-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    loadEpisodes(currentSeason);
                    torrentsContainer.style.display = 'block'; // Make torrents visible
                    fetchTorrents(currentSeason);
                });
                seasonSelector.appendChild(btn);
            });
        }

        // Load episodes for a season
        async function loadEpisodes(seasonNumber) {
            episodesGrid.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i></div>';
            try {
                const response = await fetch(`https://api.themoviedb.org/3/tv/${currentContent.id}/season/${seasonNumber}?api_key=${TMDB_API_KEY}`);
                const data = await response.json();
                displayEpisodes(data.episodes || []);
            } catch (error) {
                console.error(`Error fetching episodes for season ${seasonNumber}:`, error);
            }
        }

        // Display episodes
        function displayEpisodes(episodes) {
            episodesGrid.innerHTML = '';
            episodes.forEach(episode => {
                const card = document.createElement('div');
                card.className = 'episode-card';
                
                // Check if this episode is already in done watching
                const isEpisodeDone = doneWatchingCache.some(item => 
                    item.id === currentMovie.id && item.media_type === 'tv' && 
                    item.season === currentSeason && item.episode === episode.episode_number
                );
                
                card.innerHTML = `
                    <img src="${episode.still_path ? `https://image.tmdb.org/t/p/w300${episode.still_path}` : 'https://via.placeholder.com/300x169'}" alt="${episode.name}" class="episode-img">
                    <div class="episode-info">
                        <h4 class="episode-title">E${episode.episode_number}: ${episode.name}</h4>
                        <p class="episode-date">${episode.air_date || ''}</p>
                        <div class="episode-actions">
                            <button class="episode-done-btn ${isEpisodeDone ? 'is-done' : ''}" 
                                    onclick="toggleEpisodeDoneWatching(event, ${currentMovie.id}, '${currentMovie.title || currentMovie.name}', ${currentSeason}, ${episode.episode_number}, '${episode.name.replace(/'/g, "\\'")}', '${currentMovie.release_date?.substring(0, 4) || currentMovie.first_air_date?.substring(0, 4) || ''}', '${currentMovie.poster_path || ''}')"
                                    title="${isEpisodeDone ? 'Remove from Done Watching' : 'Mark Episode as Done Watching'}">
                                <i class="fas ${isEpisodeDone ? 'fa-check-circle' : 'fa-check'}"></i>
                            </button>
                        </div>
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    // Don't select if clicking on the done button
                    if (e.target.closest('.episode-done-btn')) return;
                    
                    console.log('[DEBUG] Episode card clicked! Season:', currentSeason, 'Episode:', episode.episode_number);
                    
                    document.querySelectorAll('.episode-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    
                    try {
                        showTorrents(e, currentSeason, episode.episode_number);
                    } catch (error) {
                        console.error('[DEBUG] Error in episode showTorrents:', error);
                    }
                });
                episodesGrid.appendChild(card);
            });
        }

        // Show episode details modal
        function showEpisodeDetails(event, showId, showTitle) {
            event.stopPropagation();
            
            // Find all episodes for this show
            const showEpisodes = doneWatchingCache.filter(item => 
                item.id === showId && item.media_type === 'tv' && item.season && item.episode
            );
            
            if (showEpisodes.length === 0) return;
            
            // Get show poster from the first episode
            const showPoster = showEpisodes[0].poster_path;
            
            // Sort episodes by season and episode
            showEpisodes.sort((a, b) => {
                if (a.season !== b.season) return a.season - b.season;
                return a.episode - b.episode;
            });
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content episode-modal">
                    <div class="modal-header">
                        <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${showPoster}" alt="${showTitle}" class="show-poster">
                        <div class="header-content">
                            <h2>${showTitle}</h2>
                            <p class="modal-subtitle"><i class="fas fa-tv"></i> ${showEpisodes.length} episode${showEpisodes.length > 1 ? 's' : ''} watched</p>
                        </div>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="episode-list">
                            ${showEpisodes.map(ep => `
                                <div class="episode-item">
                                    <div class="episode-number">S${ep.season}E${ep.episode}</div>
                                    <div class="episode-info">
                                        <h4>${ep.episode_title || `Episode ${ep.episode}`}</h4>
                                        <p><i class="fas fa-calendar"></i> Watched on ${new Date(ep.completed_date).toLocaleDateString()}</p>
                                    </div>
                                    <button class="episode-remove-btn" onclick="removeEpisodeFromDoneWatching(event, ${ep.id}, ${ep.season}, ${ep.episode})" title="Remove episode">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });

            // Add click highlighting within the episode list
            try {
                const list = modal.querySelector('.episode-list');
                const rows = Array.from(list.querySelectorAll('.episode-item'));
                // Default-select the first row for visual focus
                if (rows[0]) rows[0].classList.add('selected');
                rows.forEach(row => {
                    row.addEventListener('click', (ev) => {
                        // Ignore clicks on remove buttons
                        if (ev.target.closest('.episode-remove-btn')) return;
                        rows.forEach(r => r.classList.remove('selected'));
                        row.classList.add('selected');
                    });
                });
            } catch(_) {}
        }
        
        // Remove individual episode from done watching
    async function removeEpisodeFromDoneWatching(event, showId, season, episode) {
            // Update cache in memory
            const beforeLen = doneWatchingCache.length;
            doneWatchingCache = doneWatchingCache.filter(item => {
                if (item.media_type === 'tv' && item.id === showId) {
                    return !(item.season === season && item.episode === episode);
                }
                return true;
            });
            if (doneWatchingCache.length !== beforeLen) {
                await saveDoneWatching();
            }
            
            // Sync with Trakt if available
            if (traktToken) {
                try {
                    {
                        await fetch('/api/trakt/scrobble/pause', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                token: traktToken,
                                show: {
                                    ids: { tmdb: showId },
                                    title: undefined,
                                    year: undefined
                                },
                                episode: {
                                    season: season,
                                    number: episode
                                }
                            })
                        });
                    }
                } catch (error) {
                    console.warn('Failed to remove episode from Trakt:', error);
                }
            }
            
            showNotification('Episode removed from done watching', 'success');
            
            // If Done Watching page is visible, re-render; otherwise keep context
            if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                displayDoneWatching();
            }
            updateTraktPageStatus();
            updateAllDoneButtons(showId, 'tv');

            // Remove row in the modal immediately and update header count
            if (event && event.target) {
                const row = event.target.closest('.episode-item');
                const list = row?.closest('.episode-list');
                row?.remove();
                const headerCountEl = document.querySelector('.episode-modal .modal-subtitle');
                if (headerCountEl && list) {
                    const remaining = list.querySelectorAll('.episode-item').length;
                    headerCountEl.innerHTML = `<i class="fas fa-tv"></i> ${remaining} episode${remaining === 1 ? '' : 's'} watched`;
                }
            }
            
            // Close modal if no more episodes
            const remainingEpisodes = doneWatchingCache.filter(item => 
                item.id === showId && item.media_type === 'tv' && item.season && item.episode
            );
            if (remainingEpisodes.length === 0) {
                document.querySelector('.modal-overlay')?.remove();
            }
        }

        // Show torrents for the current content
        function showTorrents(event, season = null, episode = null) {
            // Safely check streaming servers setting
            const streamingMode = localStorage.getItem('useStreamingServers') === 'true';
            console.log('[SERVERS] showTorrents called with streaming mode:', streamingMode);
            console.log('[SERVERS] Season:', season, 'Episode:', episode);
            
            // Check if streaming servers mode is enabled
            if (streamingMode) {
                console.log('[SERVERS] Streaming servers enabled, showing server selection');
                showStreamingServerSelection(season, episode);
                return;
            }
            
            console.log('[SERVERS] Streaming servers disabled, showing torrents');
            // Modal removed - no longer checking or showing setup prompt
            torrentsContainer.style.display = 'block';
            // Reset loaded state for new searches
            torrentsLoaded = false;
            fetchTorrents(season, episode);
        }

        // Show streaming server selection instead of torrents
        function showStreamingServerSelection(season = null, episode = null) {
            console.log('[SERVERS] showStreamingServerSelection called with:', { season, episode });
            
            if (!currentContent) {
                console.error('[SERVERS] No currentContent available');
                showNotification('No content selected', 'error');
                return;
            }

            console.log('[SERVERS] Current content:', currentContent);
            console.log('[SERVERS] Current media type:', currentMediaType);

            const mediaData = {
                type: currentMediaType,
                id: currentContent.id,
                title: currentContent.title || currentContent.name,
                season: season,
                episode: episode,
                year: currentMediaType === 'movie' ? 
                    (currentContent.release_date || '').substring(0, 4) : 
                    (currentContent.first_air_date || '').substring(0, 4),
                rating: currentContent.vote_average ? parseFloat(currentContent.vote_average).toFixed(1) : null,
                poster: currentContent.poster_path ? 
                    `https://image.tmdb.org/t/p/w342${currentContent.poster_path}` : 
                    null,
                subtitle: season && episode ? 
                    `Season ${season}, Episode ${episode}` : 
                    (currentMediaType === 'tv' ? 'TV Show' : 'Movie'),
                fallbackToTorrent: () => {
                    // Fallback to torrent mode if user clicks "Use Torrent Instead"
                    useStreamingServers = false;
                    localStorage.setItem('useStreamingServers', 'false');
                    updateWatchButtonText();
                    showTorrents(null, season, episode);
                }
            };

            console.log('[SERVERS] Media data prepared:', mediaData);
            
            // Show server selection modal directly
            try {
                // Set current media data globally
                window.currentMediaData = mediaData;
                currentMediaData = mediaData;
                
                // Get modal elements
                const serverSelectionModal = document.getElementById('server-selection-modal');
                const serverMediaTitle = document.getElementById('server-media-title');
                const serverMediaSubtitle = document.getElementById('server-media-subtitle');
                const serverMediaYear = document.getElementById('server-media-year');
                const serverMediaRating = document.getElementById('server-media-rating');
                const serverMediaPoster = document.getElementById('server-media-poster');
                const serverDropdown = document.getElementById('server-dropdown');
                
                if (!serverSelectionModal) {
                    throw new Error('Server selection modal not found in DOM');
                }
                
                // Populate media info
                if (serverMediaTitle) serverMediaTitle.textContent = mediaData.title;
                if (serverMediaSubtitle) serverMediaSubtitle.textContent = mediaData.subtitle || '';
                if (serverMediaYear) serverMediaYear.textContent = mediaData.year || '';
                if (serverMediaRating) serverMediaRating.textContent = mediaData.rating ? ` ${mediaData.rating}` : '';
                if (serverMediaPoster) serverMediaPoster.src = mediaData.poster || '';
                
                // Initialize dropdown
                if (serverDropdown) {
                    const currentSelectedServer = localStorage.getItem('selectedServer') || 'Videasy';
                    serverDropdown.innerHTML = '';
                    
                    const servers = [
                        { name: 'CinemaOS' },
                        { name: 'Vidlink' },
                        { name: 'Videasy' },
                        { name: 'LunaStream' },
                        { name: 'Vidfast 1' },
                        { name: 'Vidfast 2' },
                        { name: '111Movies' },
                        { name: 'VidSrc 1' },
                        { name: 'VidSrc 2' },
                        { name: 'VidSrc 3' },
                        { name: 'VidSrc 4' },
                        { name: 'PrimeSrc' },
                        { name: 'VidRock' },
                        { name: 'HexaWatch' },
                        { name: 'FMovies' },
                        { name: 'Xprime' },
                        { name: 'Vidnest' },
                        { name: 'veloratv' },
                        { name: 'MovieClub' },
                        { name: 'MapleTV' },
                        { name: '2Embed' },
                        { name: 'SmashyStream' },
                        { name: 'Autoembed' },
                        { name: 'GoDrivePlayer' },
                        { name: 'VidWTF Premium' },
                        { name: 'GDrivePlayer API' },
                        { name: 'Nontongo' },
                        { name: 'SpencerDevs' },
                        { name: 'VidAPI' },
                        { name: 'Vidify' },
                        { name: 'VidSrc CX' },
                        { name: 'VidSrc ME' },
                        { name: 'VidSrc TO' },
                        { name: 'VidSrc VIP' },
                        { name: 'VixSrc' }
                    ];
                    
                    console.log('[SERVERS] Using servers array with length:', servers.length);
                    
                    servers.forEach(server => {
                        const option = document.createElement('option');
                        option.value = server.name;
                        option.textContent = server.name;
                        if (server.name === currentSelectedServer) {
                            option.selected = true;
                        }
                        serverDropdown.appendChild(option);
                    });
                    
                    console.log('[SERVERS] Dropdown populated with', serverDropdown.options.length, 'options');
                }
                
                // Show modal
                serverSelectionModal.style.display = 'flex';
                document.body.classList.add('server-modal-open');
                
                console.log('[SERVERS] Server selection modal displayed successfully');
            } catch (error) {
                console.error('[SERVERS] Error showing server selection:', error);
                alert('Error loading streaming servers: ' + error.message);
            }
        }

        // Fetch streams from Nuvio API (direct streaming links)
    async function fetchNuvioStreams(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Nuvio...</div>';

            try {
                const tmdbId = currentContent.id;
                const mediaType = currentMediaType; // 'movie' or 'tv'

                // Get IMDB ID from TMDB
                const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                const externalIdsRes = await fetch(externalIdsUrl);
                if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                
                const externalIds = await externalIdsRes.json();
                const imdbId = externalIds.imdb_id;
                
                if (!imdbId) {
                    throw new Error('No IMDB ID found for this content');
                }

                // Febbox JWT token for Nuvio (supports custom UI token)
                const defaultFebboxToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE3NTU5MzQ2NzcsIm5iZiI6MTc1NTkzNDY3NywiZXhwIjoxNzg3MDM4Njk3LCJkYXRhIjp7InVpZCI6OTY3OTA3LCJ0b2tlbiI6ImRjZTBiZTUyNzgzODU1Njg5ZjNlMjBhZTIzODU2YzlkIn19.yAuVwTgLyO7sTH5rOi_-UaVAHqO0YzUkykXgQC2ci2E';
                const savedToken = (localStorage.getItem('febboxToken') || '').trim();
                const febboxToken = savedToken || defaultFebboxToken;

                // Build new Nuviostreams URL with cookies, region, providers
                const base = 'https://nuviostreams.hayd.uk';
                const cookiesSeg = `cookies=${encodeURIComponent(JSON.stringify([febboxToken]))}`; // cookies=%5B"<JWT>"%5D
                const regionSeg = 'region=UK3';
                const providersSeg = 'providers=showbox,vidzee,vidsrc,vixsrc,mp4hydra,uhdmovies,moviesmod,4khdhub,topmovies';
                let nuvioExternalUrl;
                if (mediaType === 'movie') {
                    nuvioExternalUrl = `${base}/${cookiesSeg}/${regionSeg}/${providersSeg}/stream/movie/${encodeURIComponent(imdbId)}.json`;
                } else if (season && episode) {
                    nuvioExternalUrl = `${base}/${cookiesSeg}/${regionSeg}/${providersSeg}/stream/series/${encodeURIComponent(imdbId)}:${encodeURIComponent(season)}:${encodeURIComponent(episode)}.json`;
                } else {
                    throw new Error('Season and episode required for TV shows');
                }

                console.log('[Nuvio] Trying direct URL:', nuvioExternalUrl);

                let data = null;
                let responseOk = false;
                try {
                    const response = await fetch(nuvioExternalUrl);
                    responseOk = response.ok;
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    data = await response.json();
                } catch (directErr) {
                    console.warn('[Nuvio] Direct fetch failed, falling back to backend proxy:', directErr?.message || directErr);
                    // Fallback to existing backend proxy if available
                    let proxyUrl;
                    if (mediaType === 'movie') {
                        proxyUrl = `${API_BASE_URL}/nuvio/stream/movie/${imdbId}?cookie=ui%3D${encodeURIComponent(febboxToken)}&region=US`;
                    } else {
                        proxyUrl = `${API_BASE_URL}/nuvio/stream/series/${imdbId}:${season}:${episode}?cookie=ui%3D${encodeURIComponent(febboxToken)}&region=US`;
                    }
                    console.log('[Nuvio] Fetching via proxy:', proxyUrl);
                    const response = await fetch(proxyUrl);
                    if (!response.ok) throw new Error(`Proxy Nuvio error: ${response.statusText}`);
                    data = await response.json();
                    responseOk = true;
                }
                if (!responseOk || !data) throw new Error('Failed to load Nuvio streams');
                const streams = data.streams || [];
                
                console.log('[Nuvio] Found', streams.length, 'streams');

                if (streams.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No Nuvio streams found</div>';
                    return;
                }

                // Reorder streams: all MoviesMod first (1080p preferred), then others in original order
                const withIndex = streams.map((s, i) => ({ s, i }));
                const mmRegex = /moviesmod/i;
                const p1080 = /1080p/i;
                withIndex.sort((a, b) => {
                    const aMM = mmRegex.test(a.s?.name || '') || mmRegex.test(a.s?.title || '');
                    const bMM = mmRegex.test(b.s?.name || '') || mmRegex.test(b.s?.title || '');
                    if (aMM && !bMM) return -1;
                    if (!aMM && bMM) return 1;
                    if (aMM && bMM) {
                        const a1080 = p1080.test(a.s?.name || '') || p1080.test(a.s?.title || '');
                        const b1080 = p1080.test(b.s?.name || '') || p1080.test(b.s?.title || '');
                        if (a1080 && !b1080) return -1;
                        if (!a1080 && b1080) return 1;
                    }
                    // Preserve original order otherwise
                    return a.i - b.i;
                });
                const prioritizedStreams = withIndex.map(x => x.s);

                // Cache streams globally and add size info for sorting
                allNuvioStreams = prioritizedStreams.map(stream => {
                    const sizeMatch = (stream.title || '').match(/([\d.]+)\s*(GB|MB)/i);
                    let sizeBytes = 0;
                    if (sizeMatch) {
                        const num = parseFloat(sizeMatch[1]);
                        const unit = sizeMatch[2].toUpperCase();
                        sizeBytes = unit === 'GB' ? num * 1024 * 1024 * 1024 : num * 1024 * 1024;
                    }
                    return { ...stream, sizeBytes };
                });

                // Display Nuvio streams as direct play buttons
                displayNuvioStreams(allNuvioStreams);

            } catch (error) {
                console.error('[Nuvio] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Nuvio Error: ${error.message}</div>`;
            }
        }

        // Display Nuvio streams (direct play, not torrents)
        function displayNuvioStreams(streams) {
            const torrentsList = document.getElementById('torrentsList');
            
            if (!streams || streams.length === 0) {
                torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No streams available</div>';
                return;
            }

            // Apply size filter first
            let filteredStreams = streams.slice();
            if (typeof torrentSizeFilter === 'string' && torrentSizeFilter !== 'all') {
                console.log('[Nuvio] Applying size filter:', torrentSizeFilter);
                filteredStreams = filteredStreams.filter(stream => bytesMatchesSizeFilter(stream.sizeBytes));
                console.log('[Nuvio] After filter:', filteredStreams.length, 'of', streams.length, 'streams remain');
            }

            // Check if filter eliminated all results
            if (filteredStreams.length === 0) {
                torrentsList.innerHTML = '<p>No streams match your size filter.</p>';
                return;
            }

            // Apply sorting if sort mode is size-based
            let sortedStreams = filteredStreams.slice();
            const mode = (typeof torrentSortMode === 'string') ? torrentSortMode : 'seeders';
            
            if (mode === 'size-asc') {
                console.log('[Nuvio] Sorting by size ascending');
                sortedStreams.sort((a, b) => (a.sizeBytes || 0) - (b.sizeBytes || 0));
            } else if (mode === 'size-desc') {
                console.log('[Nuvio] Sorting by size descending');
                sortedStreams.sort((a, b) => (b.sizeBytes || 0) - (a.sizeBytes || 0));
            } else {
                console.log('[Nuvio] Using default priority order (MoviesMod first)');
            }

            torrentsList.innerHTML = '';
            
            sortedStreams.forEach((stream, index) => {
                const streamDiv = document.createElement('div');
                streamDiv.className = 'torrent-item';
                streamDiv.style.cursor = 'default';
                
                // Parse stream info
                const name = stream.name || `Stream ${index + 1}`;
                const title = stream.title || '';
                const url = stream.url;
                
                // Extract quality and size info from title
                const titleLines = title.split('\n');
                const mainTitle = titleLines[0] || '';
                const details = titleLines[1] || '';
                
                // Build button HTML - skip VLC on macOS
                const isMacOS = window.electronAPI?.platform === 'darwin';
                const vlcButtonHtml = isMacOS ? '' : `
                    <button class="torrent-btn vlc-nuvio-btn" data-url="${url}" data-name="${name}">
                        <i class="fas fa-external-link-alt"></i> Open in VLC
                    </button>
                `;
                
                streamDiv.innerHTML = `
                    <div class="torrent-info">
                        <div class="torrent-name">${name}</div>
                        ${mainTitle ? `<div style="color: var(--gray); font-size: 0.85rem; margin: 0.25rem 0;">${mainTitle}</div>` : ''}
                        ${details ? `<div class="torrent-details">
                            <span>${details}</span>
                        </div>` : ''}
                    </div>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="torrent-btn play-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-play"></i> Play Now
                        </button>
                        <button class="torrent-btn mpv-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-external-link-alt"></i> Open in MPV
                        </button>
                        ${vlcButtonHtml}
                        <button class="torrent-btn cast-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-tv"></i> Cast
                        </button>
                        <button class="torrent-btn copy-nuvio-btn" data-url="${url}" data-name="${name}">
                            <i class="fas fa-copy"></i> Copy Link
                        </button>
                    </div>
                `;
                
                torrentsList.appendChild(streamDiv);
            });

            // Add event listeners for Nuvio play buttons
            document.querySelectorAll('.play-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    try {
                        // Set current stream context
                        currentStreamUrl = url;
                        currentSelectedVideoName = name;

                        // Use Integrated MPV
                        const tmdbId = currentContent?.id?.toString() || '';
                        let seasonNum = null;
                        let episodeNum = null;
                        if (currentMediaType === 'tv' && lastSearchedSeason && lastSearchedEpisode) {
                            seasonNum = String(lastSearchedSeason);
                            episodeNum = String(lastSearchedEpisode);
                        }
                        const res = await window.electronAPI.spawnMpvjsPlayer({
                            url,
                            tmdbId,
                            seasonNum,
                            episodeNum,
                            isDebrid: useDebrid
                        });
                        
                        if (res?.success) {
                            showNotification('Player launched');
                        } else if (res?.message) {
                            alert(res.message);
                        } else {
                            showNotification('Failed to launch MPV player');
                        }
                    } catch (e) {
                        console.error('[Nuvio] Play Now error:', e);
                        showNotification('Failed to play stream', 'error');
                    }
                });
            });

            document.querySelectorAll('.mpv-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    openNuvioInMPV(url, name);
                });
            });

            document.querySelectorAll('.vlc-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    openNuvioInVLC(url, name);
                });
            });

            // Add event listeners for Nuvio cast buttons
            document.querySelectorAll('.cast-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    try {
                        // Set current stream and show device picker to cast
                        currentStreamUrl = url;
                        currentSelectedVideoName = name;
                        await showChromecastDevicePicker();
                    } catch (e) {
                        console.error('[Nuvio] Cast error:', e);
                        showNotification('Failed to initiate casting', 'error');
                    }
                });
            });

            // Add event listeners for Nuvio copy link buttons
            document.querySelectorAll('.copy-nuvio-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const url = btn.dataset.url;
                    const name = btn.dataset.name;
                    try {
                        await navigator.clipboard.writeText(url);
                        showNotification(`Stream link copied: ${name}`, 'success');
                    } catch (e) {
                        console.error('[Nuvio] Copy error:', e);
                        showNotification('Failed to copy link', 'error');
                    }
                });
            });
        }

        // Play Nuvio stream directly (Integrated MPV)
        async function playNuvioStream(url, name) {
            try {
                console.log('[Nuvio] Playing stream in MPV:', url);
                
                // Set current stream URL and name
                currentStreamUrl = url;
                currentSelectedVideoName = name;
                
                const tmdbId = currentContent?.id?.toString() || '';
                let seasonNum = null;
                let episodeNum = null;
                if (currentMediaType === 'tv' && lastSearchedSeason && lastSearchedEpisode) {
                    seasonNum = String(lastSearchedSeason);
                    episodeNum = String(lastSearchedEpisode);
                }

                const res = await window.electronAPI.spawnMpvjsPlayer({
                    url,
                    tmdbId,
                    seasonNum,
                    episodeNum,
                    isDebrid: useDebrid
                });

                if (res?.success) {
                    showNotification('Player launched');
                } else if (res?.message) {
                    alert(res.message);
                } else {
                    showNotification('Failed to launch MPV player');
                }
            } catch (error) {
                console.error('[Nuvio] Play error:', error);
                showNotification('Failed to play stream', 'error');
            }
        }

        // Open Nuvio stream in MPV
        async function openNuvioInMPV(url, name) {
            try {
                console.log('[Nuvio] Opening in MPV:', url);
                
                if (!window.electronAPI || !window.electronAPI.openInMPV) {
                    showNotification('MPV integration not available', 'error');
                    return;
                }
                
                // Set current stream for MPV
                currentStreamUrl = url;
                currentSelectedVideoName = name;
                
                // Open in external MPV
                const data = {
                    streamUrl: url,
                    infoHash: null,
                    startSeconds: undefined
                };
                
                const result = await window.electronAPI.openInMPV(data);
                if (result.success) {
                    showNotification('Opened in MPV', 'success');
                } else {
                    showNotification(`MPV Error: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('[Nuvio] MPV open error:', error);
                showNotification('Failed to open in MPV', 'error');
            }
        }
            // Open Nuvio stream in VLC
            async function openNuvioInVLC(url, name) {
                try {
                    console.log('[Nuvio] Opening in VLC:', url);
                    if (!window.electronAPI || !window.electronAPI.openInVLC) {
                        showNotification('VLC integration not available', 'error');
                        return;
                    }
                    // Set current stream context (for resume/discord)
                    currentStreamUrl = url;
                    currentSelectedVideoName = name;

                    const title = currentContent?.title || currentContent?.name || 'Video';
                    const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
                    updateDiscordForStreaming(title, 'Nuvio', seasonNum);

                    const data = {
                        streamUrl: url,
                        infoHash: (currentTorrentData && currentTorrentData.infoHash) ? currentTorrentData.infoHash : null,
                        startSeconds: (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) ? Math.floor(resumeInfo.position) : undefined
                    };
                    const result = await window.electronAPI.openInVLC(data);
                    if (result?.success) {
                        showNotification('Opened in VLC', 'success');
                    } else {
                        showNotification(`VLC Error: ${result?.message || result?.error || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    console.error('[Nuvio] VLC open error:', error);
                    showNotification('Failed to open in VLC', 'error');
                }
            }


        // Fetch torrents from Comet API
        async function fetchCometTorrents(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Comet...</div>';

            try {
                const tmdbId = currentContent.id;
                const mediaType = currentMediaType; // 'movie' or 'tv'

                // Get IMDB ID from TMDB
                const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                const externalIdsRes = await fetch(externalIdsUrl);
                if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                
                const externalIds = await externalIdsRes.json();
                const imdbId = externalIds.imdb_id;
                
                if (!imdbId) {
                    throw new Error('No IMDB ID found for this content');
                }

                // Comet config (base64 encoded configuration)
                const cometConfig = 'eyJtYXhSZXN1bHRzUGVyUmVzb2x1dGlvbiI6MCwibWF4U2l6ZSI6MCwiY2FjaGVkT25seSI6dHJ1ZSwicmVtb3ZlVHJhc2giOnRydWUsInJlc3VsdEZvcm1hdCI6WyJhbGwiXSwiZGVicmlkU2VydmljZSI6InRvcnJlbnQiLCJkZWJyaWRBcGlLZXkiOiIiLCJkZWJyaWRTdHJlYW1Qcm94eVBhc3N3b3JkIjoiIiwibGFuZ3VhZ2VzIjp7ImV4Y2x1ZGUiOltdLCJwcmVmZXJyZWQiOlsiZW4iXX0sInJlc29sdXRpb25zIjp7fSwib3B0aW9ucyI6eyJyZW1vdmVfcmFua3NfdW5kZXIiOi0xMDAwMDAwMDAwMCwiYWxsb3dfZW5nbGlzaF9pbl9sYW5ndWFnZXMiOmZhbHNlLCJyZW1vdmVfdW5rbm93bl9sYW5ndWFnZXMiOmZhbHNlfX0=';

                let cometUrl;
                if (mediaType === 'movie') {
                    cometUrl = `${API_BASE_URL}/comet/stream/movie/${imdbId}?config=${cometConfig}`;
                } else if (season && episode) {
                    cometUrl = `${API_BASE_URL}/comet/stream/series/${imdbId}:${season}:${episode}?config=${cometConfig}`;
                } else {
                    throw new Error('Season and episode required for TV shows');
                }

                console.log('[Comet] Fetching from:', cometUrl);

                const response = await fetch(cometUrl);
                if (!response.ok) throw new Error(`Comet error: ${response.statusText}`);
                
                const data = await response.json();
                const streams = data.streams || [];
                
                console.log('[Comet] Found', streams.length, 'streams');

                if (streams.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No Comet torrents found</div>';
                    return;
                }

                // Convert Comet streams to magnet links and display
                const torrents = streams.map(stream => {
                    const infoHash = stream.infoHash;
                    const sources = stream.sources || [];
                    const name = stream.name || 'Unknown';
                    const description = stream.description || '';
                    
                    // Use filename from behaviorHints if available, otherwise use name
                    const displayTitle = (stream.behaviorHints && stream.behaviorHints.filename) 
                        ? stream.behaviorHints.filename 
                        : name;
                    
                    // Construct magnet link compatible with WebTorrent
                    // Include display name and file index if available
                    const fileName = (stream.behaviorHints && stream.behaviorHints.filename) || displayTitle;
                    const fileIdx = stream.fileIdx !== undefined ? stream.fileIdx : 0;
                    
                    let magnetLink = `magnet:?xt=urn:btih:${infoHash}&dn=${encodeURIComponent(fileName)}`;
                    
                    // Add trackers (WebTorrent needs good trackers for peer discovery)
                    sources.forEach(tracker => {
                        magnetLink += `&tr=${encodeURIComponent(tracker)}`;
                    });
                    
                    // Store fileIdx for later use when playing specific file from torrent
                    if (fileIdx > 0) {
                        magnetLink += `&so=${fileIdx}`;
                    }
                    
                    // Extract size if available
                    let sizeBytes = 0;
                    if (stream.behaviorHints && stream.behaviorHints.videoSize) {
                        sizeBytes = stream.behaviorHints.videoSize;
                    }
                    
                    return {
                        title: displayTitle,
                        magnet: magnetLink,
                        seeders: 0, // Comet doesn't provide seeders
                        size: sizeBytes,
                        description: description
                    };
                }).filter(Boolean);

                console.log('[Comet] Converted', torrents.length, 'torrents');
                displayTorrents(torrents, season, episode);

            } catch (error) {
                console.error('[Comet] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Comet Error: ${error.message}</div>`;
            }
        }
async function fetchMovieBoxStreams(season = null, episode = null) {
    if (!currentContent) return;

    const torrentsList = document.getElementById('torrentsList');
    torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching MovieBox...</div>';

    try {
        const tmdbId = currentContent.id;
        const mediaType = currentMediaType; // 'movie' or 'tv'

        let apiUrl;

        if (mediaType === "movie") {
            apiUrl = `http://localhost:6987/api/astra/${encodeURIComponent(tmdbId)}`;
        } else if (season && episode) {
            apiUrl = `http://localhost:6987/api/tv/${encodeURIComponent(tmdbId)}/${encodeURIComponent(season)}/${encodeURIComponent(episode)}`;
        } else {
            throw new Error("Season and episode required for TV shows");
        }

        console.log("[MovieBox] Fetching from:", apiUrl);

        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`MovieBox API error: ${response.statusText}`);

        const data = await response.json();
        if (!data?.Astra?.playlist || !Array.isArray(data.Astra.playlist)) {
            torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No MovieBox streams found</div>';
            return;
        }

        const playlist = data.Astra.playlist;

        console.log("[MovieBox] Found", playlist.length, "streams");

        if (playlist.length === 0) {
            torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No MovieBox streams found</div>';
            return;
        }

        // Convert MovieBox stream  your renderer format
        const processedFiles = playlist.map(item => {
            const quality = item.resolution + "p"; // resolution is like "720"
            
            return {
                name: `MovieBox ${quality}`, // fake name for UI
                quality: quality,
                sizeFormatted: "Unknown Size",
                sizeBytes: 0,
                url: item.url,     // IMPORTANT: use url NOT rawUrl
                streamLink: item.url
            };
        });

        window._last111477Files = processedFiles; // keep your existing renderer happy
        render111477Files(processedFiles);

    } catch (error) {
        console.error("[MovieBox] Error:", error);
        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> MovieBox Error: ${error.message}</div>`;
    }
}

        // Fetch streams from 111477 API (direct streaming links)
    async function fetch111477Streams(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching 111477...</div>';

            try {
                const tmdbId = currentContent.id;
                const mediaType = currentMediaType; // 'movie' or 'tv'

                let apiUrl;
                if (mediaType === 'movie') {
                    apiUrl = `http://localhost:6987/111477/api/tmdb/movie/${encodeURIComponent(tmdbId)}`;
                } else if (season && episode) {
                    apiUrl = `http://localhost:6987/111477/api/tmdb/tv/${encodeURIComponent(tmdbId)}/season/${encodeURIComponent(season)}/episode/${encodeURIComponent(episode)}`;
                } else {
                    throw new Error('Season and episode required for TV shows');
                }

                console.log('[111477] Fetching from:', apiUrl);

                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`111477 API error: ${response.statusText}`);
                
                const data = await response.json();
                
                // Handle multi-result format from 111477 API
                let allFiles = [];
                if (Array.isArray(data?.results)) {
                    data.results.forEach(result => {
                        if (result.success && Array.isArray(result.files)) {
                            allFiles = allFiles.concat(result.files);
                        }
                    });
                } else if (Array.isArray(data?.files)) {
                    allFiles = data.files;
                }
                
                console.log('[111477] Found', allFiles.length, 'files');

                if (allFiles.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No 111477 streams found</div>';
                    return;
                }

                // Helper function to extract quality from filename
                function extractQuality(filename) {
                    const qualities = ['2160p', '4K', '1080p', '720p', '480p', '360p'];
                    for (const q of qualities) {
                        if (filename.includes(q)) {
                            return q;
                        }
                    }
                    // Check for other indicators
                    if (filename.match(/BluRay|Blu-Ray/i)) return 'BluRay';
                    if (filename.match(/WEBRip|WEB-DL/i)) return 'WEB';
                    if (filename.match(/HDTV/i)) return 'HDTV';
                    return 'Unknown';
                }

                // Helper function to format file size
                function formatFileSize(bytes) {
                    if (!bytes || bytes === 0) return 'Unknown Size';
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(1024));
                    return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
                }

                // Process files: extract quality, format size, parse size for sorting
                const processedFiles = allFiles.map(file => {
                    const fileName = file.name || '';
                    const quality = extractQuality(fileName);
                    const sizeBytes = parseInt(file.size) || 0;
                    const sizeFormatted = formatFileSize(sizeBytes);
                    
                    return {
                        ...file,
                        quality: quality,
                        sizeFormatted: sizeFormatted,
                        sizeBytes: sizeBytes
                    };
                });

                // Cache and render with current sort selection
                window._last111477Files = processedFiles;
                render111477Files(processedFiles);

            } catch (error) {
                console.error('[111477] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> 111477 Error: ${error.message}</div>`;
            }
        }

        // Helper: size filter matcher shared by torrent renders
        function bytesMatchesSizeFilter(bytes) {
            const n = Number(bytes) || 0;
            try {
                switch (torrentSizeFilter) {
                    case 'gte-1g': return n >= (1024 ** 3);
                    case 'gte-2g': return n >= (2 * 1024 ** 3);
                    case '2-4g':  return n >= (2 * 1024 ** 3) && n < (4 * 1024 ** 3);
                    case '4-8g':  return n >= (4 * 1024 ** 3) && n < (8 * 1024 ** 3);
                    case 'gte-8g': return n >= (8 * 1024 ** 3);
                    case 'all':
                    default: return true;
                }
            } catch(_) {
                return true;
            }
        }

        // Render helper for 111477 files honoring global sort and size filter
        function render111477Files(files) {
            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '';
            let list = (files || []).slice();
            try {
                // Use the same torrentSortMode variable defined near the selector
                const mode = (typeof torrentSortMode === 'string') ? torrentSortMode : 'seeders';
                // Apply size filter first
                list = list.filter(f => bytesMatchesSizeFilter(f.sizeBytes));
                if (mode === 'size-desc') list.sort((a,b) => (Number(b.sizeBytes||0) - Number(a.sizeBytes||0)));
                else /* size-asc or default */ list.sort((a,b) => (Number(a.sizeBytes||0) - Number(b.sizeBytes||0)));
            } catch(_) {}

            list.forEach(file => {
                const item = document.createElement('div');
                item.className = 'torrent-item';
                item.style.display = 'flex';
                item.style.justifyContent = 'space-between';
                item.style.alignItems = 'center';
                item.style.padding = '1rem';
                item.style.marginBottom = '0.5rem';
                item.style.background = 'rgba(255,255,255,0.05)';
                item.style.borderRadius = '8px';
                item.style.cursor = 'pointer';

                const info = document.createElement('div');
                info.style.flex = '1';

                const title = document.createElement('div');
                title.style.fontWeight = '500';
                title.style.marginBottom = '0.25rem';
                title.textContent = file.name || 'Unknown';

                const meta = document.createElement('div');
                meta.style.fontSize = '0.85rem';
                meta.style.opacity = '0.7';
                meta.textContent = `${file.quality}  ${file.sizeFormatted}`;

                info.appendChild(title);
                info.appendChild(meta);

                // New: Play Now button (Integrated MPV)
                const playNowBtn = document.createElement('button');
                playNowBtn.className = 'btn';
                playNowBtn.innerHTML = '<i class="fas fa-play"></i> Play Now';
                playNowBtn.style.marginLeft = '1rem';
                playNowBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!file.url) {
                        showNotification('No stream URL available');
                        return;
                    }
                    try {
                        const tmdbId = currentContent?.id?.toString() || '';
                        let seasonNum = null;
                        let episodeNum = null;
                        if (currentMediaType === 'tv' && lastSearchedSeason && lastSearchedEpisode) {
                            seasonNum = String(lastSearchedSeason);
                            episodeNum = String(lastSearchedEpisode);
                        }

                        // Use Integrated MPV
                        const res = await window.electronAPI.spawnMpvjsPlayer({
                            url: file.url,
                            tmdbId,
                            seasonNum,
                            episodeNum,
                            isDebrid: useDebrid
                        });

                        if (res?.success) {
                            showNotification('Player launched');
                        } else if (res?.message) {
                            alert(res.message);
                        } else {
                            showNotification('Failed to launch MPV player');
                        }
                    } catch (err) {
                        console.error('[111477] Play Now error:', err);
                        showNotification('Failed to play: ' + (err?.message || 'Unknown error'));
                    }
                };

                const playBtn = document.createElement('button');
                playBtn.className = 'btn';
                playBtn.innerHTML = '<i class="fas fa-play"></i> Open in MPV';
                playBtn.style.marginLeft = '1rem';
                playBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (file.url) {
                        console.log('[111477] Opening in MPV:', file.url);
                        try {
                            // Update Discord presence for 111477 MPV streaming
                            const title = currentContent?.title || currentContent?.name || 'Video';
                            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
                            updateDiscordForStreaming(title, '111477', seasonNum);
                            
                            const result = await window.electronAPI.openMPVDirect(file.url);
                            if (result && result.success) {
                                showNotification('Opening stream in MPV... Please Wait', 'success', 5000);
                            } else {
                                showNotification(result?.message || 'Failed to open in MPV', 'error', 7000);
                            }
                        } catch (error) {
                            console.error('[111477] MPV error:', error);
                            showNotification('Failed to open in MPV: ' + error.message);
                        }
                    } else {
                        showNotification('No stream URL available');
                    }
                };

                item.appendChild(info);
                item.appendChild(playNowBtn);
                item.appendChild(playBtn);
                
                // Add IINA button on macOS
                if (window.electronAPI.platform === 'darwin') {
                    const iinaBtn = document.createElement('button');
                    iinaBtn.className = 'btn';
                    iinaBtn.innerHTML = '<i class="fas fa-film"></i> Open in IINA';
                    iinaBtn.style.marginLeft = '0.5rem';
                    iinaBtn.onclick = async (e) => {
                        e.stopPropagation();
                        if (file.url) {
                            console.log('[IINA] Opening in IINA:', file.url);
                            try {
                                // Update Discord presence for IINA streaming
                                const title = currentContent?.title || currentContent?.name || 'Video';
                                const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
                                updateDiscordForStreaming(title, 'IINA', seasonNum);
                                
                                const result = await window.electronAPI.openInIINA({ 
                                    streamUrl: file.url,
                                    infoHash: currentInfoHash || null,
                                    startSeconds: 0
                                });
                                if (result && result.success) {
                                    showNotification('Opening stream in IINA...', 'success', 3000);
                                } else if (result && result.message && result.message.includes('not installed')) {
                                    showNotification('IINA not installed. Please install IINA from iina.io', 'error', 5000);
                                } else {
                                    showNotification('Failed to open in IINA: ' + (result?.message || 'Unknown error'));
                                }
                            } catch (error) {
                                console.error('[IINA] Error:', error);
                                showNotification('Failed to open in IINA: ' + error.message);
                            }
                        } else {
                            showNotification('No stream URL available');
                        }
                    };
                    item.appendChild(iinaBtn);
                }
                
                torrentsList.appendChild(item);
            });
        }



        // Map resolution to approximate HLS bitrate (bits/sec)
        function mapResolutionToBitrate(res) {
            const n = parseInt(String(res).replace(/[^0-9]/g, ''), 10) || 0;
            if (n >= 1080) return 5000000;
            if (n >= 720) return 2500000;
            if (n >= 480) return 1200000;
            if (n >= 360) return 600000;
            return 0; // mpv will pick automatically
        }

        // Render MovieBox groups with resolution buttons
        function displayMovieBoxGroups(groups) {
            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '';

            const groupNames = Object.keys(groups);
            if (groupNames.length === 0) {
                torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No streams available</div>';
                return;
            }

            groupNames.forEach((src) => {
                const items = groups[src] || [];

                const sample = items[0]; // for display info only

                const div = document.createElement('div');
                div.className = 'torrent-item';
                div.style.cursor = 'default';
                div.innerHTML = `
                    <div class="torrent-info">
                        <div class="torrent-name">MovieBox - ${src}</div>
                        <div class="torrent-details"><span>${sample ? (sample.format || '') : ''}${sample && sample.codecName ? '  ' + sample.codecName : ''}</span></div>
                    </div>
                    <div class="torrent-actions" data-src="${encodeURIComponent(src)}"></div>
                `;
                torrentsList.appendChild(div);

                const actions = div.querySelector('.torrent-actions');

                // Create a button for EVERY stream the API returned for this source
                items.forEach((stream) => {
                    const resStr = (stream.resolutions || '').toString().trim();
                    const label = resStr ? `${resStr}${/p$/.test(resStr) ? '' : 'p'}` : (stream.format || 'Open');
                    const btn = document.createElement('button');
                    btn.className = 'torrent-btn';
                    btn.textContent = label;
                    btn.title = `${stream.format || ''}${stream.codecName ? '  ' + stream.codecName : ''}${stream.size ? '  ' + stream.size : ''}`.trim();
                    btn.addEventListener('click', () => openMovieBoxInMPV(stream, resStr || null));
                    actions.appendChild(btn);
                });
            });
        }

        async function openMovieBoxInMPV(stream, resolution = null) {
            try {
                if (!window.electronAPI || !window.electronAPI.openMpvWithHeaders) {
                    showNotification('MPV (advanced) integration not available', 'error');
                    return;
                }

                const url = stream.url;
                const headers = stream.headers || {};
                const ua = headers.userAgent || 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36';
                const ref = headers.referer || 'https://fmoviesunblocked.net/';
                const cookie = headers.cookie || '';

                const bitrate = resolution ? mapResolutionToBitrate(resolution) : 0;

                const result = await window.electronAPI.openMpvWithHeaders({
                    url,
                    userAgent: ua,
                    referer: ref,
                    cookie,
                    hlsBitrate: bitrate || undefined,
                    isDebrid: useDebrid
                });

                if (result?.success) {
                    showNotification('Opened in MPV', 'success');
                } else {
                    showNotification(`MPV Error: ${result?.message || 'Unknown error'}`, 'error');
                }
            } catch (e) {
                console.error('[MovieBox] MPV open error:', e);
                showNotification('Failed to open in MPV', 'error');
            }
        }

        // Fetch streams from XDmovies
        async function fetchXDMoviesStreams(season = null, episode = null) {
            if (!currentContent) return;

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching XDmovies...</div>';

            try {
                // XDmovies only supports movies
                if (currentMediaType === 'tv') {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> XDmovies is for movies only, not TV shows.</div>';
                    return;
                }

                const tmdbId = currentContent.id;
                const apiUrl = `http://localhost:6987/api/xdmovies/${encodeURIComponent(tmdbId)}`;

                console.log('[XDmovies] Fetching from:', apiUrl);

                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`XDmovies API error: ${response.statusText}`);
                
                const data = await response.json();
                
                if (!data.success || !data.downloads) {
                    torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-info-circle"></i> ${data.message || 'No XDmovies streams found'}</div>`;
                    return;
                }

                const downloads = data.downloads || [];
                console.log('[XDmovies] Found', downloads.length, 'download options');

                if (downloads.length === 0) {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> No XDmovies streams found</div>';
                    return;
                }

                // Helper function to format file size
                function formatFileSize(sizeStr) {
                    if (!sizeStr) return 'Unknown Size';
                    return sizeStr;
                }

                // Display downloads with server links
                torrentsList.innerHTML = '';
                downloads.forEach((download, idx) => {
                    const div = document.createElement('div');
                    div.className = 'torrent-item';
                    div.style.display = 'flex';
                    div.style.flexDirection = 'column';
                    div.style.padding = '1rem';
                    div.style.marginBottom = '0.5rem';
                    div.style.background = 'rgba(255,255,255,0.05)';
                    div.style.borderRadius = '8px';

                    // Title
                    const title = document.createElement('div');
                    title.style.fontWeight = '500';
                    title.style.marginBottom = '0.5rem';
                    title.textContent = download.title || `Download ${idx + 1}`;

                    // Size info
                    const sizeInfo = document.createElement('div');
                    sizeInfo.style.fontSize = '0.85rem';
                    sizeInfo.style.opacity = '0.7';
                    sizeInfo.style.marginBottom = '0.5rem';
                    sizeInfo.textContent = formatFileSize(download.size);

                    // Server buttons container
                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.style.display = 'flex';
                    buttonsDiv.style.flexWrap = 'wrap';
                    buttonsDiv.style.gap = '0.5rem';

                    const serverLinks = download.serverLinks || [];
                    if (serverLinks.length === 0) {
                        const noServerMsg = document.createElement('div');
                        noServerMsg.style.fontSize = '0.9rem';
                        noServerMsg.style.opacity = '0.6';
                        noServerMsg.textContent = 'No playable links available';
                        buttonsDiv.appendChild(noServerMsg);
                    } else {
                        serverLinks.forEach(server => {
                            const btn = document.createElement('button');
                            btn.className = 'btn';
                            btn.style.padding = '0.5rem 1rem';
                            btn.style.fontSize = '0.9rem';
                            btn.innerHTML = `<i class="fas fa-play"></i> ${server.name}`;
                            btn.onclick = async (e) => {
                                e.stopPropagation();
                                if (!server.url) {
                                    showNotification('No URL available for this server');
                                    return;
                                }
                                try {
                                    console.log('[XDmovies] Opening in player:', server.name, server.url);
                                    const movieTitle = currentContent?.title || currentContent?.name || 'Movie';
                                    
                                    // Update Discord presence for XDmovies streaming
                                    updateDiscordForStreaming(movieTitle, 'XDmovies', null);
                                    
                                    // Use Integrated MPV
                                    const tmdbId = currentContent?.id?.toString() || '';
                                    const res = await window.electronAPI.spawnMpvjsPlayer({
                                        url: server.url,
                                        tmdbId,
                                        seasonNum: null,
                                        episodeNum: null,
                                        isDebrid: useDebrid
                                    });

                                    if (res?.success) {
                                        showNotification('Player launched');
                                    } else if (res?.message) {
                                        alert(res.message);
                                    } else {
                                        showNotification('Failed to launch MPV player');
                                    }
                                } catch (error) {
                                    console.error('[XDmovies] Player error:', error);
                                    showNotification('Failed to open player: ' + error.message, 'error');
                                }
                            };
                            buttonsDiv.appendChild(btn);
                        });
                    }

                    div.appendChild(title);
                    div.appendChild(sizeInfo);
                    div.appendChild(buttonsDiv);
                    torrentsList.appendChild(div);
                });
            } catch (error) {
                console.error('[XDmovies] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> XDmovies Error: ${error.message}</div>`;
            }
        }

        // Fetch streams from AIOStreams
        async function fetchAiostreamsStreams(season = null, episode = null) {
            if (!currentContent) return;

            const platform = window.electronAPI.platform;
            const isWindows = platform === 'win32';
            const isMac = platform === 'darwin';
            const isLinux = platform === 'linux';

            const torrentsList = document.getElementById('torrentsList');
            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching AIOStreams...</div>';

            try {
                const tmdbId = currentContent.id;
                let apiUrl = '';

                if (currentMediaType === 'movie') {
                    apiUrl = `http://localhost:6987/aio/movie/${encodeURIComponent(tmdbId)}`;
                } else if (currentMediaType === 'tv') {
                    apiUrl = `http://localhost:6987/aio/series/${encodeURIComponent(tmdbId)}/${encodeURIComponent(season)}/${encodeURIComponent(episode)}`;
                } else {
                    torrentsList.innerHTML = '<div class="error-message"><i class="fas fa-info-circle"></i> AIOStreams only supports movies and TV shows.</div>';
                    return;
                }

                console.log('[AIOStreams] Fetching from:', apiUrl);

                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`Please configure AIOStreams in the settings`);
                
                const data = await response.json();
                
                if (!data.streams || !data.streams.streams || data.streams.streams.length === 0) {
                    torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-info-circle"></i> No AIOStreams streams found</div>`;
                    return;
                }

                const streams = data.streams.streams;
                
                                console.log('[AIOStreams] Found', streams.length, 'streams');
                
                                torrentsList.innerHTML = '';
                                streams.forEach(stream => {
                                    const item = document.createElement('div');
                                    item.className = 'torrent-item';
                                    item.style.display = 'flex';
                                    item.style.justifyContent = 'space-between';
                                    item.style.alignItems = 'center';
                                    item.style.padding = '1rem';
                                    item.style.marginBottom = '0.5rem';
                                    item.style.background = 'rgba(255,255,255,0.05)';
                                    item.style.borderRadius = '8px';
                
                                    const infoDiv = document.createElement('div');
                                    infoDiv.style.flex = '1';
                                    infoDiv.style.minWidth = '0';
                
                                    const name = document.createElement('div');
                                    name.style.fontWeight = '500';
                                    name.style.marginBottom = '0.25rem';
                                    name.textContent = stream.name;
                
                                    const description = document.createElement('div');
                                    description.style.fontSize = '0.85rem';
                                    description.style.opacity = '0.7';
                                    description.innerHTML = stream.description.replace(/\\n/g, '<br>');
                                    
                                    infoDiv.appendChild(name);
                                    infoDiv.appendChild(description);
                
                                    const buttonsDiv = document.createElement('div');
                                    buttonsDiv.style.display = 'flex';
                                    buttonsDiv.style.flexDirection = 'row';
                                    buttonsDiv.style.alignItems = 'center';
                                    buttonsDiv.style.gap = '0.5rem';
                                    buttonsDiv.style.marginLeft = '1rem';
                                    buttonsDiv.style.flexShrink = '0';
                
                                    if (stream.infoHash) {
                                        // P2P Stream
                                        const fileName = (stream.behaviorHints && stream.behaviorHints.filename) ? stream.behaviorHints.filename : stream.name;
                                        let magnetLink = `magnet:?xt=urn:btih:${stream.infoHash}&dn=${encodeURIComponent(fileName)}`;
                                        if(stream.sources) {
                                            stream.sources.forEach(tracker => {
                                                magnetLink += `&tr=${encodeURIComponent(tracker)}`;
                                            });
                                        }
                
                                        const playBtn = document.createElement('button');
                                        playBtn.className = 'btn';
                                        playBtn.innerHTML = '<i class="fas fa-play"></i> Play';
                                        playBtn.style.backgroundColor = '#28a745';
                                        playBtn.style.borderColor = '#28a745';
                                        playBtn.onclick = () => startStream(magnetLink);
                
                                        const copyBtn = document.createElement('button');
                                        copyBtn.className = 'btn';
                                        copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
                                        copyBtn.onclick = () => copyMagnet(magnetLink);
                
                                        buttonsDiv.appendChild(playBtn);
                                        buttonsDiv.appendChild(copyBtn);
                                    } else {
                                        // Direct Stream
                                        const playBtn = document.createElement('button');
                                        playBtn.className = 'btn';
                                        playBtn.innerHTML = '<i class="fas fa-play"></i> Play';
                                        playBtn.style.backgroundColor = '#28a745';
                                        playBtn.style.borderColor = '#28a745';
                                        playBtn.onclick = async (e) => {
                                            e.stopPropagation();
                                            try {
                                                const tmdbId = currentContent?.id?.toString() || '';
                                                let seasonNum = null;
                                                let episodeNum = null;
                                                if (currentMediaType === 'tv' && season && episode) {
                                                    seasonNum = String(season);
                                                    episodeNum = String(episode);
                                                }
                                                
                                                const res = await window.electronAPI.spawnMpvjsPlayer({
                                                    url: stream.url,
                                                    tmdbId,
                                                    seasonNum,
                                                    episodeNum,
                                                    isDebrid: useDebrid
                                                });
                
                                                if (res?.success) {
                                                    showNotification('Player launched');
                                                } else if (res?.message) {
                                                    alert(res.message);
                                                } else {
                                                    showNotification('Failed to launch player', 'error');
                                                }
                                            } catch (err) {
                                                showNotification(`Player error: ${err.message}`, 'error');
                                            }
                                        };
                
                                        const copyBtn = document.createElement('button');
                                        copyBtn.className = 'btn';
                                        copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy Link';
                                        copyBtn.onclick = (e) => {
                                            e.stopPropagation();
                                            navigator.clipboard.writeText(stream.url).then(() => {
                                                showNotification('Link copied to clipboard');
                                            }, () => {
                                                showNotification('Failed to copy link', 'error');
                                            });
                                        };
                
                                        const openInBtn = document.createElement('button');
                                        openInBtn.className = 'btn';
                                        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                                        openInBtn.innerHTML = isMac ? '<i class="fas fa-external-link-alt"></i> Open in IINA' : '<i class="fas fa-external-link-alt"></i> Open in MPV';
                                        openInBtn.onclick = async (e) => {
                                            e.stopPropagation();
                                            try {
                                                const apiMethod = isMac ? 'openInIINA' : 'openInMPV';
                                                await window.electronAPI[apiMethod]({
                                                    streamUrl: stream.url,
                                                    title: stream.name
                                                });
                                            } catch (err) {
                                                showNotification(`Failed to open: ${err.message}`, 'error');
                                            }
                                        };
                                        
                                        buttonsDiv.appendChild(playBtn);
                                        buttonsDiv.appendChild(copyBtn);
                                        
                                        if (isWindows || isMac || isLinux) {
                                            buttonsDiv.appendChild(openInBtn);
                                        }
                                    }
                
                                    item.appendChild(infoDiv);
                                    item.appendChild(buttonsDiv);
                                    torrentsList.appendChild(item);
                                });
                

            } catch (error) {
                console.error('[AIOStreams] Error:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> AIOStreams Error: ${error.message}</div>`;
            }
        }
        
        // Fetch torrents from the backend
        async function fetchTorrents(season = null, episode = null) {
            if (!currentContent) {
                try { showNotification('Select a movie/show first'); } catch(_) {}
                return;
            }

            // Track last searched parameters for provider switching
            lastSearchedSeason = season;
            lastSearchedEpisode = episode;

            // Check selected provider first
            if (selectedProvider === 'nuvio') {
                console.log('[Provider] Routing to Nuvio');
                return fetchNuvioStreams(season, episode);
            } else if (selectedProvider === 'comet') {
                console.log('[Provider] Routing to Comet');
                return fetchCometTorrents(season, episode);
            }
             else if (selectedProvider === '111477') {
                console.log('[Provider] Routing to 111477');
                return fetch111477Streams(season, episode);
            } else if (selectedProvider === 'moviebox') {
                console.log('[Provider] Routing to MovieBox');
                return fetchMovieBoxStreams(season, episode);
            } else if (selectedProvider === 'xdmovies') {
                console.log('[Provider] Routing to XDmovies');
                return fetchXDMoviesStreams(season, episode);
            } else if (selectedProvider === 'aiostreams') {
                console.log('[Provider] Routing to AIOStreams');
                return fetchAiostreamsStreams(season, episode);
            } else if (selectedProvider === 'torrentio' || selectedProvider === 'torrentless' || selectedProvider === 'jackett') {
                // Explicit provider override buttons
                console.log('[Provider] Explicit override:', selectedProvider);
                // Bypass settings and force the desired path
                if (selectedProvider === 'jackett') {
                    // Go straight to Jackett mode below
                } else if (selectedProvider === 'torrentio') {
                    // Force torrentio branch
                    try {
                        const tmdbId = currentContent.id;
                        const mediaType = currentMediaType;
                        const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                        const externalIdsRes = await fetch(externalIdsUrl);
                        if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                        const externalIds = await externalIdsRes.json();
                        const imdbId = externalIds.imdb_id;
                        if (!imdbId) throw new Error('No IMDB ID found for this content');
                        let torrentioUrl;
                        if (mediaType === 'movie') {
                            torrentioUrl = `http://localhost:6987/torrentio/api/${imdbId}`;
                        } else if (season && episode) {
                            torrentioUrl = `http://localhost:6987/torrentio/api/${imdbId}/${season}/${episode}`;
                        } else {
                            throw new Error('Season and episode required for TV shows');
                        }
                        torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Torrentio...</div>';
                        const response = await fetch(torrentioUrl);
                        if (!response.ok) throw new Error(`Torrentio error: ${response.statusText}`);
                        const data = await response.json();
                        const streams = data.streams || [];
                        const torrents = streams.map(stream => {
                            const magnetLink = stream.magnetLink || (stream.infoHash ? `magnet:?xt=urn:btih:${stream.infoHash}` : null);
                            if (!magnetLink) return null;
                            const titleMatch = (stream.title || '').match(/\s*(\d+)/);
                            const sizeMatch = (stream.title || '').match(/\s*([\d.]+\s*[KMGT]B)/i);
                            const seeders = titleMatch ? parseInt(titleMatch[1]) : 0;
                            const sizeStr = sizeMatch ? sizeMatch[1] : '0 B';
                            const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                            let sizeBytes = 0;
                            if (sizeParts) {
                                const num = parseFloat(sizeParts[1]);
                                const unit = sizeParts[2].toUpperCase();
                                const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                sizeBytes = Math.round(num * (multipliers[unit] || 1));
                            }
                            return { title: (stream.title || stream.name || '').split('\n')[0], magnet: magnetLink, seeders, size: sizeBytes };
                        }).filter(Boolean);
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentio] Error:', error);
                        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Torrentio Error: ${error.message}</div>`;
                        return;
                    }
                } else if (selectedProvider === 'torrentless') {
                    // Force in-app scraper branch
                    try {
                        let query = currentContent.title || currentContent.name;
                        if (currentMediaType === 'movie') {
                            const year = (currentContent.release_date || '').substring(0, 4);
                            if (year) query = `${query} ${year}`;
                        } else if (currentMediaType === 'tv') {
                            if (season && episode) {
                                const seasonStr = String(season).padStart(2, '0');
                                const episodeStr = String(episode).padStart(2, '0');
                                query = `${query} S${seasonStr}E${episodeStr}`;
                            } else if (season) {
                                const seasonStr = String(season).padStart(2, '0');
                                query = `${query} S${seasonStr}`;
                            }
                        }
                        const torrentlessUrl = `http://localhost:6987/torrentless/api/search?q=${encodeURIComponent(query)}&page=1`;
                        torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching Torrentless...</div>';
                        const response = await fetch(torrentlessUrl);
                        if (!response.ok) throw new Error(`In-App Scraper error: ${response.statusText}`);
                        const data = await response.json();
                        // New format: { query, page, items: [{ name, magnet, size, seeds, leech }] }
                        const items = data.items || [];
                        const torrents = items.map(item => {
                            // Parse seeds string (e.g., "12,860" -> 12860)
                            const seeders = parseInt((item.seeds || '0').replace(/,/g, ''), 10) || 0;
                            
                            // Parse size string to bytes
                            let sizeBytes = 0;
                            if (item.size) {
                                const sizeStr = item.size;
                                const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                                if (sizeParts) {
                                    const num = parseFloat(sizeParts[1]);
                                    const unit = sizeParts[2].toUpperCase();
                                    const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                    sizeBytes = Math.round(num * (multipliers[unit] || 1));
                                }
                            }
                            
                            return { 
                                title: item.name,        // New format uses 'name' not 'title'
                                magnet: item.magnet, 
                                seeders: seeders, 
                                size: sizeBytes
                            };
                        });
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentless] Error:', error);
                        torrentsList.innerHTML = `<div class=\"error-message\"><i class=\"fas fa-exclamation-triangle\"></i> In-App Scraper Error: ${error.message}</div>`;
                        return;
                    }
                }
            }

            // Playtorrio (default) - use existing torrent search logic
            console.log('[Provider] Using Playtorrio (default torrent search)');

            // Check if Watch without Jackett is enabled and which source to use
            let torrentSource = 'torrentio'; // default
            let useTorrentless = false;
            try {
                const res = await fetch(`${API_BASE_URL}/settings`);
                if (res.ok) {
                    const settings = await res.json();
                    useTorrentless = !!settings.useTorrentless;
                    torrentSource = settings.torrentSource || 'torrentio';
                    console.log('=================================');
                    console.log('[Torrents] Settings loaded:');
                    console.log('  useTorrentless:', useTorrentless);
                    console.log('  torrentSource:', torrentSource);
                    console.log('  Mode Decision:');
                    if (!useTorrentless) {
                        console.log('   Will use JACKETT (useTorrentless is false)');
                    } else if (torrentSource === 'torrentio') {
                        console.log('   Will use TORRENTIO (useTorrentless=true, source=torrentio)');
                    } else if (torrentSource === 'in-app-scraper') {
                        console.log('   Will use IN-APP SCRAPER (useTorrentless=true, source=in-app-scraper)');
                    }
                    console.log('=================================');
                }
            } catch (e) {
                console.error('[Torrents] Failed to load settings:', e);
            }

            torrentsList.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Searching...</div>';
            torrentsLoaded = true;

            // If Watch without Jackett is enabled
            if (useTorrentless) {
                // TORRENTIO MODE: Use IMDB ID
                if (torrentSource === 'torrentio') {
                    console.log('[Torrentio] Using Torrentio API');
                    try {
                        // Get IMDB ID from TMDB
                        const tmdbId = currentContent.id;
                        const mediaType = currentMediaType; // 'movie' or 'tv'
                        
                        console.log('[Torrentio] Fetching IMDB ID for:', { tmdbId, mediaType });
                        
                        // Fetch external IDs from TMDB
                        const externalIdsUrl = `https://api.themoviedb.org/3/${mediaType}/${tmdbId}/external_ids?api_key=${TMDB_API_KEY}`;
                        console.log('[Torrentio] External IDs URL:', externalIdsUrl);
                        
                        const externalIdsRes = await fetch(externalIdsUrl);
                        if (!externalIdsRes.ok) throw new Error('Failed to get IMDB ID from TMDB');
                        
                        const externalIds = await externalIdsRes.json();
                        const imdbId = externalIds.imdb_id;
                        
                        console.log('[Torrentio] Got IMDB ID:', imdbId);
                        
                        if (!imdbId) {
                            throw new Error('No IMDB ID found for this content');
                        }

                        let torrentioUrl;
                        if (mediaType === 'movie') {
                            // Movies: http://localhost:6987/torrentio/api/tt5950044
                            torrentioUrl = `http://localhost:6987/torrentio/api/${imdbId}`;
                            console.log('[Torrentio] Movie URL:', torrentioUrl);
                        } else if (season && episode) {
                            // TV Shows: http://localhost:6987/torrentio/api/tt13159924/2/1
                            torrentioUrl = `http://localhost:6987/torrentio/api/${imdbId}/${season}/${episode}`;
                            console.log('[Torrentio] TV Show URL:', torrentioUrl);
                        } else {
                            throw new Error('Season and episode required for TV shows');
                        }

                        console.log('[Torrentio] Fetching from:', torrentioUrl);

                        const response = await fetch(torrentioUrl);
                        if (!response.ok) throw new Error(`Torrentio error: ${response.statusText}`);
                        
                        const data = await response.json();
                        console.log('[Torrentio] Received data:', data);
                        
                        const streams = data.streams || [];
                        console.log('[Torrentio] Found', streams.length, 'streams');
                        
                        // Convert Torrentio format to our torrent format
                        const torrents = streams.map(stream => {
                            // Extract magnet link (Torrentio might return magnetLink or construct it from infoHash)
                            const magnetLink = stream.magnetLink || 
                                (stream.infoHash ? `magnet:?xt=urn:btih:${stream.infoHash}` : null);
                            
                            if (!magnetLink) return null;
                            
                            // Extract seeders and size from title
                            const titleMatch = stream.title.match(/\s*(\d+)/);
                            const sizeMatch = stream.title.match(/\s*([\d.]+\s*[KMGT]B)/i);
                            const seeders = titleMatch ? parseInt(titleMatch[1]) : 0;
                            const sizeStr = sizeMatch ? sizeMatch[1] : '0 B';
                            
                            // Convert size string to bytes
                            const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                            let sizeBytes = 0;
                            if (sizeParts) {
                                const num = parseFloat(sizeParts[1]);
                                const unit = sizeParts[2].toUpperCase();
                                const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                sizeBytes = Math.round(num * (multipliers[unit] || 1));
                            }
                            
                            return {
                                title: stream.title.split('\n')[0] || stream.name, // First line of title
                                magnet: magnetLink,
                                seeders: seeders,
                                size: sizeBytes
                            };
                        }).filter(Boolean);
                        
                        console.log('[Torrentio] Converted', torrents.length, 'torrents');
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentio] Error:', error);
                        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> Torrentio Error: ${error.message}</div>`;
                        return;
                    }
                } 
                // IN-APP SCRAPER MODE: Use search query (same format as Jackett)
                else if (torrentSource === 'in-app-scraper') {
                    console.log('[Torrentless] Using In-App Scraper API');
                    try {
                        // Build search query - SAME FORMAT AS JACKETT
                        let query = currentContent.title || currentContent.name;
                        
                        if (currentMediaType === 'movie') {
                            const year = (currentContent.release_date || '').substring(0, 4);
                            if (year) {
                                query = `${query} ${year}`;
                            }
                        } else if (currentMediaType === 'tv') {
                            if (season && episode) {
                                const seasonStr = String(season).padStart(2, '0');
                                const episodeStr = String(episode).padStart(2, '0');
                                query = `${query} S${seasonStr}E${episodeStr}`;
                            } else if (season) {
                                const seasonStr = String(season).padStart(2, '0');
                                query = `${query} S${seasonStr}`;
                            }
                        }
                        
                        // Use Torrentless API: http://localhost:6987/torrentless/api/search?q=Superman&page=1
                        const torrentlessUrl = `http://localhost:6987/torrentless/api/search?q=${encodeURIComponent(query)}&page=1`;
                        console.log('[Torrentless] Query:', query);
                        console.log('[Torrentless] Fetching from:', torrentlessUrl);
                        
                        const response = await fetch(torrentlessUrl);
                        if (!response.ok) throw new Error(`In-App Scraper error: ${response.statusText}`);
                        
                        const data = await response.json();
                        console.log('[Torrentless] Raw response:', data);
                        
                        // Torrentless returns { query, page, items: [{ name, magnet, size, seeds, leech }] }
                        const items = data.items || [];
                        console.log('[Torrentless] Found', items.length, 'items');
                        
                        // Convert Torrentless format to our torrent format
                        const torrents = items.map(item => {
                            // Parse seeds string (e.g., "12,860" -> 12860)
                            const seeders = parseInt((item.seeds || '0').replace(/,/g, ''), 10) || 0;
                            
                            // Parse size string to bytes (e.g., "2.39 GB" -> bytes)
                            let sizeBytes = 0;
                            if (item.size) {
                                const sizeStr = item.size;
                                const sizeParts = sizeStr.match(/([\d.]+)\s*([KMGT]?B)/i);
                                if (sizeParts) {
                                    const num = parseFloat(sizeParts[1]);
                                    const unit = sizeParts[2].toUpperCase();
                                    const multipliers = { 'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4 };
                                    sizeBytes = Math.round(num * (multipliers[unit] || 1));
                                }
                            }
                            
                            return {
                                title: item.name,           // New format uses 'name' not 'title'
                                magnet: item.magnet,
                                seeders: seeders,
                                size: sizeBytes
                            };
                        });
                        
                        console.log('[Torrentless] Converted', torrents.length, 'torrents');
                        displayTorrents(torrents, season, episode);
                        return;
                    } catch (error) {
                        console.error('[Torrentless] Error:', error);
                        torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> In-App Scraper Error: ${error.message}</div>`;
                        return;
                    }
                }
            }

            // JACKETT MODE (default when useTorrentless is false)
            console.log('[Torrents] Using Jackett mode');
            let query = currentContent.title || currentContent.name;
            if (currentMediaType === 'movie') {
                const year = (currentContent.release_date || '').substring(0, 4);
                if (year) {
                    query = `${query} ${year}`;
                }
            } else if (currentMediaType === 'tv') {
                if (season && episode) {
                    const seasonStr = String(season).padStart(2, '0');
                    const episodeStr = String(episode).padStart(2, '0');
                    query = `${query} S${seasonStr}.E${episodeStr}`;
                } else if (season) {
                    const seasonStr = String(season).padStart(2, '0');
                    query = `${query} S${seasonStr}`;
                }
            }

            try {
                const showTitle = currentContent.title || currentContent.name;
                const response = await fetch(`${API_BASE_URL}/torrents?q=${encodeURIComponent(query)}&title=${encodeURIComponent(showTitle)}&season=${season||''}&episode=${episode||''}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                const torrents = await response.json();
                displayTorrents(torrents, season, episode);
            } catch (error) {
                console.error('[Jackett] Error fetching torrents:', error);
                torrentsList.innerHTML = `<div class="error-message"><i class="fas fa-exclamation-triangle"></i> ${error.message}</div>`;
            }
        }

        // Helper function to check if torrent title matches specific season/episode
        function getEpisodeMatchScore(title, season, episode) {
            if (!season || !episode || !title) return 0;
            
            const titleLower = title.toLowerCase();
            const s = parseInt(season);
            const e = parseInt(episode);
            
            // Create patterns for different episode naming formats
            const patterns = [
                // S01E01 format (most common)
                new RegExp(`s0*${s}[\\s._-]*e0*${e}(?!\\d)`, 'i'),
                // S01.E01 format
                new RegExp(`s0*${s}\\.e0*${e}(?!\\d)`, 'i'),
                // 1x01 format
                new RegExp(`(?:^|\\D)${s}x0*${e}(?!\\d)`, 'i'),
                // Season 1 Episode 1 format (written out)
                new RegExp(`season[\\s._-]*0*${s}[\\s._-]*episode[\\s._-]*0*${e}(?!\\d)`, 'i'),
                // Ep1S1 or E1S1 format
                new RegExp(`e(?:p)?0*${e}s0*${s}(?!\\d)`, 'i'),
                // S1Ep1 format
                new RegExp(`s0*${s}ep0*${e}(?!\\d)`, 'i'),
                // [1-01] or (1-01) format
                new RegExp(`[\\[\\(]0*${s}[\\s._-]0*${e}[\\]\\)]`, 'i')
            ];
            
            // Check if any pattern matches
            for (let i = 0; i < patterns.length; i++) {
                if (patterns[i].test(titleLower)) {
                    // Return higher score for exact matches (based on pattern priority)
                    // First pattern (S01E01) gets highest bonus
                    return 1000 - (i * 10);
                }
            }
            
            return 0; // No match
        }

        // Display torrents
        function displayTorrents(torrents, season = null, episode = null) {
            // Compute episode match scores if TV ep context; actual sorting applied in renderTorrentsPage based on current sort mode
            if (season && episode && currentMediaType === 'tv') {
                allTorrents = (torrents || []).map(t => ({
                    ...t,
                    episodeMatchScore: getEpisodeMatchScore(t.title, season, episode)
                }));
            } else {
                allTorrents = (torrents || []).slice();
            }
            torrentsPage = 1;
            renderTorrentsPage();
        }

        function renderTorrentsPage() {
            torrentsList.innerHTML = '';
            
            console.log('[RENDER] Starting renderTorrentsPage with sort mode:', torrentSortMode);
            
            // Apply sorting according to mode (keeping episode match priority for TV episodes)
            const isTvEp = currentMediaType === 'tv' && lastSearchedSeason && lastSearchedEpisode;
            const toSort = (allTorrents || []).slice();
            
            console.log('[RENDER] Total torrents to sort:', toSort.length, 'isTvEp:', isTvEp);
            
            toSort.sort((a, b) => {
                // TV episode exact match priority (always first)
                if (isTvEp) {
                    const ea = Number(a.episodeMatchScore || 0);
                    const eb = Number(b.episodeMatchScore || 0);
                    if (eb !== ea) return eb - ea; // primary: episode match
                }
                
                // Apply selected sort mode
                const mode = (typeof torrentSortMode === 'string') ? torrentSortMode : 'seeders';
                
                if (mode === 'size-asc') {
                    const sa = Number(a.size || 0);
                    const sb = Number(b.size || 0);
                    return sa - sb; // smallest first
                } else if (mode === 'size-desc') {
                    const sa = Number(a.size || 0);
                    const sb = Number(b.size || 0);
                    return sb - sa; // largest first
                } else {
                    // default: seeders desc
                    const seeda = Number(a.seeders || 0);
                    const seedb = Number(b.seeders || 0);
                    return seedb - seeda;
                }
            });
            
            console.log('[RENDER] After sort, first 3 torrents:');
            toSort.slice(0, 3).forEach((t, i) => {
                console.log(`  ${i+1}. Size: ${((t.size||0)/1024/1024/1024).toFixed(2)}GB, Seeds: ${t.seeders}, Title: ${t.title?.substring(0, 50)}`);
            });
            
            // Apply keyword filter
            let filteredTorrents = toSort;
            const keyword = torrentKeywordFilter ? torrentKeywordFilter.value.trim().toLowerCase() : '';
            if (keyword) {
                filteredTorrents = toSort.filter(t => 
                    (t.title || '').toLowerCase().includes(keyword)
                );
            }

            // Apply size filter
            try {
                if (typeof torrentSizeFilter === 'string' && torrentSizeFilter !== 'all') {
                    filteredTorrents = filteredTorrents.filter(t => bytesMatchesSizeFilter(t.size));
                }
            } catch(_) {}
            
            if (filteredTorrents.length === 0) {
                torrentsList.innerHTML = keyword 
                    ? '<p>No torrents match your filter.</p>' 
                    : '<p>No torrents found. Try enabling <strong>Streaming Servers</strong> in the app settings for more sources.</p>';
                return;
            }

            const start = (torrentsPage - 1) * torrentsPerPage;
            const end = start + torrentsPerPage;
            const paginatedTorrents = filteredTorrents.slice(start, end);

            let rdAvailChecked = 0;
            const rdAvailBudget = 12; // cap RD availability checks per render
            paginatedTorrents.forEach(torrent => {
                const item = document.createElement('div');
                item.className = 'torrent-item';
                item.innerHTML = `
                    <div class="torrent-info">
                        <p class="torrent-name">
                            ${torrent.title}
                            <span class="cached-badge" style="display:none; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 8px;"></span>
                        </p>
                        <div class="torrent-details">
                            <span><i class="fas fa-arrow-up"></i> ${torrent.seeders}</span>
                            <span><i class="fas fa-database"></i> ${((torrent.size || 0) / 1024 / 1024 / 1024).toFixed(2)} GB</span>
                        </div>
                    </div>
                    <div class="torrent-actions">
                        <button class="btn-play torrent-btn"><i class="fas fa-play"></i> Play</button>
                        <button class="btn-copy torrent-btn"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                `;

                const playButton = item.querySelector('.btn-play');
                if (playButton) {
                    if (torrent.streamUrl) {
                         playButton.addEventListener('click', async (e) => {
                             e.stopPropagation();
                             try {
                                 const tmdbId = currentContent?.id?.toString() || '';
                                 let seasonNum = null;
                                 let episodeNum = null;
                                 
                                 // Determine season/episode if TV show
                                 if (currentMediaType === 'tv') {
                                     if (lastSearchedSeason && lastSearchedEpisode) {
                                         seasonNum = String(lastSearchedSeason);
                                         episodeNum = String(lastSearchedEpisode);
                                     } else if (currentSeason) {
                                         // Fallback if lastSearched vars aren't set but currentSeason is
                                         seasonNum = String(currentSeason);
                                         // Try to parse episode from title if not explicit
                                         const epMatch = (torrent.title || '').match(/[E|e](\d+)/);
                                         if (epMatch) episodeNum = epMatch[1];
                                     }
                                 }

                                 const res = await window.electronAPI.spawnMpvjsPlayer({
                                     url: torrent.streamUrl,
                                     tmdbId,
                                     seasonNum,
                                     episodeNum,
                                     isDebrid: useDebrid
                                 });

                                 if (res?.success) {
                                     showNotification('Player launched');
                                 } else if (res?.message) {
                                     alert(res.message);
                                 } else {
                                     showNotification('Failed to launch MPV player');
                                 }
                             } catch (err) {
                                 console.error('[Addon] Play Now error:', err);
                                 showNotification('Failed to play: ' + (err?.message || 'Unknown error'));
                             }
                         });
                    } else if (torrent.magnet) {
                        playButton.addEventListener('click', () => startStream(torrent.magnet));
                    } else if (torrent.torrentFileUrl) {
                        playButton.addEventListener('click', () => handleTorrentFileUrl(torrent));
                    }
                }
                
                const copyButton = item.querySelector('.btn-copy');
                if(copyButton) {
                    if (torrent.streamUrl) {
                         copyButton.addEventListener('click', () => {
                             navigator.clipboard.writeText(torrent.streamUrl).then(() => {
                                 showNotification('Stream URL copied to clipboard');
                             });
                         });
                    } else if (torrent.magnet) {
                        copyButton.addEventListener('click', () => copyMagnet(torrent.magnet));
                    } else if (torrent.torrentFileUrl) {
                        copyButton.addEventListener('click', () => {
                            navigator.clipboard.writeText(torrent.torrentFileUrl).then(() => {
                                showNotification('Torrent file URL copied to clipboard');
                            });
                        });
                    }
                }

                torrentsList.appendChild(item);

                // Debrid availability check REMOVED: Feature permanently disabled by Real-Debrid (403 disabled_endpoint)
                // We cannot check cached status without adding the torrent to the user's account, which is too heavy for list views.
            });

            renderTorrentPagination();
        }

        function renderTorrentPagination() {
            // Apply same keyword filter for pagination count
            let filteredTorrents = allTorrents;
            const keyword = torrentKeywordFilter ? torrentKeywordFilter.value.trim().toLowerCase() : '';
            if (keyword) {
                filteredTorrents = allTorrents.filter(t => 
                    (t.title || '').toLowerCase().includes(keyword)
                );
            }

            // Apply size filter as well for accurate page count
            try {
                if (typeof torrentSizeFilter === 'string' && torrentSizeFilter !== 'all') {
                    filteredTorrents = filteredTorrents.filter(t => bytesMatchesSizeFilter(t.size));
                }
            } catch(_) {}
            
            const totalPages = Math.ceil(filteredTorrents.length / torrentsPerPage);
            if (totalPages <= 1) {
                return;
            }

            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'torrent-pagination';

            const prevBtn = document.createElement('button');
            prevBtn.innerHTML = '<i class="fas fa-arrow-left"></i>';
            prevBtn.disabled = torrentsPage === 1;
            prevBtn.addEventListener('click', () => {
                if (torrentsPage > 1) {
                    torrentsPage--;
                    renderTorrentsPage();
                }
            });

            const nextBtn = document.createElement('button');
            nextBtn.innerHTML = '<i class="fas fa-arrow-right"></i>';
            nextBtn.disabled = torrentsPage === totalPages;
            nextBtn.addEventListener('click', () => {
                if (torrentsPage < totalPages) {
                    torrentsPage++;
                    renderTorrentsPage();
                }
            });

            const pageInfo = document.createElement('span');
            pageInfo.textContent = `Page ${torrentsPage} of ${totalPages}`;

            paginationContainer.appendChild(prevBtn);
            paginationContainer.appendChild(pageInfo);
            paginationContainer.appendChild(nextBtn);

            torrentsList.appendChild(paginationContainer);
        }

        // Start streaming a torrent

        async function handleTorrentFileUrl(torrent) {
            if (!torrent || !torrent.torrentFileUrl) return;

            showNotification('Resolving torrent file...', 'info');
            try {
                const response = await fetch(`${API_BASE_URL}/resolve-torrent-file?url=${encodeURIComponent(torrent.torrentFileUrl)}&title=${encodeURIComponent(torrent.title)}`);
                const data = await response.json();

                if (response.ok && data.magnet) {
                    showNotification('Torrent resolved, starting stream...', 'success');
                    await startStream(data.magnet);
                } else {
                    throw new Error(data.error || 'Failed to resolve torrent file');
                }
            } catch (error) {
                console.error('Error resolving torrent file:', error);
                showNotification(error.message, 'error');
            }
        }

        async function startStream(magnet) {
            // Refresh debrid flags before deciding path
            await ensureDebridState();
            const providerLabel = getProviderDisplayName(debridProvider);
            
            console.log('[UI][Stream] Starting with settings:', { useDebrid, debridAuth, debridProvider });
            
            // If Debrid is enabled but not authenticated, block fallback and prompt login
            if (useDebrid && !debridAuth) {
                console.warn('[UI][Debrid] blocked: enabled but not logged in');
                showNotification(`${providerLabel} is enabled but you are not logged in. Please log in to continue.`);
                promptDebridLogin();
                return;
            }
            
            // Debrid-exclusive flow when enabled: skip WebTorrent entirely
            if (useDebrid && debridAuth && magnet && magnet.startsWith('magnet:')) {
                console.log('[UI][Stream] Using Debrid path');
                try {
                    // Start a new Debrid session (used to cancel polling if user exits)
                    const myDebridSession = ++debridFlowSession;
                    const isSessionActive = (expectedId) => {
                        const playerOpen = mpvPlayerContainer.classList.contains('active');
                        const sessionOk = (myDebridSession === debridFlowSession);
                        const idOk = (!expectedId) || (currentDebridTorrentId === expectedId);
                        return playerOpen && sessionOk && idOk;
                    };
                    // Open our player UI first
                    showPlayer();
                    mpvLoading.style.display = 'flex';
                    mpvControls.style.display = 'none';
                    fileList.innerHTML = '';
                    subtitleList.innerHTML = '';
                    subtitleControls.style.display = 'none';
                    playerTitle.textContent = `Preparing ${providerLabel}`;

                    // Add magnet to RD and select all
                    console.log('[UI][Debrid] prepare addMagnet');
                    const prep = await fetch(`${API_BASE_URL}/debrid/prepare`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ magnet })
                    });
                    if (!prep.ok) {
                        let notif = 'Debrid prepare failed';
                        try {
                            const txt = await prep.text();
                            console.error('[UI][Debrid] prepare failed', txt);
                            try {
                                const ej = JSON.parse(txt);
                                if (ej && ej.code === 'RD_PREMIUM_REQUIRED') {
                                    notif = `${providerLabel} premium is required to add torrents. Disable Debrid in Settings to use WebTorrent instead.`;
                                } else if (ej && ej.code === 'DEBRID_UNAUTH') {
                                    notif = `${providerLabel} authentication invalid. Please login again.`;
                                    if (debridStatus) debridStatus.textContent = 'Not logged in';
                                    promptDebridLogin();
                                } else if (ej && ej.code === 'TORBOX_UNIMPLEMENTED') {
                                    notif = 'TorBox is not supported yet. Please switch provider in Settings or disable Debrid to use WebTorrent.';
                                } else if (ej && ej.error) {
                                    notif = ej.error;
                                }
                            } catch { /* not json */ }
                        } catch { /* ignore */ }
                        showNotification(notif);
                        mpvLoading.style.display = 'none';
                        return;
                    }
                    const prepj = await prep.json();
                    const rdId = prepj.id;
                    currentDebridTorrentId = rdId; // Track globally for cleanup
                    let info = prepj.info || null;
                    if (!isSessionActive(rdId)) return; // user closed / session invalidated
                    
                    if (!info || !Array.isArray(info.files) || !info.files.length) {
                        await new Promise(r => setTimeout(r, 900));
                        if (!isSessionActive(rdId)) return; // cancelled
                        const fres = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(rdId)}`);
                        if (fres.ok) info = await fres.json();
                    }

                    let files = (info && info.files) || [];
                    // If metadata/files are not ready yet, poll a few times (helps TorBox and slow RD responses)
                    if (!files.length) {
                        for (let i = 0; i < 8; i++) {
                            await new Promise(r => setTimeout(r, 1000));
                            if (!isSessionActive(rdId)) return; // cancelled
                            try {
                                const rf = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(rdId)}`);
                                if (rf.ok) {
                                    const ij = await rf.json();
                                    files = (ij && ij.files) || [];
                                    if (files.length) break;
                                }
                            } catch {}
                        }
                    }
                    // Render RD files for explicit selection, like our torrent file list
                    mpvLoading.style.display = 'none';
                    fileList.innerHTML = '';
                    
                    const isCached = info?.status === 'downloaded';
                    const statusPrefix = isCached ? ' Cached' : ' Downloading';
                    playerTitle.textContent = `${statusPrefix} - ${info?.filename || providerLabel}`;
                    
                    if (!isCached) {
                        showNotification(`${providerLabel}: Torrent not cached. Downloading to cloud...`, 'info');
                    } else {
                        showNotification(`${providerLabel}: Torrent is cached and ready!`, 'success');
                    }

                    const rdVideos = files.filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                    const rdSubs = files.filter(f => /\.(srt|vtt)$/i.test(f.path || f.filename || ''));

                    const displayName = (f) => (f.path || f.filename || 'file');
                    const displaySize = (f) => ((f.bytes || f.size || 0) / 1024 / 1024).toFixed(2) + ' MB';

                    // Helper to render a small cached status badge
                    const statusBadgeHtml = (file) => {
                        // If the torrent itself is 'downloaded', effectively all its files are cached/ready
                        const cached = (info?.status === 'downloaded') || (file && file.cached === true) || (Array.isArray(file.links) && file.links.length > 0);
                        const label = cached ? 'Cached' : 'Not cached';
                        const bg = cached ? 'background:#198754;' : 'background:#6c757d;';
                        return `<span class="source-badge rd-cache-badge" style="${bg} margin-left:6px;">${label}</span>`;
                    };

                    // Poll Debrid files info until ALL files have links (cached) or timeout
                    async function pollForAllLinks(id, { timeoutMs = 60000, intervalMs = 2000 } = {}) {
                        const start = Date.now();
                        console.log('[UI][Debrid] Starting polling for file links...');
                        while (Date.now() - start < timeoutMs) {
                            if (!isSessionActive(id)) return null; // cancelled/closed
                            try {
                                const fres = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(id)}`);
                                if (!fres.ok) {
                                    // If rate limited or disabled endpoint reported, stop trying
                                    try {
                                        const t = await fres.text();
                                        if (/RD_RATE_LIMIT|RD_FEATURE_UNAVAILABLE|TB_NO_SEEDS/i.test(t)) {
                                            if (/TB_NO_SEEDS/i.test(t)) {
                                                showNotification(' This torrent has no seeders and cannot be cached. Try a different release.', 'error');
                                            }
                                            return null;
                                        }
                                    } catch {}
                                    await new Promise(r => setTimeout(r, intervalMs));
                                    continue;
                                }
                                const info = await fres.json();
                                const filesList = Array.isArray(info?.files) ? info.files : [];
                                const videos = filesList.filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                                
                                // Check if any video files have links
                                const anyHasLinks = videos.some(f => Array.isArray(f.links) && f.links.length > 0);
                                
                                if (anyHasLinks) {
                                    console.log('[UI][Debrid] Files are ready! Links available.');
                                    return filesList;
                                }
                                
                                // Show progress if available
                                const status = info?.status || '';
                                const progress = info?.progress || 0;
                                if (status && progress > 0) {
                                    playerTitle.textContent = `${info?.filename || 'Downloading'} - ${progress}%`;
                                }
                            } catch(e) {
                                console.warn('[UI][Debrid] Polling error:', e?.message);
                            }
                            await new Promise(r => setTimeout(r, intervalMs));
                        }
                        console.warn('[UI][Debrid] Polling timed out after', timeoutMs, 'ms');
                        return null; // timed out
                    }

                    // Poll Debrid files info until the specific file has links (cached) or timeout
                    async function waitForRdLinks(id, fileId, { timeoutMs = 30000, intervalMs = 1500 } = {}) {
                        const start = Date.now();
                        while (Date.now() - start < timeoutMs) {
                            if (!isSessionActive(id)) return null; // cancelled/closed
                            try {
                                const fres = await fetch(`${API_BASE_URL}/debrid/files?id=${encodeURIComponent(id)}`);
                                if (!fres.ok) {
                                    // If rate limited or disabled endpoint reported, stop trying
                                    try {
                                        const t = await fres.text();
                                        if (/RD_RATE_LIMIT|RD_FEATURE_UNAVAILABLE|TB_NO_SEEDS/i.test(t)) {
                                            if (/TB_NO_SEEDS/i.test(t)) {
                                                showNotification(' This torrent has no seeders. Try a different release.', 'error');
                                            }
                                            return null;
                                        }
                                    } catch {}
                                    await new Promise(r => setTimeout(r, intervalMs));
                                    continue;
                                }
                                const info = await fres.json();
                                const list = Array.isArray(info?.files) ? info.files : [];
                                const found = list.find(x => String(x.id || x.file) === String(fileId));
                                if (found && Array.isArray(found.links) && found.links.length) {
                                    return found.links[0];
                                }
                            } catch {}
                            await new Promise(r => setTimeout(r, intervalMs));
                        }
                        return null; // timed out
                    }
                    
                    // Check if any files are not cached yet
                    const hasUncachedFiles = rdVideos.some(f => !Array.isArray(f.links) || f.links.length === 0);
                    
                    if (hasUncachedFiles) {
                        // Show status message
                        playerTitle.textContent = `${info?.filename || 'Torrent'} - Preparing files...`;
                        showNotification('Waiting for files to be ready on Real-Debrid...');
                        
                        // Poll for links in background
                        (async () => {
                            const updatedFiles = await pollForAllLinks(rdId);
                            if (updatedFiles) {
                                if (!isSessionActive(rdId)) return; // cancelled
                                // Re-render files with updated links
                                const updatedVideos = updatedFiles.filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                                const updatedSubs = updatedFiles.filter(f => /\.(srt|vtt)$/i.test(f.path || f.filename || ''));
                                
                                // Update the rdVideos and rdSubs arrays
                                rdVideos.length = 0;
                                rdVideos.push(...updatedVideos);
                                rdSubs.length = 0;
                                rdSubs.push(...updatedSubs);
                                
                                // Re-render file list
                                fileList.innerHTML = '';
                                rdVideos.forEach((f) => {
                                    const item = document.createElement('div');
                                    item.className = 'file-item';
                                    item.innerHTML = `<p class="file-name">${displayName(f)} ${statusBadgeHtml(f)}</p><p class="file-size">(${displaySize(f)})</p>`;
                                    item.addEventListener('click', createFileClickHandler(f, rdId, rdSubs));
                                    fileList.appendChild(item);
                                });
                                
                                playerTitle.textContent = info?.filename || providerLabel;
                                showNotification(' Files are ready! Click to play.');
                            } else {
                                showNotification('Files are taking longer than expected. Try again later.');
                            }
                        })();
                    }
                    
                    // Extract click handler into a function so we can reuse it
                    function createFileClickHandler(f, rdId, rdSubs) {
                        return async (event) => {
                            try {
                                const clickedItem = event?.currentTarget;
                                if (!isSessionActive(rdId)) return; // cancelled
                                
                                // Disconnect from current debrid torrent before switching files
                                if (currentDebridTorrentId && currentDebridTorrentId !== rdId) {
                                    try {
                                        console.log('[UI][Debrid] Disconnecting from previous torrent before file switch:', currentDebridTorrentId);
                                        await fetch(`${API_BASE_URL}/debrid/cleanup`, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({ id: currentDebridTorrentId })
                                        });
                                    } catch(e) {
                                        console.warn('[UI][Debrid] Error cleaning up previous torrent:', e?.message);
                                    }
                                }
                                
                                // Set resume key and prefetch resume info for Debrid path
                                try {
                                    const fileId = String(f.id || f.file || f.filename || f.path || '0');
                                    resumeKey = `debrid:${debridProvider}:${rdId}:${fileId}`;
                                    resumeInfo = await fetchResume(resumeKey);
                                } catch(_) {}
                                
                                // Always select just this file for RD to process
                                try {
                                        console.log('[UI][Debrid] select-files', { id: rdId, file: String(f.id || f.file) });
                                        const selectRes = await fetch(`${API_BASE_URL}/debrid/select-files`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: rdId, files: String(f.id || f.file) }) });
                                        if (!selectRes.ok) {
                                            const errText = await selectRes.text();
                                            console.warn('[UI][Debrid] select-files failed', errText);
                                            try {
                                                const errJson = JSON.parse(errText);
                                                if (errJson.code === 'DEBRID_UNAUTH') {
                                                    showNotification('Real-Debrid authentication expired. Please logout and login again in Settings.');
                                                    mpvLoading.style.display = 'none';
                                                    if (debridStatus) debridStatus.textContent = 'Not logged in';
                                                    return;
                                                }
                                            } catch {}
                                        } else {
                                            // Check if torrent was re-added with new ID for file switching
                                            try {
                                                const selectData = await selectRes.json();
                                                if (selectData.reAddedForFileSwitch && selectData.id) {
                                                    console.log('[UI][Debrid] Torrent re-added for file switch. Old ID:', rdId, ' New ID:', selectData.id);
                                                    rdId = selectData.id; // Update to new torrent ID
                                                    currentDebridTorrentId = selectData.id; // Update global tracker
                                                    if (!isSessionActive(rdId)) return; // cancelled
                                                    showNotification('Switched to episode ' + (f.id || f.file) + ' - Reloading file list...');
                                                    
                                                    // Fully reload the file selector with new torrent info
                                                    if (selectData.info && selectData.info.files) {
                                                        console.log('[UI][Debrid] Reloading file selector with new torrent info');
                                                        const newFiles = selectData.info.files;
                                                        const newVideos = newFiles.filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                                                        const newSubs = newFiles.filter(f => /\.(srt|vtt)$/i.test(f.path || f.filename || ''));
                                                        
                                                        // Update the arrays
                                                        rdVideos.length = 0;
                                                        rdVideos.push(...newVideos);
                                                        rdSubs.length = 0;
                                                        rdSubs.push(...newSubs);
                                                        
                                                        // Clear and re-render file list
                                                        fileList.innerHTML = '';
                                                        rdVideos.forEach((newFile) => {
                                                            const item = document.createElement('div');
                                                            item.className = 'file-item';
                                                            item.innerHTML = `<p class="file-name">${displayName(newFile)} ${statusBadgeHtml(newFile)}</p><p class="file-size">(${displaySize(newFile)})</p>`;
                                                            item.addEventListener('click', createFileClickHandler(newFile, rdId, newSubs));
                                                            fileList.appendChild(item);
                                                        });
                                                        
                                                        // Update player title with torrent name
                                                        if (selectData.info.filename) {
                                                            playerTitle.textContent = selectData.info.filename;
                                                        }
                                                    }
                                                }
                                            } catch(e) {
                                                console.warn('[UI][Debrid] Could not parse select-files response:', e?.message);
                                            }
                                        }
                                } catch(e) { console.warn('[UI][Debrid] select-files exception', e?.message); }
                                
                                // Find current link if already cached, else wait for caching
                                let link = Array.isArray(f.links) && f.links.length ? f.links[0] : null;
                                if (!link) {
                                    showNotification(`Not cached yet on ${providerLabel}. Waiting to cache`);
                                    // Show loading indicator while waiting
                                    mpvLoading.style.display = 'flex';
                                    const waited = await waitForRdLinks(rdId, (f.id || f.file));
                                    if (!isSessionActive(rdId)) return; // cancelled
                                    link = waited;
                                    // Update badge to Cached if now available
                                    if (link && clickedItem) {
                                        try {
                                            const badge = clickedItem.querySelector('.rd-cache-badge');
                                            if (badge) { badge.textContent = 'Cached'; badge.style.background = '#198754'; }
                                        } catch {}
                                    }
                                }
                                if (!link) {
                                    showNotification('Still not cached. Try again later or disable Debrid in Settings to use WebTorrent.');
                                    mpvLoading.style.display = 'none';
                                    return;
                                }
                                // Unrestrict the resolved link
                                const unres = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link }) });
                                if (!unres.ok) {
                                    console.error('[UI][Debrid] unrestrict/stream resolve failed', await unres.text());
                                    const msg = (debridProvider === 'torbox') ? 'Failed to get stream link' : 'Failed to unrestrict';
                                    showNotification(msg);
                                    mpvLoading.style.display = 'none';
                                    return;
                                }
                                const uj = await unres.json();
                                if (!uj?.url) { console.error('[UI][Debrid] unrestrict response missing url', uj); showNotification('Invalid Debrid URL'); mpvLoading.style.display = 'none'; return; }
                                
                                // For MPV: Use direct CDN URL to avoid query parameter encoding issues
                                // MPV's ffmpeg is strict about URL encoding and fails with proxied URLs
                                // VLC and in-app player can use the proxy for better header control
                                const cdnUrl = uj.url;
                                
                                // Store direct CDN URL for MPV, proxy URL for others
                                currentStreamUrl = cdnUrl; // Direct CDN URL works for all players
                                
                                const fname = baseName(f.path || f.filename || '');
                                currentSelectedVideoName = fname || displayName(f);
                                playerTitle.textContent = currentSelectedVideoName || displayName(f);
                                // Source badges -> Debrid
                                if (streamSourceBadge) { streamSourceBadge.textContent = 'Debrid'; streamSourceBadge.classList.remove('webtorrent'); streamSourceBadge.classList.add('debrid'); }
                                if (customSourceBadge) { customSourceBadge.textContent = 'Debrid'; customSourceBadge.classList.remove('webtorrent'); customSourceBadge.classList.add('debrid'); }
                                mpvControls.style.display = 'flex';
                                mpvLoading.style.display = 'none';
                                showNotification(`Ready via ${providerLabel}`);

                                // Auto-attach subtitle: prefer same folder subtitle
                                const sub = rdSubs[0];
                                if (sub && Array.isArray(sub.links) && sub.links.length) {
                                    try {
                                        const su = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: sub.links[0] }) });
                                        if (su.ok) {
                                            const suj = await su.json();
                                            if (suj?.url) {
                                                const dl = await fetch(`${API_BASE_URL}/subtitles/download-direct`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: suj.url, preferredName: displayName(sub) }) });
                                                const dlj = await dl.json();
                                                if (dl.ok && dlj.url) currentSubtitleUrl = dlj.url;
                                            }
                                        } else { console.warn('[UI][Debrid] sub unrestrict failed', await su.text()); }
                                    } catch(e) { console.warn('[UI][Debrid] sub attach failed', e?.message); }
                                }
                            } catch (_) {
                                console.error('[UI][Debrid] file play failed');
                                showNotification('Failed to prepare Debrid file');
                            }
                        };
                    }

                    // Initial render of files
                    rdVideos.forEach((f) => {
                        const item = document.createElement('div');
                        item.className = 'file-item';
                        item.innerHTML = `<p class="file-name">${displayName(f)} ${statusBadgeHtml(f)}</p><p class="file-size">(${displaySize(f)})</p>`;
                        item.addEventListener('click', createFileClickHandler(f, rdId, rdSubs));
                        fileList.appendChild(item);
                    });

                    // Subtitle sidebar for visibility
                    if (rdSubs.length) {
                        subtitleControls.style.display = 'flex';
                        subtitleList.innerHTML = '';
                        subtitleList.classList.add('subtitle-list');
                        currentSubtitles = rdSubs.map(s => ({ name: displayName(s), index: -1 }));
                        rdSubs.forEach((s) => {
                            const subItem = document.createElement('div');
                            subItem.className = 'subtitle-item';
                            const langDiv = document.createElement('div');
                            langDiv.className = 'subtitle-lang';
                            langDiv.textContent = displayName(s);
                            subItem.appendChild(langDiv);
                            subItem.addEventListener('click', async () => {
                                try {
                                    const l = Array.isArray(s.links) && s.links.length ? s.links[0] : null;
                                    if (!l) return;
                                    const su = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: l }) });
                                    if (!su.ok) { console.warn('[UI][Debrid] sub unrestrict failed', await su.text()); return; }
                                    const suj = await su.json();
                                    if (!suj?.url) return;
                                    const dl = await fetch(`${API_BASE_URL}/subtitles/download-direct`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: suj.url, preferredName: displayName(s) }) });
                                    const dlj = await dl.json();
                                    if (dl.ok && dlj.url) {
                                        currentSubtitleUrl = dlj.url;
                                        showNotification('Subtitle ready');
                                    }
                                } catch(e) { console.warn('[UI][Debrid] sub attach failed', e?.message); }
                            });
                            subtitleList.appendChild(subItem);
                        });
                    }
                    return; // Debrid path handled fully
                } catch (e) {
                    console.error('[UI][Debrid] flow failed', e?.message);
                    showNotification('Debrid path failed. Falling back to WebTorrent.');
                    mpvLoading.style.display = 'none';
                    // Don't return here - let it fall through to WebTorrent
                }
            }

            // Fallback to WebTorrent (when Debrid is disabled OR debrid flow failed)
            console.log('[UI][Stream] Using torrent engine path');
            showPlayer();
            mpvLoading.style.display = 'flex';
            mpvControls.style.display = 'none';
            fileList.innerHTML = '';
            subtitleList.innerHTML = '';
            subtitleControls.style.display = 'none';
            playerTitle.textContent = 'Loading torrent info...';

            try {
                // Check which engine to use
                let engineConfig = { engine: 'stremio', instances: 1 };
                try {
                    const cfgRes = await fetch('http://localhost:6987/api/torrent-engine/config');
                    if (cfgRes.ok) engineConfig = await cfgRes.json();
                } catch(e) { console.warn('[Engine] Config fetch failed, using stremio'); }
                
                const isAltEngine = engineConfig.engine !== 'stremio';
                const engineNames = { stremio: 'Stremio', webtorrent: 'WebTorrent', torrentstream: 'TorrentStream', hybrid: 'Hybrid' };
                const engineName = engineNames[engineConfig.engine] || 'Stremio';
                
                console.log('[UI][Stream] Using engine:', engineConfig.engine, 'isAlt:', isAltEngine);
                
                // Use appropriate endpoint based on engine
                const filesUrl = isAltEngine 
                    ? `http://localhost:6987/api/alt-torrent-files?magnet=${encodeURIComponent(magnet)}`
                    : `${API_BASE_URL}/torrent-files?magnet=${encodeURIComponent(magnet)}`;
                
                const response = await fetch(filesUrl);
                const data = await response.json();
                currentTorrentData = data;
                currentTorrentData._isAltEngine = isAltEngine; // Store for displayFiles
                playerTitle.textContent = data.name || 'Selected Torrent';
                displayFiles(data.videoFiles || [], data.subtitleFiles || []);
                
                // Set source badges
                if (streamSourceBadge) { streamSourceBadge.textContent = engineName; streamSourceBadge.classList.remove('debrid'); streamSourceBadge.classList.add('webtorrent'); }
                if (customSourceBadge) { customSourceBadge.textContent = engineName; customSourceBadge.classList.remove('debrid'); customSourceBadge.classList.add('webtorrent'); }
            } catch (error) {
                console.error('Error getting torrent files:', error);
            }
        }

        function promptDebridLogin() {
            try {
                showSettingsModal().then(() => {
                    setTimeout(() => {
                        try {
                            const sec = document.getElementById('debridSection');
                            if (sec && typeof sec.scrollIntoView === 'function') {
                                sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                            // Focus appropriate control by provider
                            if (debridProvider === 'alldebrid') {
                                if (adSection) adSection.style.display = '';
                                if (adStartPinBtn) adStartPinBtn.focus();
                            } else {
                                const input = document.getElementById('rdClientId');
                                if (input) input.focus();
                            }
                        } catch(_) {}
                    }, 50);
                });
            } catch(_) {
                // As a fallback, open settings without smooth behaviors
                showSettingsModal();
            }
        }

        // Helpers: parse BTIH from magnet and pick best file from RD
        function extractInfoHashFromMagnet(magnet) {
            try {
                const m = /btih:([A-Za-z0-9]{32,40})/i.exec(magnet);
                return m ? encodeURIComponent(m[1].toUpperCase()) : '';
            } catch { return ''; }
        }
        function pickBestVideoFile(files) {
            try {
                const vids = (files || []).filter(f => /\.(mp4|mkv|avi|mov)$/i.test(f.path || f.filename || ''));
                if (!vids.length) return null;
                vids.sort((a,b) => (b.bytes || b.size || 0) - (a.bytes || a.size || 0));
                return vids[0];
            } catch { return null; }
        }

        // Display files for selection
        function displayFiles(videos, subtitles) {
            mpvLoading.style.display = 'none';
            fileList.innerHTML = '';

            // Sort videos by season and episode
            videos.sort((a, b) => {
                const regex = /(S|s)(\d+)(E|e)(\d+)|(\d+)x(\d+)|(\d+)-(\d+)/;

                const aMatch = a.name.match(regex);
                const bMatch = b.name.match(regex);

                if (aMatch && bMatch) {
                    const aSeason = parseInt(aMatch[2] || aMatch[5] || aMatch[7], 10);
                    const aEpisode = parseInt(aMatch[4] || aMatch[6] || aMatch[8], 10);
                    const bSeason = parseInt(bMatch[2] || bMatch[5] || bMatch[7], 10);
                    const bEpisode = parseInt(bMatch[4] || bMatch[6] || bMatch[8], 10);

                    if (aSeason !== bSeason) {
                        return aSeason - bSeason;
                    }
                    return aEpisode - bEpisode;
                }
                // If no match, sort alphabetically
                return a.name.localeCompare(b.name);
            });

            videos.forEach(file => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <p class="file-name">${file.name}</p>
                    <p class="file-size">(${(file.size / 1024 / 1024).toFixed(2)} MB)</p>
                `;

                let hoverTimer;
                item.addEventListener('mouseenter', () => {
                    hoverTimer = setTimeout(() => {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'file-name-tooltip';
                        tooltip.textContent = file.name;
                        item.appendChild(tooltip);
                    }, 3000);
                });

                item.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimer);
                    const tooltip = item.querySelector('.file-name-tooltip');
                    if (tooltip) {
                        tooltip.remove();
                    }
                });

                item.addEventListener('click', async () => {
                    // Use appropriate endpoint based on engine
                    const isAltEngine = currentTorrentData._isAltEngine || false;
                    const streamUrl = isAltEngine 
                        ? `http://localhost:6987/api/alt-stream-file?hash=${currentTorrentData.infoHash}&file=${file.index}`
                        : `${API_BASE_URL}/stream-file?hash=${currentTorrentData.infoHash}&file=${file.index}`;
                    const prepareUrl = isAltEngine
                        ? `http://localhost:6987/api/alt-prepare-file?hash=${currentTorrentData.infoHash}&file=${file.index}`
                        : `${API_BASE_URL}/prepare-file?hash=${currentTorrentData.infoHash}&file=${file.index}`;
                    
                    currentStreamUrl = streamUrl;
                    currentSelectedVideoName = baseName(file.name);
                    playerTitle.textContent = currentSelectedVideoName;
                    // Compute resume key and prefetch resume info
                    try {
                        resumeKey = `webtorrent:${currentTorrentData.infoHash}:${file.index}`;
                        resumeInfo = await fetchResume(resumeKey);
                    } catch(_) {}
                    mpvControls.style.display = 'flex';
                    // Ask backend to begin downloading the selected file
                    try {
                        await fetch(prepareUrl);
                    } catch (_) {}
                    showNotification(`Selected: ${currentSelectedVideoName}. Click Play Now or Open in MPV to start.`);
                });
                fileList.appendChild(item);
            });

            if (subtitles.length > 0) {
                subtitleControls.style.display = 'flex';
                subtitleList.innerHTML = '';
                subtitleList.classList.add('subtitle-list');
                currentSubtitles = subtitles;
                subtitles.forEach(sub => {
                    const subItem = document.createElement('div');
                    subItem.className = 'subtitle-item';
                    
                    const langDiv = document.createElement('div');
                    langDiv.className = 'subtitle-lang';
                    langDiv.textContent = sub.name;
                    subItem.appendChild(langDiv);

                    subItem.addEventListener('click', async () => {
                        document.querySelectorAll('.subtitle-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        subItem.classList.add('selected');

                        currentSubtitleUrl = `${API_BASE_URL}/subtitle-file?hash=${currentTorrentData.infoHash}&file=${sub.index}`;
                        showNotification(`Selected subtitle: ${sub.name}`);
                    });
                    subtitleList.appendChild(subItem);
                });
            }
        }

        // Show the MPV player
        function showPlayer() {
            mpvPlayerContainer.classList.add('active');
        }

        // Close the MPV player
        async function closePlayer(showNotif = true) {
            mpvPlayerContainer.classList.remove('active');
            // Invalidate any ongoing Debrid polling loops
            debridFlowSession++;
            
            // Cleanup debrid torrent if one is active
            if (currentDebridTorrentId) {
                console.log('[UI][Debrid] Cleaning up torrent:', currentDebridTorrentId);
                try {
                    await fetch(`${API_BASE_URL}/debrid/cleanup`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ id: currentDebridTorrentId })
                    });
                    console.log('[UI][Debrid] Torrent cleanup complete');
                } catch (e) {
                    console.warn('[UI][Debrid] Cleanup failed:', e?.message);
                }
                currentDebridTorrentId = null; // Clear tracker
            }
            
            if (currentTorrentData) {
                try {
                    await fetch(`${API_BASE_URL}/stop-stream?hash=${currentTorrentData.infoHash}`);
                } catch (e) {}
                if (window.electronAPI && showNotif) {
                    try {
                        const result = await window.electronAPI.clearWebtorrentTemp();
                        if (result.success) {
                            showNotification('Player closed and temp files cleared.');
                        } else {
                            showNotification(`Error clearing temp files: ${result.message}`);
                        }
                    } catch (e) {}
                } else if (window.electronAPI) {
                    // Still clear cache, just don't show notification
                    try {
                        await window.electronAPI.clearWebtorrentTemp();
                    } catch (e) {}
                }
            }
            // Cleanup RD auto-downloaded subtitle if present
            try { if (currentSubtitleFile) await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
        }

        // Open stream in MPV
        async function openInMPV() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            
            // On macOS, use IINA instead of MPV
            const isMac = window.electronAPI && window.electronAPI.platform === 'darwin';
            const playerName = isMac ? 'IINA' : 'MPV';
            const apiMethod = isMac ? 'openInIINA' : 'openInMPV';
            
            if (!window.electronAPI || !window.electronAPI[apiMethod]) {
                showNotification(`${playerName} integration not available in this environment`);
                return;
            }
            
            // Update Discord presence for external player streaming
            // Always use TMDB title, not torrent filename
            const title = currentContent?.title || currentContent?.name || 'Video';
            
            // Determine provider based on selectedProvider setting
            let provider;
            if (selectedProvider === 'jackett') {
                provider = 'Jackett';
            } else if (selectedProvider === 'nuvio') {
                provider = 'Nuvio';
            } else if (selectedProvider === 'comet') {
                provider = 'Comet';
            } else if (selectedProvider === '111477') {
                provider = '111477';
            } else if (selectedProvider === 'moviebox') {
                provider = 'MovieBox';
            } else if (selectedProvider === 'torrentless') {
                provider = 'PlayTorrio';
            } else {
                provider = 'App Sources';  // Default fallback
            }
            
            // For TV shows, pass the season number
            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
            updateDiscordForStreaming(title, provider, seasonNum);
            
            const data = {
                streamUrl: currentStreamUrl,
                infoHash: (currentTorrentData && currentTorrentData.infoHash) ? currentTorrentData.infoHash : null,
                startSeconds: (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) ? Math.floor(resumeInfo.position) : undefined
            };
            
            const result = await window.electronAPI[apiMethod](data);
            if (result.success) {
                showNotification(`${playerName} launched - Please Wait! Watch out for a new window`, 'success', 5000);
            } else {
                // Special handling for IINA/MPV not installed
                if (result.message && (result.message.includes('not installed') || result.message.includes('not found'))) {
                    showNotification(result.message, 'error', 10000);
                } else {
                    showNotification(`Error: ${result.message}`, 'error', 7000);
                }
            }
        }

        // Open stream in VLC (same data shape as MPV)
        async function openInVLC() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            if (!window.electronAPI || !window.electronAPI.openInVLC) {
                showNotification('VLC integration not available in this environment');
                return;
            }

            const title = currentContent?.title || currentContent?.name || 'Video';
            let provider;
            if (selectedProvider === 'jackett') provider = 'Jackett';
            else if (selectedProvider === 'nuvio') provider = 'Nuvio';
            else if (selectedProvider === 'comet') provider = 'Comet';
            else if (selectedProvider === '111477') provider = '111477';
            else if (selectedProvider === 'moviebox') provider = 'MovieBox';
            else if (selectedProvider === 'torrentless') provider = 'PlayTorrio';
            else provider = 'App Sources';

            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
            updateDiscordForStreaming(title, provider, seasonNum);

            const data = {
                streamUrl: currentStreamUrl,
                infoHash: (currentTorrentData && currentTorrentData.infoHash) ? currentTorrentData.infoHash : null,
                startSeconds: (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) ? Math.floor(resumeInfo.position) : undefined
            };
            const result = await window.electronAPI.openInVLC(data);
            if (result.success) {
                showNotification('VLC launched - Please Wait! Watch out for a new window', 'success', 5000);
            } else {
                showNotification(`Error: ${result.message}`);
            }
        }

        // Copy stream URL to clipboard
        function copyStreamUrl() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            navigator.clipboard.writeText(currentStreamUrl).then(() => {
                showNotification('Stream URL copied to clipboard');
            });
        }

        // Download subtitles
        function downloadSubtitles() {
            if (!currentSubtitleUrl) {
                showNotification('No subtitle selected');
                return;
            }
            window.open(currentSubtitleUrl);
        }

        // Copy magnet link to clipboard
        function copyMagnet(magnet) {
            navigator.clipboard.writeText(magnet).then(() => {
                showNotification('Magnet link copied to clipboard');
            });
        }

        // Show notification with optional duration and type
        function showNotification(message, type = 'info', duration = 5000) {
            // Clear any existing notification classes
            notification.className = 'notification';
            
            // Add the type class for styling
            if (type) {
                notification.classList.add(type);
            }
            
            // Set the message (text content to avoid HTML injection)
            notification.textContent = message;
            notification.classList.add('show');
            
            // Clear any existing timeout
            if (window.notificationTimeout) {
                clearTimeout(window.notificationTimeout);
            }
            
            // Auto-hide notification after duration
            window.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
            
            // Log notification for debugging
            console.log(`[NOTIFICATION] ${type.toUpperCase()}: ${message}`);
        }

        // Persistent update notification that stays until user restarts
        let persistentUpdateNotification = null;
        let persistentDownloadNotification = null;
        
        function showPersistentUpdateNotification() {
            // Remove any existing persistent notification
            hideUpdateNotification();
            
            // Create persistent notification element
            persistentUpdateNotification = document.createElement('div');
            persistentUpdateNotification.id = 'persistentUpdateNotification';
            persistentUpdateNotification.innerHTML = `
                <div style="
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                    color: white;
                    padding: 16px 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(34, 197, 94, 0.3);
                    z-index: 10000;
                    font-weight: 600;
                    font-size: 14px;
                    max-width: 320px;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    animation: slideInRight 0.4s ease-out;
                ">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <i class="fas fa-rocket" style="font-size: 18px; color: #dcfce7;"></i>
                        <div>
                            <div style="font-size: 15px; margin-bottom: 4px;"> Update Ready!</div>
                            <div style="font-size: 13px; opacity: 0.9;">Restart the app to complete the update</div>
                        </div>
                        <button onclick="restartForUpdate()" style="
                            background: rgba(255, 255, 255, 0.2);
                            border: 1px solid rgba(255, 255, 255, 0.3);
                            color: white;
                            padding: 8px 12px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 12px;
                            font-weight: 600;
                            transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
                        " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                            Restart
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(persistentUpdateNotification);
            
            // Also show a regular notification
            showNotification(' Update ready! Restart to complete installation.', 'success', 6000);
        }
        
        function hideUpdateNotification() {
            if (persistentUpdateNotification) {
                persistentUpdateNotification.remove();
                persistentUpdateNotification = null;
            }
            if (persistentDownloadNotification) {
                persistentDownloadNotification.remove();
                persistentDownloadNotification = null;
            }
        }
        
        function restartForUpdate() {
            hideUpdateNotification();
            // Trigger restart via the existing restart button in the overlay
            document.getElementById('updateRestartBtn')?.click();
        }

        // Persistent downloading notification (sticks during download)
        function showPersistentDownloadNotification(percent = 0) {
            // Remove old download notification if any
            if (persistentDownloadNotification) {
                try { persistentDownloadNotification.remove(); } catch(_) {}
                persistentDownloadNotification = null;
            }
            persistentDownloadNotification = document.createElement('div');
            persistentDownloadNotification.id = 'persistentDownloadNotification';
            persistentDownloadNotification.innerHTML = `
                <div style="
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
                    color: white;
                    padding: 16px 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(124, 58, 237, 0.35);
                    z-index: 10000;
                    font-weight: 600;
                    font-size: 14px;
                    max-width: 340px;
                    min-width: 280px;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.12);
                    animation: slideInRight 0.4s ease-out;
                ">
                    <div style="display:flex; align-items:center; gap:12px;">
                        <i class="fas fa-download" style="font-size:18px; color:#ede9fe;"></i>
                        <div style="flex:1;">
                            <div style="font-size:15px; margin-bottom:6px;">Downloading update...</div>
                            <div id="dlNotifText" style="font-size:13px; opacity:0.95;">${percent}% complete</div>
                            <div style="margin-top:10px; height:6px; background:rgba(255,255,255,0.2); border-radius:6px; overflow:hidden;">
                                <div id="dlNotifBar" style="height:100%; width:${percent}%; background:#c4b5fd; transition: width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(persistentDownloadNotification);
        }

        function updatePersistentDownloadNotification(percent = 0) {
            if (!persistentDownloadNotification) return;
            const text = persistentDownloadNotification.querySelector('#dlNotifText');
            const bar = persistentDownloadNotification.querySelector('#dlNotifBar');
            if (text) text.textContent = `${percent}% complete`;
            if (bar) bar.style.width = `${percent}%`;
        }

        // --- Custom Player Logic ---

        function openCustomPlayer() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            
            // Update Discord presence for streaming
            const tmdbTitle = currentContent?.title || currentContent?.name || 'Unknown';
            
            // Determine provider based on selectedProvider setting
            let provider;
            if (selectedProvider === 'jackett') {
                provider = 'Jackett';
            } else if (selectedProvider === 'nuvio') {
                provider = 'Nuvio';
            } else if (selectedProvider === 'comet') {
                provider = 'Comet';
            } else if (selectedProvider === '111477') {
                provider = '111477';
            } else if (selectedProvider === 'torrentless') {
                provider = 'PlayTorrio';
            } else {
                provider = 'App Sources';
            }
            
            // For TV shows, pass the season number
            const seasonNum = (currentMediaType === 'tv' && currentSeason) ? currentSeason : null;
            updateDiscordForStreaming(tmdbTitle, provider, seasonNum);
            
            customPlayerContainer.classList.add('active');
            customPlayerContainer.style.display = 'flex'; // Ensure it's visible
            
            // Check if this is an HLS stream (.m3u8) and use HLS.js if needed
            if (currentStreamUrl.includes('.m3u8') && typeof Hls !== 'undefined' && Hls.isSupported()) {
                // Destroy existing HLS instance if any
                if (window.hls) {
                    window.hls.destroy();
                }
                
                // Create new HLS instance
                window.hls = new Hls({
                    enableWorker: false,
                    lowLatencyMode: false,
                    backBufferLength: 90
                });
                
                window.hls.loadSource(currentStreamUrl);
                window.hls.attachMedia(customVideo);
                
                window.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('[HLS] Manifest parsed, ready to play');
                });
                
                window.hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('[HLS] Error:', data);
                    if (data.fatal) {
                        if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                            console.log('[HLS] Network error, trying to recover...');
                            window.hls.startLoad();
                        } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                            console.log('[HLS] Media error, trying to recover...');
                            window.hls.recoverMediaError();
                        }
                    }
                });
            } else {
                // Ensure any previous HLS instance is destroyed
                if (window.hls) {
                    window.hls.destroy();
                    window.hls = null;
                }
                
                if (customVideo.canPlayType('application/vnd.apple.mpegurl') && currentStreamUrl.includes('.m3u8')) {
                    // Native HLS support (Safari)
                    const savedTracks = preserveSubtitleTracks();
                    videoSource.setAttribute('src', currentStreamUrl);
                    customVideo.load();
                    customVideo.addEventListener('loadedmetadata', () => restoreSubtitleTracks(savedTracks), { once: true });
                } else {
                    // Regular video file
                    const savedTracks = preserveSubtitleTracks();
                    videoSource.setAttribute('src', currentStreamUrl);
                    customVideo.load();
                    customVideo.addEventListener('loadedmetadata', () => restoreSubtitleTracks(savedTracks), { once: true });
                }
            }
            
            customPlayerTitle.textContent = playerTitle.textContent;
            // If resume is available, seek after metadata loaded
            if (resumeInfo && typeof resumeInfo.position === 'number' && resumeInfo.position > 10) {
                const to = Math.floor(resumeInfo.position);
                customVideo.addEventListener('loadedmetadata', () => { try { customVideo.currentTime = Math.min(to, (customVideo.duration || to + 1) - 1); } catch(_) {} }, { once: true });
                showNotification(`Resuming from ${formatTime(to)}`);
            }
            // Always start recording progress as soon as playback produces timeupdates
            try {
                const onFirst = () => { try { saveResumeThrottled(true); } catch(_) {} customVideo.removeEventListener('timeupdate', onFirst); };
                customVideo.addEventListener('timeupdate', onFirst);
            } catch(_) {}
            // If we prefetched a RD subtitle, attach it now
            if (currentSubtitleUrl) {
                try { loadSubtitle(currentSubtitleUrl, { label: 'Auto', lang: 'en' }); } catch(_) {}
            }

            // Reset subtitles
            if (subtitleTrack) {
                subtitleTrack.mode = 'hidden';
            }
            subtitleDisplay.style.display = 'none';
            htmlSubsPanel.style.display = 'none';
            try {
                customVideo.muted = false;
                const vol = Number(htmlVolume?.value || 80);
                customVideo.volume = Math.max(0, Math.min(1, vol / 100));
                htmlMuteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
            } catch(_) {}

            // Show controls initially
            videoContainer.classList.add('show-controls');
            customPlayerContainer.classList.add('show-controls');
            resetControlsAutoHide();

            // If streaming via RD proxy, add a one-time retry to re-unrestrict on error
            try {
                const u = new URL(videoSource.getAttribute('src'), window.location.origin);
                if (u.pathname.startsWith('/stream/debrid')) {
                    const origDirect = u.searchParams.get('url');
                    let retried = false;
                    customVideo.addEventListener('error', async () => {
                        if (retried) return;
                        retried = true;
                        try {
                            const base = new URL(origDirect);
                            const baseLink = `${base.origin}${base.pathname}`;
                            const rr = await fetch(`${API_BASE_URL}/debrid/link`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ link: baseLink }) });
                            if (rr.ok) {
                                const rj = await rr.json();
                                if (rj?.url) {
                                    const proxied = `${API_BASE_URL}/stream/debrid?url=${encodeURIComponent(rj.url)}`;
                                    const savedTracks = preserveSubtitleTracks();
                                    videoSource.setAttribute('src', proxied);
                                    customVideo.load();
                                    customVideo.addEventListener('loadedmetadata', () => restoreSubtitleTracks(savedTracks), { once: true });
                                    await customVideo.play();
                                }
                            }
                        } catch(_) {}
                    }, { once: false });
                }
            } catch(_) {}
        }

        // Auto-hide controls when idle in custom player
        let controlsHideTimer = null;
        const CONTROLS_HIDE_DELAY = 1500; // ms
        const videoContainer = document.getElementById('videoContainer');

        function showControls() {
            videoContainer.classList.add('show-controls');
            customPlayerContainer.classList.add('show-controls');
        }

        function hideControls() {
            // Do not hide if subtitles panel is open
            if (htmlSubsPanel && htmlSubsPanel.style.display === 'block') return;
            videoContainer.classList.remove('show-controls');
            customPlayerContainer.classList.remove('show-controls');
        }

        function clearControlsTimer() { if (controlsHideTimer) { clearTimeout(controlsHideTimer); controlsHideTimer = null; } }

        function resetControlsAutoHide() {
            clearControlsTimer();
            showControls();
            controlsHideTimer = setTimeout(hideControls, CONTROLS_HIDE_DELAY);
        }

        // Reveal/hide on mouse activity inside video container
        videoContainer.addEventListener('mousemove', resetControlsAutoHide);
        videoContainer.addEventListener('mouseenter', resetControlsAutoHide);
        videoContainer.addEventListener('mouseleave', hideControls);
        // Keep visible while interacting with the controls bar
        videoControls.addEventListener('mouseenter', () => { clearControlsTimer(); showControls(); });
        videoControls.addEventListener('mousemove', () => { clearControlsTimer(); showControls(); });
        videoControls.addEventListener('mouseleave', resetControlsAutoHide);

        // Prevent header from flickering when mouse is over it
        const customPlayerHeader = customPlayerContainer.querySelector('.player-header');
        if (customPlayerHeader) {
            customPlayerHeader.addEventListener('mouseenter', () => { 
                clearControlsTimer(); 
                showControls(); 
            });
            customPlayerHeader.addEventListener('mousemove', () => { 
                clearControlsTimer(); 
                showControls(); 
            });
            customPlayerHeader.addEventListener('mouseleave', resetControlsAutoHide);
        }

        // When opening and closing the subtitles panel, force controls visibility appropriately
        if (htmlSubsBtn) {
            htmlSubsBtn.addEventListener('click', () => {
                // After toggling, ensure state is correct
                setTimeout(() => {
                    if (htmlSubsPanel.style.display === 'block') {
                        clearControlsTimer();
                        showControls();
                    } else {
                        resetControlsAutoHide();
                    }
                }, 0);
            });
        }
        if (htmlSubsClose) {
            htmlSubsClose.addEventListener('click', () => {
                resetControlsAutoHide();
            });
        }

        // ---- WCJS Player Logic ----
        let wcjsPlayer = null;
        let wcjsTimer = null;
        function openWCJSPlayer() {
            if (!currentStreamUrl) {
                showNotification('No file selected to play');
                return;
            }
            try {
                const wc = window.electronAPI?.wcjs;
                if (!wc || !wc.available) {
                    openCustomPlayer();
                    return;
                }
                // Show container
                wcjsPlayerContainer.style.opacity = '1';
                wcjsPlayerContainer.style.pointerEvents = 'all';
                wcjsLoading.style.display = 'flex';
                wcjsPlayerTitle.textContent = playerTitle.textContent || 'WebChimera Player';

                // Init player and bind to canvas
                const ctx = wc.init('#wcjsCanvas', ["--no-video-title-show"]);
                if (!ctx || !ctx.player) {
                    showNotification('WebChimera failed to initialize, falling back to built-in player.');
                    closeWCJSPlayer();
                    openCustomPlayer();
                    return;
                }
                wcjsPlayer = ctx.player;
                // Start playback
                wcjsPlayer.play(currentStreamUrl);
                // Load pre-downloaded subtitle if available (from RD auto fetch)
                try {
                    if (currentSubtitleUrl && wcjsPlayer && wcjsPlayer.subtitles && wcjsPlayer.subtitles.load) {
                        wcjsPlayer.subtitles.load(currentSubtitleUrl);
                    }
                } catch(_) {}

                // Setup events and UI updates
                wcjsAttachEvents();
            } catch (e) {
                console.error('WCJS init error:', e);
                showNotification('WebChimera init error, using built-in player.');
                closeWCJSPlayer();
                openCustomPlayer();
            }
        }

        function wcjsAttachEvents() {
            if (!wcjsPlayer) return;
            // Length/time change handlers if available
            try { wcjsPlayer.onLengthChanged = (len) => { wcjsTotalTime.textContent = formatTime((len||0)/1000); }; } catch(_){}
            try { wcjsPlayer.onPlaying = () => { wcjsLoading.style.display = 'none'; wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i>'; }; } catch(_){}
            try { wcjsPlayer.onPaused = () => { wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; }; } catch(_){}
            try { wcjsPlayer.onEndReached = () => { wcjsPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; }; } catch(_){}

            // Poll time/length as a reliable way across versions
            clearInterval(wcjsTimer);
            wcjsTimer = setInterval(() => {
                if (!wcjsPlayer) return;
                let len = 0, t = 0;
                try { len = Number(wcjsPlayer.length || wcjsPlayer.input?.length || 0); } catch(_){}
                try { t = Number(wcjsPlayer.time || wcjsPlayer.input?.time || 0); } catch(_){}
                if (len > 0) wcjsTotalTime.textContent = formatTime(len/1000);
                wcjsCurrentTime.textContent = formatTime(t/1000);
                if (len > 0) {
                    const pct = Math.max(0, Math.min(100, (t/len) * 100));
                    wcjsProgressFilled.style.width = pct + '%';
                }
            }, 200);
            // Refresh audio list on play
            setTimeout(renderAudioTracks, 400);
        }

        async function closeWCJSPlayer() {
            wcjsPlayerContainer.style.opacity = '0';
            wcjsPlayerContainer.style.pointerEvents = 'none';
            wcjsLoading.style.display = 'none';
            clearInterval(wcjsTimer);
            wcjsTimer = null;
            
            // Exit video fullscreen if active
            if (document.fullscreenElement) {
                try {
                    await document.exitFullscreen();
                } catch(_) {}
            }
            
            // Also exit app fullscreen if the window is in fullscreen to prevent black screen
            if (window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success && result.isFullscreen) {
                        // Temporarily exit app fullscreen to prevent black screen
                        await window.electronAPI.setFullscreen(false);
                        // Show notification that user can re-enable fullscreen via settings
                        setTimeout(() => {
                            showNotification('Exited fullscreen mode. Re-enable in Settings if needed.', 'info', 4000);
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error handling fullscreen exit:', error);
                }
            }
            
            if (wcjsPlayer) {
                try { wcjsPlayer.stop(); } catch(_){}
                try { wcjsPlayer.close && wcjsPlayer.close(); } catch(_){}
            }
            wcjsPlayer = null;
            // Stop torrent stream on server and clean temp (same as MPV close)
            if (currentTorrentData) {
                try { await fetch(`${API_BASE_URL}/stop-stream?hash=${currentTorrentData.infoHash}`); } catch(e) {}
                if (window.electronAPI) {
                    try { await window.electronAPI.clearWebtorrentTemp(); } catch(e) {}
                }
            }
            // Cleanup downloaded temporary subtitles
            try { await fetch(`${API_BASE_URL}/subtitles/cleanup`, { method: 'POST' }); } catch(e) {}
        }

        function wcjsTogglePlayPause() {
            if (!wcjsPlayer) return;
            try { wcjsPlayer.togglePause(); } catch(_){}
        }

        function wcjsSkipTime(seconds) {
            if (!wcjsPlayer) return;
            try {
                const cur = Number(wcjsPlayer.time || 0);
                wcjsPlayer.time = Math.max(0, cur + seconds * 1000);
            } catch(_){}
        }

        function wcjsToggleFullscreen() {
            if (!document.fullscreenElement) {
                wcjsPlayerContainer.requestFullscreen?.();
            } else {
                document.exitFullscreen?.();
            }
        }

        function wcjsSeek(e) {
            if (!wcjsPlayer) return;
            const rect = wcjsProgressBar.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const pct = offsetX / rect.width;
            try {
                const len = Number(wcjsPlayer.length || 0);
                if (len > 0) wcjsPlayer.time = Math.floor(len * pct);
            } catch(_){}
        }

        function wcjsToggleMute() {
            if (!wcjsPlayer) return;
            try {
                if (typeof wcjsPlayer.toggleMute === 'function') wcjsPlayer.toggleMute();
                else wcjsPlayer.mute = !wcjsPlayer.mute;
                // Update icon
                const muted = !!wcjsPlayer.mute;
                wcjsMuteBtn.innerHTML = muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
            } catch(_){}
        }

        function wcjsSetVolume() {
            if (!wcjsPlayer) return;
            // wcjs volume is 0..200
            const v = Number(wcjsVolume.value || 0);
            try { wcjsPlayer.volume = Math.round(v * 2); } catch(_){}
        }

        async function wcjsHandleSubtitleUpload(event) {
            const file = event.target.files[0];
            if (!file || !wcjsPlayer) return;
            try {
                const text = await file.text();
                const formData = new FormData();
                formData.append('subtitle', new Blob([text]), file.name);
                const response = await fetch(`${API_BASE_URL}/upload-subtitle`, { method: 'POST', body: formData });
                const data = await response.json();
                if (!response.ok || !data?.url) {
                    showNotification(data?.error || 'Subtitle upload failed');
                    return;
                }
                try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(data.url); } catch(_){ }
                showNotification('Subtitles loaded');
            } catch (e) {
                showNotification('Failed to load subtitles');
            } finally {
                try { event.target.value = ''; } catch {}
            }
        }

        // Fetch and display subtitles from backend
        async function fetchAndRenderSubtitles() {
            wcjsSubsList.innerHTML = '<div class="subs-help"><i class="fas fa-spinner" style="animation: spin 1.4s cubic-bezier(0.65, 0, 0.35, 1) infinite;"></i> Loading...</div>';
            try {
                // Always prefer the selected show's TMDB id and media type
                let tmdbId = currentContent?.id;
                let type = currentMediaType === 'tv' ? 'tv' : 'movie';
                // For movies, if tmdbId is missing, derive it from the selected torrent filename
                if (type === 'movie' && (!tmdbId || tmdbId === '')) {
                    if (currentSelectedVideoName) {
                        try {
                            const derived = await getTmdbFromFilename(currentSelectedVideoName);
                            if (derived?.id) tmdbId = derived.id;
                        } catch(_) {}
                    }
                }
                const params = new URLSearchParams({ type });
                if (tmdbId) params.set('tmdbId', String(tmdbId));
                if (currentSelectedVideoName) {
                    params.set('filename', currentSelectedVideoName);
                    // Provide show title/year for better matching
                    const showTitle = currentContent?.title || currentContent?.name || '';
                    const showYear = (currentContent?.release_date || currentContent?.first_air_date || '').slice(0,4);
                    if (showTitle) params.set('title', showTitle);
                    if (showYear) params.set('year', showYear);
                } else if (type === 'tv' && currentSeason) {
                    params.set('season', String(currentSeason));
                }
                // Try to detect selected episode from episodesGrid selection
                const sel = document.querySelector('.episode-card.selected');
                if (!currentSelectedVideoName && type === 'tv' && sel) {
                    const titleEl = sel.querySelector('.episode-title');
                    const m = titleEl?.textContent?.match(/E(\d+)/i);
                    if (m) params.set('episode', String(parseInt(m[1], 10)));
                }
                const res = await fetch(`${API_BASE_URL}/subtitles?${params.toString()}`);
                const data = await res.json();
                const items = Array.isArray(data.subtitles) ? data.subtitles : [];
                // Group by language and index duplicates
                const grouped = {};
                for (const it of items) {
                    const key = `${(it.langName || it.lang || 'Unknown').toLowerCase()}|${it.source}`;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(it);
                }
                wcjsSubsList.innerHTML = '';
                const entries = Object.entries(grouped);
                if (!entries.length) wcjsSubsList.innerHTML = '<div class="subs-help">No subtitles found.</div>';
                for (const [key, arr] of entries) {
                    const [langNameLower, source] = key.split('|');
                    const langDisplay = langNameLower.charAt(0).toUpperCase() + langNameLower.slice(1);
                    arr.forEach((sub, idx) => {
                        const displayName = arr.length > 1 ? `${langDisplay} ${idx + 1}` : langDisplay;
                        const row = document.createElement('div');
                        row.className = 'subs-item';
                        row.innerHTML = `<div>${displayName} <span class="subs-source">(${source})</span></div><div class="subs-badge">Select</div>`;
                        row.addEventListener('click', async () => {
                            try {
                                // Download via backend to temp, then load into WCJS
                                const payload = sub.source === 'opensubtitles'
                                    ? { source: 'opensubtitles', fileId: sub.file_id, preferredName: sub.name }
                                    : { source: 'wyzie', url: sub.url, preferredName: sub.name };
                                const dl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                                const dlJson = await dl.json();
                                if (dl.ok && dlJson.url) {
                                    try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(dlJson.url); } catch(_){}
                                    showNotification(`Loaded: ${displayName}`);
                                    wcjsSubsPanel.style.display = 'none';
                                } else {
                                    if (dl.status === 429 || dlJson?.code === 'OS_QUOTA') {
                                        showNotification('OpenSubtitles is rate-limited. Trying Wyzie automatically...');
                                        // Try fallback to Wyzie: prefer same language, else any Wyzie
                                        const sameLangWyzie = currentSubtitles.find(s => s.source === 'wyzie' && s.lang && s.lang === (sub.lang || '').toLowerCase());
                                        const anyWyzie = currentSubtitles.find(s => s.source === 'wyzie');
                                        const wyziePick = sameLangWyzie || anyWyzie;
                                        if (wyziePick) {
                                            try {
                                                const wyPayload = { source: 'wyzie', url: wyziePick.url, preferredName: wyziePick.name || wyziePick.langName };
                                                const wyDl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(wyPayload) });
                                                const wyJson = await wyDl.json();
                                                if (wyDl.ok && wyJson.url) {
                                                    try { wcjsPlayer.subtitles && wcjsPlayer.subtitles.load && wcjsPlayer.subtitles.load(wyJson.url); } catch(_){}
                                                    showNotification(`Loaded from Wyzie: ${wyziePick.name || wyziePick.langName}`);
                                                    wcjsSubsPanel.style.display = 'none';
                                                } else {
                                                    showNotification(wyJson.error || 'Wyzie fallback failed. Please pick a different subtitle.');
                                                }
                                            } catch (e) {
                                                showNotification('Wyzie fallback failed. Please pick a different subtitle.');
                                            }
                                        } else {
                                            showNotification('No Wyzie subtitles available. Please try another source later.');
                                        }
                                    } else {
                                        showNotification(dlJson.error || 'Subtitle download failed');
                                    }
                                }
                            } catch (e) {
                                showNotification('Subtitle download error');
                            }
                        });
                        wcjsSubsList.appendChild(row);
                    });
                }
            } catch {
                wcjsSubsList.innerHTML = '<div class="subs-help">Failed to load subtitles.</div>';
            }
        }

        // Render audio tracks and allow switching
        function renderAudioTracks() {
            wcjsAudioList.innerHTML = '';
            if (!wcjsPlayer || !wcjsPlayer.audio) {
                wcjsAudioList.innerHTML = '<div class="subs-help">Audio track info not available.</div>';
                return;
            }
            try {
                const count = Number(wcjsPlayer.audio.count || 0);
                if (!count) {
                    wcjsAudioList.innerHTML = '<div class="subs-help">No alternate audio tracks.</div>';
                    return;
                }
                for (let i = 1; i <= count; i++) {
                    const name = wcjsPlayer.audio[i] || `Track ${i}`;
                    const row = document.createElement('div');
                    row.className = 'subs-item';
                    row.innerHTML = `<div>${name}</div><div class="subs-badge">Select</div>`;
                    row.addEventListener('click', () => {
                        try { wcjsPlayer.audio.track = i; showNotification(`Audio: ${name}`); wcjsAudioPanel.style.display = 'none'; } catch(_){}
                    });
                    wcjsAudioList.appendChild(row);
                }
            } catch {
                wcjsAudioList.innerHTML = '<div class="subs-help">Audio list unavailable.</div>';
            }
        }

        async function closeCustomPlayer_() {
            // Stop Trakt scrobbling when player closes
            if (customVideo.duration && traktCurrentScrobble) {
                const progress = customVideo.currentTime / customVideo.duration * 100;
                scrobbleStop(Math.floor(progress));
            }
            
            // Clear Discord presence when custom player closes
            if (discordStreamingActive) {
                clearDiscordPresence();
            }
            
            customPlayerContainer.classList.remove('active');
            customPlayerContainer.style.display = 'none'; // Fully hide to prevent invisible overlay
            try { customVideo.pause(); } catch(_) {}
            
            // Exit video fullscreen if active
            if (document.fullscreenElement) {
                try {
                    await document.exitFullscreen();
                } catch(_) {}
            }
            
            // Also exit app fullscreen if the window is in fullscreen to prevent black screen
            if (window.electronAPI && window.electronAPI.getFullscreen) {
                try {
                    const result = await window.electronAPI.getFullscreen();
                    if (result.success && result.isFullscreen) {
                        // Temporarily exit app fullscreen to prevent black screen
                        await window.electronAPI.setFullscreen(false);
                        // Show notification that user can re-enable fullscreen via settings
                        setTimeout(() => {
                            showNotification('Exited fullscreen mode. Re-enable in Settings if needed.', 'info', 4000);
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error handling fullscreen exit:', error);
                }
            }
            
            // Cleanup HLS instance if any
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }
            
            // Fully reset video source to clear any residual tracks/cues
            try {
                customVideo.removeAttribute('src');
                if (videoSource) videoSource.setAttribute('src', '');
                customVideo.load();
            } catch(_) {}
            
            // Cleanup temp subtitle file for HTML5 if any
            if (currentSubtitleFile) {
                try { await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
                currentSubtitleFile = null;
            }
        }

        function togglePlayPause() {
            if (customVideo.paused) {
                customVideo.play();
            } else {
                customVideo.pause();
            }
        }

        function skipTime(amount) {
            customVideo.currentTime += amount;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                customPlayerContainer.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        async function castToChromecast() {
            // Use the same backend casting as MPV button
            if (!currentStreamUrl) {
                showNotification('No stream available to cast', 'error');
                return;
            }
            
            // Show device picker modal (same as MPV casting)
            await showChromecastDevicePicker();
        }

        // Deprecated: Old Web SDK method (kept for reference but not used in Electron)
        function loadMediaToCast() {
            const castSession = window.cast.framework.CastContext.getInstance().getCurrentSession();
            if (!castSession) {
                showNotification('No active Chromecast session', 'error');
                return;
            }

            // Prepare media info
            const mediaInfo = new window.chrome.cast.media.MediaInfo(currentStreamUrl, 'video/mp4');
            
            // Set metadata
            const metadata = new window.chrome.cast.media.GenericMediaMetadata();
            if (currentContent) {
                metadata.title = currentContent.title || currentContent.name || 'Unknown';
                if (currentContent.poster_path) {
                    metadata.images = [new window.chrome.cast.Image(`https://image.tmdb.org/t/p/w342${currentContent.poster_path}`)];
                }
            }
            mediaInfo.metadata = metadata;

            const request = new window.chrome.cast.media.LoadRequest(mediaInfo);
            
            // Set current playback position if playing from custom player
            if (customVideo && !customVideo.paused) {
                request.currentTime = customVideo.currentTime;
                // Pause local player
                customVideo.pause();
            }

            castSession.loadMedia(request).then(
                () => {
                    showNotification('Casting to ' + castSession.getCastDevice().friendlyName, 'success');
                },
                (error) => {
                    console.error('Load media error:', error);
                    showNotification('Failed to cast media: ' + error.message, 'error');
                }
            );
        }

        async function castMPVToChromecast() {
            if (!currentStreamUrl) {
                showNotification('No stream available to cast', 'error');
                return;
            }
            
            // Show device picker modal
            await showChromecastDevicePicker();
        }

        async function showChromecastDevicePicker() {
            const modal = document.getElementById('chromecast-device-modal');
            const deviceList = document.getElementById('chromecast-device-list');
            
            if (!modal || !deviceList) {
                console.error('[Chromecast] Modal elements not found');
                showNotification('Device picker not available', 'error');
                return;
            }
            
            // Show modal with loading state
            modal.style.display = 'flex';
            modal.classList.add('active');
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'all';
            
            deviceList.innerHTML = `
                <div class="loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Discovering Chromecast devices...</p>
                </div>
            `;
            
            try {
                // Discover devices
                const result = await window.electronAPI.discoverChromecastDevices();
                
                if (!result.success || result.devices.length === 0) {
                    deviceList.innerHTML = `
                        <div class="chromecast-no-devices">
                            <i class="fas fa-broadcast-tower"></i>
                            <h4>No Chromecast Devices Found</h4>
                            <p>Make sure your Chromecast is on the same network</p>
                            <button class="chromecast-refresh-btn" onclick="showChromecastDevicePicker()">
                                <i class="fas fa-sync"></i> Refresh
                            </button>
                        </div>
                    `;
                    return;
                }
                
                // Display devices
                deviceList.innerHTML = '';
                result.devices.forEach(device => {
                    const deviceItem = document.createElement('div');
                    deviceItem.className = 'chromecast-device-item';
                    deviceItem.innerHTML = `
                        <div class="chromecast-device-icon">
                            <i class="fas fa-tv"></i>
                        </div>
                        <div class="chromecast-device-info">
                            <div class="chromecast-device-name">${escapeHtml(device.name)}</div>
                            <div class="chromecast-device-host">${escapeHtml(device.host)}</div>
                        </div>
                    `;
                    
                    deviceItem.addEventListener('click', () => {
                        castToDevice(device);
                    });
                    
                    deviceList.appendChild(deviceItem);
                });
                
            } catch (error) {
                console.error('Device discovery error:', error);
                deviceList.innerHTML = `
                    <div class="chromecast-no-devices">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h4>Discovery Failed</h4>
                        <p>${escapeHtml(error.message || 'Failed to discover devices')}</p>
                        <button class="chromecast-refresh-btn" onclick="showChromecastDevicePicker()">
                            <i class="fas fa-sync"></i> Try Again
                        </button>
                    </div>
                `;
            }
        }

        async function castToDevice(device) {
            const modal = document.getElementById('chromecast-device-modal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.remove('active');
                modal.style.opacity = '0';
                modal.style.pointerEvents = 'none';
            }
            
            try {
                // Just send the URL as-is - main.js will handle proxying through network IP
                let toCast = currentStreamUrl;
                if (!toCast) {
                    showNotification('No stream available to cast', 'error');
                    return;
                }

                // Prepare metadata for Chromecast
                const metadata = {
                    title: 'PlayTorrio Stream',
                    // Guess content type from original URL
                    contentType: (toCast.includes('.m3u8') ? 'application/vnd.apple.mpegurl' : 'video/mp4'),
                    images: []
                };
                
                // Use currentContent if available
                if (currentContent) {
                    metadata.title = currentContent.title || currentContent.name || 'PlayTorrio Stream';
                    
                    if (currentContent.poster_path) {
                        metadata.images = [{
                            url: `https://image.tmdb.org/t/p/w342${currentContent.poster_path}`
                        }];
                    }
                }
                
                console.log('[Cast] Sending stream URL to main process:', toCast);
                
                showNotification(`Connecting to ${device.name}...`, 'info');
                
                const result = await window.electronAPI.castToChromecast({
                    streamUrl: toCast,
                    metadata: metadata,
                    deviceHost: device.host
                });
                
                if (result.success) {
                    showNotification(`Casting to ${device.name}`, 'success');
                } else {
                    showNotification(result.message, 'error');
                }
            } catch (error) {
                console.error('Cast error:', error);
                showNotification('Failed to cast: ' + error.message, 'error');
            }
        }

        function updateProgress() {
            const percent = (customVideo.currentTime / customVideo.duration) * 100;
            progressFilled.style.width = `${percent}%`;
            currentTime.textContent = formatTime(customVideo.currentTime);
            saveResumeThrottled();
        }

        function updateDuration() {
            totalTime.textContent = formatTime(customVideo.duration);
            saveResumeThrottled();
        }

        function seekVideo(e) {
            const rect = progressBar.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const seekTime = (offsetX / progressBar.offsetWidth) * customVideo.duration;
            customVideo.currentTime = seekTime;
            saveResumeThrottled(true);
        }

        function formatTime(seconds) {
            if (!isFinite(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${String(secs).padStart(2, '0')}`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function handleSubtitleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            try {
                const text = await file.text();
                const formData = new FormData();
                formData.append('subtitle', new Blob([text]), file.name);
                const response = await fetch(`${API_BASE_URL}/upload-subtitle`, { method: 'POST', body: formData });
                const data = await response.json();
                if (!response.ok || !data?.url) {
                    showNotification(data?.error || 'Subtitle upload failed');
                    return;
                }
                // Delete previous temp file if any
                if (currentSubtitleFile) {
                    try { await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) }); } catch {}
                }
                await loadSubtitle(data.url, { label: file.name.replace(/\.[^.]+$/, ''), lang: 'en' });
                showNotification('Subtitles loaded');
            } catch (_) {
                showNotification('Failed to load subtitles');
            } finally {
                try { event.target.value = ''; } catch {}
            }
        }

        function updateSubtitleControlDisplays() {
            if (subsSizeValue) subsSizeValue.textContent = `${subtitleSettings.size}px`;
            if (subsOpacityValue) subsOpacityValue.textContent = `${subtitleSettings.backgroundOpacity}%`;
            if (subsSizeInput) subsSizeInput.value = subtitleSettings.size;
            if (subsColorInput) subsColorInput.value = subtitleSettings.color;
            if (subsBackgroundInput) subsBackgroundInput.value = subtitleSettings.background;
            if (subsBackgroundOpacityInput) subsBackgroundOpacityInput.value = subtitleSettings.backgroundOpacity;
            if (subsFontSelect) subsFontSelect.value = subtitleSettings.font;
        }

        function applySubtitleSettings() {
            // Apply styles to Video.js subtitle display
            let styleEl = document.getElementById('subtitle-cue-style');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'subtitle-cue-style';
                document.head.appendChild(styleEl);
            }
            
            // Convert hex color to rgba for background
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };
            
            const bgColor = hexToRgba(subtitleSettings.background, subtitleSettings.backgroundOpacity / 100);
            
            // Apply to Video.js text track display and native cues with fixed position
            styleEl.textContent = `
                .video-js .vjs-text-track-display {
                    bottom: 3em !important;
                    pointer-events: none !important;
                }
                
                .video-js .vjs-text-track-cue > div {
                    font-size: ${subtitleSettings.size}px !important;
                    color: ${subtitleSettings.color} !important;
                    background-color: ${bgColor} !important;
                    font-family: ${subtitleSettings.font} !important;
                    padding: 0.2em 0.5em !important;
                    border-radius: 4px !important;
                    pointer-events: auto !important;
                }
                
                video::cue {
                    font-size: ${subtitleSettings.size}px !important;
                    color: ${subtitleSettings.color} !important;
                    background-color: ${bgColor} !important;
                    font-family: ${subtitleSettings.font} !important;
                }
            `;
        }

        // Helper to preserve subtitle tracks across video loads
        function preserveSubtitleTracks() {
            const tracks = Array.from(customVideo.querySelectorAll('track[kind="subtitles"]'));
            return tracks.map(t => ({
                src: t.src,
                label: t.label,
                srclang: t.srclang,
                isDefault: t.default,
                mode: t.track ? t.track.mode : 'hidden'
            }));
        }

        function restoreSubtitleTracks(trackData) {
            if (!trackData || trackData.length === 0) return;
            
            trackData.forEach((data, index) => {
                const track = document.createElement('track');
                track.kind = 'subtitles';
                track.label = data.label;
                track.srclang = data.srclang;
                track.src = data.src;
                if (data.isDefault) {
                    track.default = true;
                    track.setAttribute('default', '');
                }
                customVideo.appendChild(track);
                
                // Restore the mode when track loads
                track.addEventListener('load', () => {
                    try {
                        if (track.track) {
                            track.track.mode = data.mode;
                            if (data.mode === 'showing') {
                                applySubtitleSettings();
                                subtitleTrack = track;
                            }
                        }
                    } catch {}
                }, { once: true });
            });
        }

        async function loadSubtitle(url, opts = {}) {
            // Check if this subtitle URL is already loaded
            const existingTracks = Array.from(customVideo.querySelectorAll('track[kind="subtitles"]'));
            const alreadyLoaded = existingTracks.find(t => t.src === url);
            
            if (alreadyLoaded) {
                // Just switch to the existing track
                for (const t of customVideo.textTracks) { t.mode = 'hidden'; }
                if (alreadyLoaded.track) {
                    alreadyLoaded.track.mode = 'showing';
                    applySubtitleSettings();
                }
                subtitleTrack = alreadyLoaded;
                return;
            }

            // Only remove tracks if we're loading a completely new subtitle
            // Keep the current track to avoid it disappearing
            if (subtitleTrack && subtitleTrack.src !== url) {
                // Don't remove the current track yet, just hide it
                if (subtitleTrack.track) {
                    subtitleTrack.track.mode = 'hidden';
                }
            }

            const track = document.createElement('track');
            track.kind = 'subtitles';
            track.label = opts.label || 'Subtitles';
            track.srclang = (opts.lang || 'en');
            track.src = url;
            track.default = true;
            track.setAttribute('default', '');
            customVideo.appendChild(track);
            // Wait for track to load then enable showing
            track.addEventListener('load', () => {
                try {
                    // Hide all other tracks then show current
                    for (const t of customVideo.textTracks) { t.mode = 'hidden'; }
                    if (track.track) track.track.mode = 'showing';
                    applySubtitleSettings();
                } catch {}
            });
            subtitleTrack = track;
            // Track the served filename so we can delete it when switching
            try {
                const u = new URL(url, window.location.origin);
                const parts = u.pathname.split('/');
                const fname = parts[parts.length - 1];
                currentSubtitleFile = decodeURIComponent(fname);
            } catch {}
        }

        async function fetchAndRenderHtmlSubs() {
            htmlSubsList.innerHTML = '<div class="subs-help"><i class="fas fa-spinner" style="animation: spin 1.4s cubic-bezier(0.65, 0, 0.35, 1) infinite;"></i> Loading...</div>';
            try {
                // Always use the selected show's TMDB id and type from UI
                let tmdbId = currentContent?.id;
                let type = currentMediaType === 'tv' ? 'tv' : 'movie';
                const title = currentContent?.title || currentContent?.name || '';
                const year = (currentContent?.release_date || currentContent?.first_air_date || '').slice(0,4);
                // For movies, if tmdbId is missing, derive it from the selected torrent filename
                if (type === 'movie' && (!tmdbId || tmdbId === '')) {
                    if (currentSelectedVideoName) {
                        try {
                            const derived = await getTmdbFromFilename(currentSelectedVideoName);
                            if (derived?.id) tmdbId = derived.id;
                        } catch(_) {}
                    }
                }
                const params = new URLSearchParams({ type });
                if (tmdbId) params.set('tmdbId', String(tmdbId));
                if (title) params.set('title', title);
                if (year) params.set('year', year);
                if (currentSelectedVideoName) {
                    params.set('filename', currentSelectedVideoName);
                    // title/year already represent the selected show
                }
                if (type === 'tv' && currentSeason) params.set('season', String(currentSeason));
                const sel = document.querySelector('.episode-card.selected');
                if (!currentSelectedVideoName && type === 'tv' && sel) {
                    const titleEl = sel.querySelector('.episode-title');
                    const m = titleEl?.textContent?.match(/E(\d+)/i);
                    if (m) params.set('episode', String(parseInt(m[1], 10)));
                }
                const res = await fetch(`${API_BASE_URL}/subtitles?${params.toString()}`);
                const data = await res.json();
                let items = Array.isArray(data.subtitles) ? data.subtitles : [];
                // Extra safety: filter client-side for supported formats only
                items = items.filter(it => {
                    const ext = (it.ext || it.format || '').toString().toLowerCase();
                    const u = (it.url || '').toString().toLowerCase();
                    return ['srt','vtt'].includes(ext) || u.includes('.srt') || u.includes('.vtt') || u.includes('.srt.gz') || it.file_id; // OS entries will be converted server-side
                });
                const grouped = {};
                for (const it of items) {
                    const key = `${(it.langName || it.lang || 'Unknown').toLowerCase()}|${it.source}`;
                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(it);
                }
                htmlSubsList.innerHTML = '';
                const entries = Object.entries(grouped);
                if (!entries.length) htmlSubsList.innerHTML = '<div class="subs-help">No subtitles found.</div>';
                for (const [key, arr] of entries) {
                    const [langNameLower, source] = key.split('|');
                    const langDisplay = langNameLower.charAt(0).toUpperCase() + langNameLower.slice(1);
                    arr.forEach((sub, idx) => {
                        const displayName = arr.length > 1 ? `${langDisplay} ${idx + 1}` : langDisplay;
                        const row = document.createElement('div');
                        row.className = 'subs-item';
                        row.innerHTML = `<div>${displayName} <span class="subs-source">(${source})</span></div><div class="subs-badge">Select</div>`;
                        row.addEventListener('click', async () => {
                            try {
                                const payload = sub.source === 'opensubtitles'
                                    ? { source: 'opensubtitles', fileId: sub.file_id, preferredName: sub.name }
                                    : { source: 'wyzie', url: sub.url, preferredName: sub.name };
                                const dl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                                const dlJson = await dl.json();
                                if (dl.ok && dlJson.url) {
                                    // Delete old subtitle temp file (if any)
                                    if (currentSubtitleFile) {
                                        try {
                                            await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) });
                                        } catch {}
                                    }
                                    const langCode = (sub.lang || '').toLowerCase();
                                    await loadSubtitle(dlJson.url, { label: displayName, lang: langCode });
                                    showNotification(`Loaded: ${displayName}`);
                                    htmlSubsPanel.style.display = 'none';
                                } else {
                                    if (dl.status === 429 || dlJson?.code === 'OS_QUOTA') {
                                        showNotification('OpenSubtitles is rate-limited. Trying Wyzie automatically...');
                                        const sameLangWyzie = currentSubtitles.find(s => s.source === 'wyzie' && s.lang && s.lang === (sub.lang || '').toLowerCase());
                                        const anyWyzie = currentSubtitles.find(s => s.source === 'wyzie');
                                        const wyziePick = sameLangWyzie || anyWyzie;
                                        if (wyziePick) {
                                            try {
                                                // Delete old subtitle temp file (if any)
                                                if (currentSubtitleFile) {
                                                    try {
                                                        await fetch(`${API_BASE_URL}/subtitles/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: currentSubtitleFile }) });
                                                    } catch {}
                                                }
                                                const wyPayload = { source: 'wyzie', url: wyziePick.url, preferredName: wyziePick.name || wyziePick.langName };
                                                const wyDl = await fetch(`${API_BASE_URL}/subtitles/download`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(wyPayload) });
                                                const wyJson = await wyDl.json();
                                                if (wyDl.ok && wyJson.url) {
                                                    const langCode = (wyziePick.lang || '').toLowerCase();
                                                    await loadSubtitle(wyJson.url, { label: wyziePick.name || wyziePick.langName, lang: langCode });
                                                    showNotification(`Loaded from Wyzie: ${wyziePick.name || wyziePick.langName}`);
                                                    htmlSubsPanel.style.display = 'none';
                                                } else {
                                                    showNotification(wyJson.error || 'Wyzie fallback failed. Please pick a different subtitle.');
                                                }
                                            } catch (e) {
                                                showNotification('Wyzie fallback failed. Please pick a different subtitle.');
                                            }
                                        } else {
                                            showNotification('No Wyzie subtitles available. Please try another source later.');
                                        }
                                    } else {
                                        showNotification(dlJson.error || 'Subtitle download failed');
                                    }
                                }
                            } catch (e) {
                                showNotification('Subtitle download error');
                            }
                        });
                        htmlSubsList.appendChild(row);
                    });
                }
            } catch {
                htmlSubsList.innerHTML = '<div class="subs-help">Failed to load subtitles.</div>';
            }
        }

        // ---- AudioBooks functionality ----
        function initializeAudioBooks() {
            const searchInput = document.getElementById('audiobookSearchInput');
            const searchBtn = document.getElementById('searchAudioBooksBtn');
            const clearBtn = document.getElementById('clearAudioBookSearchBtn');
            const backToBooks = document.getElementById('audiobooksBackToBooks');
            const closePlayer = document.getElementById('audiobooksClosePlayer');
            const playPauseBtn = document.getElementById('audiobooksPlayPauseBtn');
            const prevBtn = document.getElementById('audiobooksPrevBtn');
            const nextBtn = document.getElementById('audiobooksNextBtn');
            const progressBar = document.getElementById('audiobooksProgressBar');
            const volumeBtn = document.getElementById('audiobooksVolumeBtn');
            const volumeSlider = document.getElementById('audiobooksVolumeSlider');
            const audioEl = document.getElementById('audiobooksAudioElement');
            const playbackSpeed = document.getElementById('audiobooksPlaybackSpeed');

            if (!searchInput || !searchBtn || !clearBtn) return;

            // Search on button click
            searchBtn.addEventListener('click', () => {
                const query = searchInput.value.trim();
                if (query) {
                    searchAudioBooks(query);
                }
            });

            // Search on Enter key
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = searchInput.value.trim();
                    if (query) {
                        searchAudioBooks(query);
                    }
                }
            });

            // Clear search and return to home
            clearBtn.addEventListener('click', () => {
                searchInput.value = '';
                isAudioBookSearchMode = false;
                clearBtn.style.display = 'none';
                loadInitialAudioBooks();
            });

            // Back to books button
            if (backToBooks) {
                backToBooks.addEventListener('click', () => {
                    document.getElementById('audiobooks-books-view').style.display = 'block';
                    document.getElementById('audiobooks-chapters-view').style.display = 'none';
                });
            }

            // Close player
            if (closePlayer && audioEl) {
                closePlayer.addEventListener('click', () => {
                    audioEl.pause();
                    document.getElementById('audiobooksPlayer').style.display = 'none';
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                });
            }

            // Play/Pause
            if (playPauseBtn && audioEl) {
                playPauseBtn.addEventListener('click', () => {
                    if (audioEl.paused) {
                        audioEl.play();
                        playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        audioEl.pause();
                        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
            }

            // Previous chapter
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (currentAudioBookChapterIndex > 0) {
                        playAudioBookChapter(currentAudioBookChapterIndex - 1);
                    }
                });
            }

            // Next chapter
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentAudioBookChapterIndex < currentAudioBookChapters.length - 1) {
                        playAudioBookChapter(currentAudioBookChapterIndex + 1);
                    }
                });
            }

            // Progress bar
            if (audioEl && progressBar) {
                audioEl.addEventListener('timeupdate', () => {
                    const percent = (audioEl.currentTime / audioEl.duration) * 100;
                    document.getElementById('audiobooksProgressFilled').style.width = percent + '%';
                    document.getElementById('audiobooksCurrentTime').textContent = formatAudioTime(audioEl.currentTime);
                });

                audioEl.addEventListener('loadedmetadata', () => {
                    document.getElementById('audiobooksDuration').textContent = formatAudioTime(audioEl.duration);
                });

                progressBar.addEventListener('click', (e) => {
                    const rect = progressBar.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    audioEl.currentTime = percent * audioEl.duration;
                });

                // Auto-play next chapter
                audioEl.addEventListener('ended', () => {
                    if (currentAudioBookChapterIndex < currentAudioBookChapters.length - 1) {
                        playAudioBookChapter(currentAudioBookChapterIndex + 1);
                    } else {
                        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
            }

            // Volume control
            if (volumeSlider && audioEl && volumeBtn) {
                volumeSlider.addEventListener('input', (e) => {
                    audioEl.volume = e.target.value / 100;
                    if (audioEl.volume === 0) {
                        volumeBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                    } else if (audioEl.volume < 0.5) {
                        volumeBtn.innerHTML = '<i class="fas fa-volume-down"></i>';
                    } else {
                        volumeBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                    }
                });

                volumeBtn.addEventListener('click', () => {
                    if (audioEl.volume > 0) {
                        audioEl.volume = 0;
                        volumeSlider.value = 0;
                        volumeBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                    } else {
                        audioEl.volume = 1;
                        volumeSlider.value = 100;
                        volumeBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                    }
                });
            }

            // Playback speed
            if (playbackSpeed && audioEl) {
                playbackSpeed.addEventListener('change', (e) => {
                    audioEl.playbackRate = parseFloat(e.target.value);
                });
            }

            // Load More button
            const loadMoreBtn = document.getElementById('audiobookLoadMoreBtn');
            if (loadMoreBtn) {
                loadMoreBtn.addEventListener('click', loadMoreAudioBooks);
            }
        }

        // ---- BookTorrio functionality ----
        async function initializeBookTorrio() {
            const searchInput = document.getElementById('bookSearchInput');
            const searchBtn = document.getElementById('searchBooksBtn');
            const resultsContainer = document.getElementById('bookSearchResults');
            const loadingDiv = document.getElementById('bookSearchLoading');
            const searchTabBtn = document.getElementById('searchTabBtn');
            const libraryTabBtn = document.getElementById('libraryTabBtn');
            const searchTab = document.getElementById('searchTab');
            const libraryTab = document.getElementById('libraryTab');

            if (!searchInput || !searchBtn || !resultsContainer || !loadingDiv) return;

            // Show EPUB folder location to user
            try {
                const folderResult = await window.electronAPI.getEpubFolder();
                if (folderResult.success) {
                    console.log('EPUB books will be downloaded to:', folderResult.path);
                    // You could add a small info message on the page if needed
                }
            } catch (error) {
                console.warn('Could not get EPUB folder path:', error);
            }

            // Tab switching functionality
            if (searchTabBtn && libraryTabBtn && searchTab && libraryTab) {
                searchTabBtn.addEventListener('click', () => {
                    searchTabBtn.classList.add('active');
                    libraryTabBtn.classList.remove('active');
                    searchTab.style.display = 'block';
                    libraryTab.style.display = 'none';
                });

                libraryTabBtn.addEventListener('click', () => {
                    libraryTabBtn.classList.add('active');
                    searchTabBtn.classList.remove('active');
                    libraryTab.style.display = 'block';
                    searchTab.style.display = 'none';
                    // Load library when tab is opened
                    loadEpubLibrary();
                });
            }

            // Load EPUB library function
            async function loadEpubLibrary() {
                try {
                    const result = await window.electronAPI.getEpubLibrary();
                    const libraryContent = document.getElementById('libraryTab');
                    
                    if (result.success && result.books.length > 0) {
                        libraryContent.innerHTML = `
                            <div class="books-grid">
                                ${result.books.map(book => `
                                    <div class="book-card">
                                        <img src="${book.coverUrl || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDZiNmQ0Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkJvb2s8L3RleHQ+PC9zdmc+'}"
                                             alt="${book.title}"
                                             class="book-cover"
                                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMDZiNmQ0Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkJvb2s8L3RleHQ+PC9zdmc+'">
                                        <div class="book-title">${book.title}</div>
                                        <div class="book-author">${Array.isArray(book.author) ? book.author.join(', ') : (book.author || '')}</div>
                                        <div class="book-details">
                                            <span class="book-tag"><i class="fas fa-file"></i> EPUB</span>
                                            ${book.fileSize ? `<span class="book-tag"><i class=\"fas fa-hdd\"></i> ${formatFileSize(book.fileSize)}</span>` : ''}
                                        </div>
                                        <button class="read-btn" data-local-path="${book.localPath}" data-title="${book.title}">
                                            <i class="fas fa-book-open"></i>
                                            Read
                                        </button>
                                    </div>
                                `).join('')}
                            </div>
                        `;
                        libraryContent.querySelectorAll('.read-btn').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const p = btn.getAttribute('data-local-path');
                                const t = btn.getAttribute('data-title');
                                openEpubReader(p, t);
                            });
                        });
                    } else {
                        libraryContent.innerHTML = `
                            <div class="search-placeholder">
                                <i class="fas fa-bookmark" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                                <h3>No Books in Library</h3>
                                <p>Downloaded EPUB books will appear here. Search and download some books to get started!</p>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error loading library:', error);
                    const libraryContent = document.getElementById('libraryTab');
                    libraryContent.innerHTML = `
                        <div class="search-placeholder">
                            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #dc3545; margin-bottom: 1rem;"></i>
                            <h3>Error Loading Library</h3>
                            <p>Could not load your EPUB library. Please try again.</p>
                        </div>
                    `;
                }
            }

            // Search function
            async function searchBooks(query) {
                if (!query.trim()) return;

                try {
                    loadingDiv.style.display = 'block';
                    resultsContainer.innerHTML = '';

                    const response = await fetch(`http://localhost:6987/otherbook/api/search/${encodeURIComponent(query)}`);
                    if (!response.ok) {
                        throw new Error('Search failed');
                    }

                    const data = await response.json();
                    loadingDiv.style.display = 'none';

                    if (data.books && data.books.length > 0) {
                        // Filter to show only EPUB files
                        const epubBooks = data.books.filter(book => 
                            book.fileExtension && book.fileExtension.toLowerCase() === 'epub'
                        );

                        if (epubBooks.length === 0) {
                            resultsContainer.innerHTML = `
                                <div class="search-placeholder">
                                    <i class="fas fa-file-alt" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                                    <h3>No EPUB Books Found</h3>
                                    <p>No EPUB books found for "${query}". Try a different search term.</p>
                                </div>
                            `;
                            return;
                        }

                        resultsContainer.innerHTML = epubBooks.map(book => `
                            <div class="book-card">
                                <div class="book-title">${book.title}</div>
                                <div class="book-author">${Array.isArray(book.author) ? book.author.join(', ') : book.author}</div>
                                <div class="book-details">
                                    <span class="book-tag"><i class="fas fa-calendar"></i> ${book.year}</span>
                                    <span class="book-tag"><i class="fas fa-language"></i> ${book.language}</span>
                                    <span class="book-tag ${book.fileExtension && book.fileExtension.toLowerCase() === 'epub' ? 'epub-highlight' : ''}">
                                        <i class="fas fa-file"></i> ${book.fileExtension ? book.fileExtension.toUpperCase() : 'Unknown'}
                                    </span>
                                    <span class="book-tag"><i class="fas fa-hdd"></i> ${formatFileSize(book.fileSize)}</span>
                                </div>
                                <button class="download-btn" 
                                        data-download-url="${book.downloadlink}"
                                        data-book="${encodeURIComponent(JSON.stringify(book))}">
                                    <i class="fas fa-download"></i>
                                    Download Now
                                </button>
                            </div>
                        `).join('');

                        // Wire click handlers after rendering to avoid inline JS and quoting issues
                        const downloadButtons = resultsContainer.querySelectorAll('.download-btn');
                        downloadButtons.forEach(btn => {
                            btn.addEventListener('click', () => {
                                const url = btn.getAttribute('data-download-url');
                                const encoded = btn.getAttribute('data-book');
                                let bookObj = {};
                                try {
                                    bookObj = JSON.parse(decodeURIComponent(encoded));
                                } catch (e) {
                                    console.warn('Failed to parse book data from button:', e);
                                }
                                if (!url) {
                                    alert('No download URL available for this book.');
                                    return;
                                }
                                window.downloadBook(url, bookObj);
                            });
                        });
                    } else {
                        resultsContainer.innerHTML = `
                            <div class="search-placeholder">
                                <i class="fas fa-search" style="font-size: 3rem; color: #06b6d4; margin-bottom: 1rem;"></i>
                                <h3>No Books Found</h3>
                                <p>No books found for "${query}". Try a different search term.</p>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Search error:', error);
                    loadingDiv.style.display = 'none';
                    resultsContainer.innerHTML = `
                        <div class="search-placeholder">
                            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #dc3545; margin-bottom: 1rem;"></i>
                            <h3>Search Error</h3>
                            <p>Failed to search for books. Make sure the RandomBook server is running on port 5000.</p>
                        </div>
                    `;
                }
            }

            // Format file size helper
            function formatFileSize(bytes) {
                if (!bytes) return 'Unknown';
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
            }

            // Download book function
            window.downloadBook = async function(downloadUrl, bookData) {
                console.log('downloadBook called with:', downloadUrl, bookData);
                
                if (downloadUrl && bookData) {
                    try {
                        console.log('Calling electronAPI.downloadEpub...');
                        // Get EPUB folder path and prepare download
                        const result = await window.electronAPI.downloadEpub({
                            url: downloadUrl,
                            bookData: bookData
                        });
                        
                        console.log('Download result:', result);
                        
                        if (result.success) {
                            // Show download modal
                            console.log('Showing download modal...');
                            showDownloadModal(result);
                        } else {
                            alert('Error preparing download: ' + result.message);
                        }
                    } catch (error) {
                        console.error('Download error:', error);
                        alert('Error preparing download. Please try again.');
                    }
                } else {
                    console.error('Invalid parameters:', { downloadUrl, bookData });
                    alert('Invalid download link or book data.');
                }
            };

            // Modal functions
            let currentDownload = null;

            function showDownloadModal(downloadInfo) {
                const modal = document.getElementById('epubDownloadModal');
                const pathText = document.getElementById('epubDownloadPath');
                
                // Store download info for modal functions
                currentDownload = downloadInfo;
                
                // Show only the folder path per user preference
                pathText.textContent = downloadInfo.folder;
                modal.style.display = 'flex';
            }

            function closeEpubDownloadModal() {
                const modal = document.getElementById('epubDownloadModal');
                modal.style.display = 'none';
                currentDownload = null;
            }

            function copyEpubPath() {
                if (currentDownload) {
                    // Copy only the folder path per user preference
                    navigator.clipboard.writeText(currentDownload.folder).then(() => {
                        // Show feedback
                        const button = document.querySelector('.copy-path-btn');
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        button.style.background = '#059669';
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = '';
                        }, 2000);
                    });
                }
            }

            function openDownloadLink() {
                if (currentDownload && currentDownload.url) {
                    // Use electron shell to open URL in default browser
                    if (window.electronAPI && window.electronAPI.openExternal) {
                        window.electronAPI.openExternal(currentDownload.url);
                    } else {
                        // Fallback
                        window.open(currentDownload.url, '_blank');
                    }
                }
            }

            // Make functions globally available
            window.closeEpubDownloadModal = closeEpubDownloadModal;
            window.copyEpubPath = copyEpubPath;
            window.openDownloadLink = openDownloadLink;

            // Event listeners
            searchBtn.addEventListener('click', () => {
                const query = searchInput.value.trim();
                if (query) {
                    searchBooks(query);
                }
            });

            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = searchInput.value.trim();
                    if (query) {
                        searchBooks(query);
                    }
                }
            });
        }

        // ---- Anime functionality ----
        let animeList = [];
        let currentAnime = null;
        let animeOffset = 0;
        let animeIsLoading = false;
        let animeHasMore = true;
        let animeIsSearching = false;
        let animeSearchQuery = '';
        let animeBaseUrl = 'http://localhost:6987/anime';
        
        async function initializeAnime() {
            const animeSearchInput = document.getElementById('animeSearchInput');
            const animeGrid = document.getElementById('animeGrid');
            const animeLoadingIndicator = document.getElementById('animeLoadingIndicator');
            const animeDetailsModal = document.getElementById('animeDetailsModal');
            const animeModalClose = document.getElementById('animeModalClose');
            const animeFindTorrentsBtn = document.getElementById('animeFindTorrentsBtn');
            const animeTorrentsContainer = document.getElementById('animeTorrentsContainer');
            const animeRefreshTorrents = document.getElementById('animeRefreshTorrents');
            const animeTorrentKeywordFilter = document.getElementById('animeTorrentKeywordFilter');
            
            let searchTimeout = null;
            
            // Load trending anime on init
            loadTrendingAnime();
            
            // Setup infinite scroll
            const mainElement = document.querySelector('main');
            mainElement.addEventListener('scroll', () => {
                const animePage = document.getElementById('anime-page');
                if (animePage.style.display === 'none') return;
                
                const scrollBottom = mainElement.scrollTop + mainElement.clientHeight;
                const threshold = mainElement.scrollHeight - 300;
                
                if (scrollBottom >= threshold && !animeIsLoading && animeHasMore) {
                    if (animeIsSearching) {
                        searchAnime(animeSearchQuery, true);
                    } else {
                        loadTrendingAnime(true);
                    }
                }
            });
            
            // Search functionality
            animeSearchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = animeSearchInput.value.trim();
                
                if (!query) {
                    animeIsSearching = false;
                    animeSearchQuery = '';
                    animeOffset = 0;
                    animeHasMore = true;
                    loadTrendingAnime();
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    animeIsSearching = true;
                    animeSearchQuery = query;
                    animeOffset = 0;
                    animeHasMore = true;
                    searchAnime(query);
                }, 500);
            });
            
            animeSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = animeSearchInput.value.trim();
                    if (query) {
                        animeIsSearching = true;
                        animeSearchQuery = query;
                        animeOffset = 0;
                        animeHasMore = true;
                        searchAnime(query);
                    }
                }
            });
            
            // Modal close
            animeModalClose.addEventListener('click', () => {
                animeDetailsModal.classList.remove('active');
                animeTorrentsContainer.style.display = 'none';
                animeRealmSourcesContainer.style.display = 'none';
                // Clear the sources to free memory
                animeRealmSourcesList.innerHTML = '';
                animeTorrentsList.innerHTML = '';
            });
            
            animeDetailsModal.addEventListener('click', (e) => {
                if (e.target === animeDetailsModal) {
                    animeDetailsModal.classList.remove('active');
                    animeTorrentsContainer.style.display = 'none';
                    animeRealmSourcesContainer.style.display = 'none';
                    // Clear the sources to free memory
                    animeRealmSourcesList.innerHTML = '';
                    animeTorrentsList.innerHTML = '';
                }
            });
            
            // Find torrents button
            animeFindTorrentsBtn.addEventListener('click', async () => {
                if (!currentAnime) return;
                animeTorrentsContainer.style.display = 'block';
                animeRealmSourcesContainer.style.display = 'none';
                await loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
            });
            
            // Realm sources button
            const animeRealmSourcesBtn = document.getElementById('animeRealmSourcesBtn');
            const animeDirectStreamBtn = document.getElementById('animeDirectStreamBtn');
            const animeRealmSourcesContainer = document.getElementById('animeRealmSourcesContainer');
            const animeRealmSourcesList = document.getElementById('animeRealmSourcesList');
            const animeRefreshRealmSources = document.getElementById('animeRefreshRealmSources');
            
            // Direct Stream button - shows AnimRealms URL
            animeDirectStreamBtn.addEventListener('click', () => {
                if (!currentAnime) return;
                
                const seasonSelector = document.getElementById('animeSeasonSelector');
                const episodeSelector = document.getElementById('animeEpisodeSelector');
                let episodeNumber = episodeSelector ? episodeSelector.value : null;
                const seasonNumber = seasonSelector ? seasonSelector.value : null;
                
                // If no episode selected or it's a movie, default to episode 1
                if (!episodeNumber || currentAnime.episodes === 1 || currentAnime.format === 'MOVIE') {
                    episodeNumber = '1';
                } else if (seasonNumber) {
                    // Calculate absolute episode if season is selected
                    episodeNumber = calculateAbsoluteEpisode(seasonNumber, episodeNumber).toString();
                }
                
                const anilistId = currentAnime.id;
                const realmUrl = `https://www.animerealms.org/en/watch/${anilistId}/${episodeNumber}`;
                
                console.log('[Direct Stream] URL:', realmUrl);
                
                // Show in Realm sources container
                const animeRealmSourcesList = document.getElementById('animeRealmSourcesList');
                animeRealmSourcesContainer.style.display = 'block';
                animeTorrentsContainer.style.display = 'none';
                
                animeRealmSourcesList.innerHTML = `
                    <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                        <h3 style="color: #10b981; margin: 0 0 1rem 0; font-size: 1.1rem;">
                            <i class="fas fa-external-link-alt"></i> Direct Stream
                        </h3>
                        <iframe src="${realmUrl}" style="width: 100%; height: 600px; border: none; border-radius: 6px; background: #000;" allowfullscreen="true" allow="fullscreen; accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;"></iframe>
                    </div>
                `;
            });
            
            animeRealmSourcesBtn.addEventListener('click', async () => {
                if (!currentAnime) return;
                const seasonSelector = document.getElementById('animeSeasonSelector');
                const episodeSelector = document.getElementById('animeEpisodeSelector');
                let episodeNumber = episodeSelector ? episodeSelector.value : null;
                const seasonNumber = seasonSelector ? seasonSelector.value : null;
                
                // If no episode selected or it's a movie, default to episode 1
                if (!episodeNumber || currentAnime.episodes === 1 || currentAnime.format === 'MOVIE') {
                    episodeNumber = '1';
                } else if (seasonNumber) {
                    // Calculate absolute episode number for Realm API
                    episodeNumber = calculateAbsoluteEpisode(seasonNumber, episodeNumber).toString();
                }
                
                animeRealmSourcesContainer.style.display = 'block';
                animeTorrentsContainer.style.display = 'none';
                await loadRealmSources(currentAnime.id, episodeNumber);
            });
            
            // Refresh Realm sources
            animeRefreshRealmSources.addEventListener('click', async () => {
                if (!currentAnime) return;
                const seasonSelector = document.getElementById('animeSeasonSelector');
                const episodeSelector = document.getElementById('animeEpisodeSelector');
                let episodeNumber = episodeSelector ? episodeSelector.value : null;
                const seasonNumber = seasonSelector ? seasonSelector.value : null;
                
                // If no episode selected or it's a movie, default to episode 1
                if (!episodeNumber || currentAnime.episodes === 1 || currentAnime.format === 'MOVIE') {
                    episodeNumber = '1';
                } else if (seasonNumber) {
                    // Calculate absolute episode number for Realm API
                    episodeNumber = calculateAbsoluteEpisode(seasonNumber, episodeNumber).toString();
                }
                
                await loadRealmSources(currentAnime.id, episodeNumber);
            });
            
            // Refresh torrents
            animeRefreshTorrents.addEventListener('click', async () => {
                if (!currentAnime) return;
                await loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
            });
            
            // Torrent keyword filter
            animeTorrentKeywordFilter.addEventListener('input', () => {
                filterAnimeTorrents();
            });
            
            // Custom search functionality
            const animeCustomSearchInput = document.getElementById('animeCustomSearchInput');
            const animeCustomSearchBtn = document.getElementById('animeCustomSearchBtn');
            
            animeCustomSearchBtn.addEventListener('click', async () => {
                const query = animeCustomSearchInput.value.trim();
                if (query) {
                    await searchAnimeCustomQuery(query);
                }
            });
            
            animeCustomSearchInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const query = animeCustomSearchInput.value.trim();
                    if (query) {
                        await searchAnimeCustomQuery(query);
                    }
                }
            });
        }
        
        async function loadTrendingAnime(append = false) {
            if (animeIsLoading) return;
            animeIsLoading = true;
            
            const animeGrid = document.getElementById('animeGrid');
            const animeLoadingIndicator = document.getElementById('animeLoadingIndicator');
            
            if (!append) {
                animeGrid.innerHTML = '';
                animeOffset = 0;
            }
            
            animeLoadingIndicator.style.display = 'block';
            
            try {
                const query = `
                    query ($page: Int, $perPage: Int) {
                        Page(page: $page, perPage: $perPage) {
                            media(type: ANIME, sort: TRENDING_DESC) {
                                id
                                title {
                                    romaji
                                    english
                                }
                                coverImage {
                                    large
                                }
                                bannerImage
                                averageScore
                                episodes
                                format
                                genres
                                seasonYear
                                description
                            }
                        }
                    }
                `;
                
                const page = Math.floor(animeOffset / 20) + 1;
                const variables = { page, perPage: 20 };
                
                const response = await fetch('https://graphql.anilist.co', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({ query, variables })
                });
                
                const data = await response.json();
                const anime = data.data.Page.media;
                
                if (append) {
                    animeList = [...animeList, ...anime];
                } else {
                    animeList = anime;
                }
                
                if (anime.length < 20) {
                    animeHasMore = false;
                }
                
                anime.forEach(item => {
                    const card = createAnimeCard(item);
                    animeGrid.appendChild(card);
                });
                
                animeOffset += anime.length;
            } catch (error) {
                console.error('Error loading trending anime:', error);
            } finally {
                animeLoadingIndicator.style.display = 'none';
                animeIsLoading = false;
            }
        }
        
        async function searchAnime(query, append = false) {
            if (animeIsLoading) return;
            animeIsLoading = true;
            
            const animeGrid = document.getElementById('animeGrid');
            const animeLoadingIndicator = document.getElementById('animeLoadingIndicator');
            
            if (!append) {
                animeGrid.innerHTML = '';
                animeOffset = 0;
            }
            
            animeLoadingIndicator.style.display = 'block';
            
            try {
                const graphqlQuery = `
                    query ($search: String, $page: Int, $perPage: Int) {
                        Page(page: $page, perPage: $perPage) {
                            media(type: ANIME, search: $search, sort: POPULARITY_DESC) {
                                id
                                title {
                                    romaji
                                    english
                                }
                                coverImage {
                                    large
                                }
                                bannerImage
                                averageScore
                                episodes
                                format
                                genres
                                seasonYear
                                description
                            }
                        }
                    }
                `;
                
                const page = Math.floor(animeOffset / 20) + 1;
                const variables = { search: query, page, perPage: 20 };
                
                const response = await fetch('https://graphql.anilist.co', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({ query: graphqlQuery, variables })
                });
                
                const data = await response.json();
                const anime = data.data.Page.media;
                
                if (append) {
                    animeList = [...animeList, ...anime];
                } else {
                    animeList = anime;
                }
                
                if (anime.length < 20) {
                    animeHasMore = false;
                }
                
                anime.forEach(item => {
                    const card = createAnimeCard(item);
                    animeGrid.appendChild(card);
                });
                
                animeOffset += anime.length;
            } catch (error) {
                console.error('Error searching anime:', error);
            } finally {
                animeLoadingIndicator.style.display = 'none';
                animeIsLoading = false;
            }
        }
        
        function createAnimeCard(anime) {
            const card = document.createElement('div');
            card.className = 'movie-card';
            card.style.cursor = 'pointer';
            
            const title = anime.title.english || anime.title.romaji;
            const coverImage = anime.coverImage.large || '/placeholder.jpg';
            const rating = anime.averageScore ? (anime.averageScore / 10).toFixed(1) : 'N/A';
            const year = anime.seasonYear || 'N/A';
            
            card.innerHTML = `
                <div class="movie-poster-container">
                    <img src="${coverImage}" alt="${title}" class="movie-poster" loading="lazy" />
                    <div class="movie-overlay">
                        <i class="fas fa-info-circle"></i>
                    </div>
                </div>
                <div class="movie-info">
                    <div class="movie-title">${title}</div>
                    <div class="movie-meta">
                        <span class="movie-year">${year}</span>
                        <span class="movie-rating">
                            <i class="fas fa-star"></i> ${rating}
                        </span>
                    </div>
                </div>
            `;
            
            card.addEventListener('click', () => showAnimeDetails(anime));
            return card;
        }
        
        function showAnimeDetails(anime) {
            currentAnime = anime;
            const animeDetailsModal = document.getElementById('animeDetailsModal');
            const animeModalTitle = document.getElementById('animeModalTitle');
            const animeModalPoster = document.getElementById('animeModalPoster');
            const animeModalBackdrop = document.getElementById('animeModalBackdrop');
            const animeModalRating = document.getElementById('animeModalRating');
            const animeModalYear = document.getElementById('animeModalYear');
            const animeModalEpisodes = document.getElementById('animeModalEpisodes');
            const animeModalGenres = document.getElementById('animeModalGenres');
            const animeModalOverview = document.getElementById('animeModalOverview');
            const animeTorrentsContainer = document.getElementById('animeTorrentsContainer');
            const animeRealmSourcesContainer = document.getElementById('animeRealmSourcesContainer');
            const animeRealmSourcesList = document.getElementById('animeRealmSourcesList');
            const animeSeasonEpisodeContainer = document.getElementById('animeSeasonEpisodeContainer');
            
            // Clear previous content
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            if (animeTorrentsList) animeTorrentsList.innerHTML = '';
            if (animeRealmSourcesList) animeRealmSourcesList.innerHTML = '';
            
            // Clear stored subtitles from previous anime
            Object.keys(window).forEach(key => {
                if (key.startsWith('realmSubtitles_')) {
                    delete window[key];
                }
            });
            
            const title = anime.title.english || anime.title.romaji;
            const rating = anime.averageScore ? (anime.averageScore / 10).toFixed(1) : 'N/A';
            const year = anime.seasonYear || 'N/A';
            const episodes = anime.episodes ? `${anime.episodes} Episodes` : 'N/A';
            const genres = anime.genres ? anime.genres.join(', ') : 'N/A';
            const description = anime.description ? anime.description.replace(/<[^>]*>/g, '') : 'No description available.';
            
            animeModalTitle.textContent = title;
            animeModalPoster.src = anime.coverImage.large || '/placeholder.jpg';
            animeModalBackdrop.src = anime.bannerImage || anime.coverImage.large || '/placeholder.jpg';
            animeModalRating.textContent = rating;
            animeModalYear.textContent = year;
            animeModalEpisodes.textContent = episodes;
            animeModalGenres.textContent = genres;
            animeModalOverview.textContent = description;
            
            // Check if it's a series (has episodes) or a movie
            const isMovie = !anime.episodes || anime.episodes === 1 || anime.format === 'MOVIE';
            
            if (isMovie) {
                // Hide season/episode selector for movies
                animeSeasonEpisodeContainer.style.display = 'none';
            } else {
                // Show season/episode selector for series
                animeSeasonEpisodeContainer.style.display = 'block';
                setupAnimeSeasonEpisodeSelectors(anime.episodes);
            }
            
            animeTorrentsContainer.style.display = 'none';
            animeRealmSourcesContainer.style.display = 'none';
            animeDetailsModal.classList.add('active');
        }
        
        function setupAnimeSeasonEpisodeSelectors(totalEpisodes) {
            const seasonSelector = document.getElementById('animeSeasonSelector');
            const episodeSelector = document.getElementById('animeEpisodeSelector');
            
            // Clear existing options
            seasonSelector.innerHTML = '<option value="">All Seasons</option>';
            episodeSelector.innerHTML = '<option value="">All Episodes</option>';
            
            // Remove old event listeners by cloning and replacing
            const newSeasonSelector = seasonSelector.cloneNode(false);
            const newEpisodeSelector = episodeSelector.cloneNode(false);
            const defaultSeasonOption = document.createElement('option');
            defaultSeasonOption.value = '';
            defaultSeasonOption.textContent = 'All Seasons';
            defaultSeasonOption.style.background = '#1a1a2e';
            defaultSeasonOption.style.color = 'var(--light)';
            newSeasonSelector.appendChild(defaultSeasonOption);
            
            const defaultEpisodeOption = document.createElement('option');
            defaultEpisodeOption.value = '';
            defaultEpisodeOption.textContent = 'All Episodes';
            defaultEpisodeOption.style.background = '#1a1a2e';
            defaultEpisodeOption.style.color = 'var(--light)';
            newEpisodeSelector.appendChild(defaultEpisodeOption);
            
            seasonSelector.parentNode.replaceChild(newSeasonSelector, seasonSelector);
            episodeSelector.parentNode.replaceChild(newEpisodeSelector, episodeSelector);
            
            // Estimate number of seasons (typical anime season is ~12-13 or 24-26 episodes)
            // Let's assume max 4 seasons for safety
            const estimatedSeasons = totalEpisodes ? Math.min(Math.ceil(totalEpisodes / 12), 4) : 1;
            
            // Populate season selector
            for (let i = 1; i <= estimatedSeasons; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Season ${i}`;
                option.style.background = '#1a1a2e';
                option.style.color = 'var(--light)';
                option.style.fontWeight = '500';
                newSeasonSelector.appendChild(option);
            }
            
            // Populate episode selector (up to total episodes or 100, whichever is smaller)
            const maxEpisodes = totalEpisodes ? Math.min(totalEpisodes, 100) : 50;
            for (let i = 1; i <= maxEpisodes; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Episode ${i}`;
                option.style.background = '#1a1a2e';
                option.style.color = 'var(--light)';
                option.style.fontWeight = '500';
                newEpisodeSelector.appendChild(option);
            }
            
            // Add event listeners (only once per new selector)
            newSeasonSelector.addEventListener('change', () => {
                if (document.getElementById('animeTorrentsContainer').style.display !== 'none') {
                    loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
                }
            });
            
            newEpisodeSelector.addEventListener('change', () => {
                if (document.getElementById('animeTorrentsContainer').style.display !== 'none') {
                    loadAnimeTorrents(currentAnime.title.romaji || currentAnime.title.english);
                }
            });
        }
        
        async function loadAnimeTorrents(animeTitle) {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            const seasonSelector = document.getElementById('animeSeasonSelector');
            const episodeSelector = document.getElementById('animeEpisodeSelector');
            
            const selectedSeason = seasonSelector.value;
            const selectedEpisode = episodeSelector.value;
            
            // Generate search queries with multiple variants
            const searchQueries = generateAnimeSearchQueries(animeTitle, selectedSeason, selectedEpisode);
            
            // Show loading state and lock the display
            animeTorrentsList.innerHTML = `<div class="loading"><div class="spinner"></div><p>Searching Nyaa with ${searchQueries.length} query variants...</p></div>`;
            
            try {
                // Collect all results first
                const allTorrents = [];
                const seenMagnets = new Set();
                
                // Execute all searches in parallel and wait for ALL to complete
                const searchResults = await Promise.all(
                    searchQueries.map(async (query) => {
                        try {
                            const response = await fetch(`${animeBaseUrl}/api/${encodeURIComponent(query)}`);
                            const data = await response.json();
                            return data.results || [];
                        } catch (err) {
                            console.error(`Error searching for "${query}":`, err);
                            return [];
                        }
                    })
                );
                
                // Now combine all results (this happens AFTER all searches complete)
                searchResults.forEach(results => {
                    results.forEach(torrent => {
                        if (!seenMagnets.has(torrent.magnetLink)) {
                            seenMagnets.add(torrent.magnetLink);
                            allTorrents.push(torrent);
                        }
                    });
                });
                
                // Check if we found anything
                if (allTorrents.length === 0) {
                    animeTorrentsList.innerHTML = '<p style="text-align: center; color: var(--light); padding: 2rem;">No torrents found. Try selecting different season/episode options.</p>';
                    return;
                }
                
                // Sort by seeders (highest first)
                allTorrents.sort((a, b) => (b.seeders || 0) - (a.seeders || 0));
                
                // Store original torrents for filtering
                animeTorrentsList.dataset.allTorrents = JSON.stringify(allTorrents);
                
                // Display all results at once
                displayAnimeTorrents(allTorrents);
                
            } catch (error) {
                console.error('Error loading anime torrents:', error);
                animeTorrentsList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 2rem;">Error loading torrents. Make sure the Nyaa server is running.</p>';
            }
        }
        
        function generateAnimeSearchQueries(animeTitle, season, episode) {
            const queries = [];
            const baseTitle = animeTitle.trim();
            
            // If no season/episode selected, just search for the anime title
            if (!season && !episode) {
                queries.push(baseTitle);
                return queries;
            }
            
            // If only season selected (no specific episode)
            if (season && !episode) {
                // Season variants
                queries.push(`${baseTitle} S${season}`);
                queries.push(`${baseTitle} S${season.padStart(2, '0')}`);
                queries.push(`${baseTitle} Season ${season}`);
                queries.push(`${baseTitle} Season${season}`);
                queries.push(`${baseTitle} Season ${season.padStart(2, '0')}`);
                queries.push(`${baseTitle} Season${season.padStart(2, '0')}`);
                return queries;
            }
            
            // If only episode selected (no season)
            if (!season && episode) {
                // Episode only variants
                queries.push(`${baseTitle} E${episode}`);
                queries.push(`${baseTitle} E${episode.padStart(2, '0')}`);
                queries.push(`${baseTitle} EP${episode}`);
                queries.push(`${baseTitle} EP${episode.padStart(2, '0')}`);
                queries.push(`${baseTitle} Episode ${episode}`);
                queries.push(`${baseTitle} Episode${episode}`);
                queries.push(`${baseTitle} - ${episode.padStart(2, '0')}`);
                return queries;
            }
            
            // Both season and episode selected
            const s = season;
            const e = episode;
            const s2 = season.padStart(2, '0');
            const e2 = episode.padStart(2, '0');
            
            // Combined season+episode variants
            queries.push(`${baseTitle} S${s2}E${e2}`);
            queries.push(`${baseTitle} S${s}E${e}`);
            queries.push(`${baseTitle} S${s2}E${e}`);
            queries.push(`${baseTitle} S${s}E${e2}`);
            queries.push(`${baseTitle} S${s2} E${e2}`);
            queries.push(`${baseTitle} Season ${s} Episode ${e}`);
            queries.push(`${baseTitle} Season${s} Episode${e}`);
            queries.push(`${baseTitle} Season ${s} Ep ${e}`);
            queries.push(`${baseTitle} ${s2}x${e2}`);
            queries.push(`${baseTitle} - ${s2}x${e2}`);
            queries.push(`${baseTitle} - S${s2}E${e2}`);
            
            return queries;
        }
        
        function displayAnimeTorrents(torrents) {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            animeTorrentsList.innerHTML = '';
            
            torrents.forEach(torrent => {
                const torrentItem = document.createElement('div');
                torrentItem.className = 'torrent-item';
                
                torrentItem.innerHTML = `
                    <div class="torrent-info">
                        <div class="torrent-title">${torrent.title}</div>
                        <div class="torrent-meta">
                            <span class="torrent-size">
                                <i class="fas fa-hdd"></i> ${torrent.size}
                            </span>
                            <span class="torrent-seeders">
                                <i class="fas fa-arrow-up"></i> ${torrent.seeders} seeders
                            </span>
                        </div>
                    </div>
                    <div class="torrent-actions">
                        <button class="btn btn-primary" onclick="playAnimeTorrent('${torrent.magnetLink.replace(/'/g, "\\'")}', '${torrent.title.replace(/'/g, "\\'")}')">
                            <i class="fas fa-play"></i> Play
                        </button>
                    </div>
                `;
                
                animeTorrentsList.appendChild(torrentItem);
            });
        }
        
        function filterAnimeTorrents() {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            const filterInput = document.getElementById('animeTorrentKeywordFilter');
            const keyword = filterInput.value.toLowerCase();
            
            const allTorrentsData = animeTorrentsList.dataset.allTorrents;
            if (!allTorrentsData) return;
            
            const allTorrents = JSON.parse(allTorrentsData);
            
            if (!keyword) {
                displayAnimeTorrents(allTorrents);
                return;
            }
            
            const filtered = allTorrents.filter(t => t.title.toLowerCase().includes(keyword));
            displayAnimeTorrents(filtered);
        }
        
        async function searchAnimeCustomQuery(customQuery) {
            const animeTorrentsList = document.getElementById('animeTorrentsList');
            const animeTorrentsContainer = document.getElementById('animeTorrentsContainer');
            
            // Show torrents container if hidden
            animeTorrentsContainer.style.display = 'block';
            
            // Show loading
            animeTorrentsList.innerHTML = '<div class="loading"><div class="spinner"></div><p>Searching Nyaa with your custom query...</p></div>';
            
            try {
                const response = await fetch(`${animeBaseUrl}/api/${encodeURIComponent(customQuery)}`);
                const data = await response.json();
                
                if (!data.results || data.results.length === 0) {
                    animeTorrentsList.innerHTML = '<p style="text-align: center; color: var(--light); padding: 2rem;">No torrents found for your custom query. Try different keywords.</p>';
                    return;
                }
                
                // Sort by seeders
                const torrents = data.results.sort((a, b) => (b.seeders || 0) - (a.seeders || 0));
                
                // Store and display
                animeTorrentsList.dataset.allTorrents = JSON.stringify(torrents);
                displayAnimeTorrents(torrents);
                
                // Show notification
                showNotification(`Found ${torrents.length} torrents for "${customQuery}"`, 'success');
                
            } catch (error) {
                console.error('Error with custom search:', error);
                animeTorrentsList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 2rem;">Error searching. Make sure the Nyaa server is running.</p>';
            }
        }
        
        function playAnimeTorrent(magnetLink, title) {
            // Close the anime modal
            const animeDetailsModal = document.getElementById('animeDetailsModal');
            animeDetailsModal.classList.remove('active');
            
            // Use the same startStream function as movies/shows
            startStream(magnetLink);
        }
        
        // ============================================================================
        // REALM ANIME SOURCES
        // ============================================================================
        
        // Open AnimRealms in iframe
        function openAnimeRealmIframe(realmUrl) {
            const iframe = document.getElementById('video-player-frame');
            const customPlayerContainer = document.getElementById('customPlayerContainer');
            const videoContainer = document.getElementById('videoContainer');
            const frameContainer = document.querySelector('.video-player-frame-container');
            
            if (!iframe || !customPlayerContainer) {
                console.error('[Direct Stream] Player elements not found');
                showNotification('Player not available', 'error');
                return;
            }
            
            // Hide the video container, show only iframe
            if (videoContainer) videoContainer.style.display = 'none';
            if (frameContainer) frameContainer.style.display = 'block';
            
            // Set iframe source
            iframe.src = realmUrl;
            
            // Show player
            customPlayerContainer.classList.add('active');
            customPlayerContainer.style.display = 'flex';
            
            // Update Discord if available
            if (currentAnime) {
                const animeTitle = currentAnime.title?.romaji || currentAnime.title?.english || 'Anime';
                updateDiscordForStreaming(animeTitle, 'AnimRealms', null);
            }
            
            console.log('[Direct Stream] Opened iframe:', realmUrl);
            showNotification('Loading AnimRealms...', 'success');
        }
        
        // Helper function to calculate absolute episode number from season + episode
        function calculateAbsoluteEpisode(seasonNum, episodeNum, episodesPerSeason = 12) {
            const season = parseInt(seasonNum) || 1;
            const episode = parseInt(episodeNum) || 1;
            
            // If season 1, just return episode number
            if (season === 1) return episode;
            
            // Calculate: (previous seasons * eps per season) + current episode
            return ((season - 1) * episodesPerSeason) + episode;
        }
        
        async function loadRealmSources(anilistId, episodeNumber) {
            const animeRealmSourcesList = document.getElementById('animeRealmSourcesList');
            
            if (!anilistId || !episodeNumber) {
                animeRealmSourcesList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 2rem;">Please select an episode first</p>';
                return;
            }
            
            // Show loading
            animeRealmSourcesList.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading Realm sources...</p></div>';
            
            try {
                const response = await fetch(`http://localhost:6987/api/realm/${anilistId}/${episodeNumber}`);
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
                
                const data = await response.json();
                console.log('[Realm] Sources data:', data);
                
                displayRealmSources(data);
                
            } catch (error) {
                console.error('[Realm] Error loading sources:', error);
                animeRealmSourcesList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 2rem;">Error loading sources. Make sure the server is running.</p>';
            }
        }
        
        function displayRealmSources(sourcesData) {
            const animeRealmSourcesList = document.getElementById('animeRealmSourcesList');
            animeRealmSourcesList.innerHTML = '';
            
            let hasAnySources = false;
            
            // Iterate through each provider
            Object.keys(sourcesData).forEach(providerName => {
                const provider = sourcesData[providerName];
                
                // Skip if error or not found or no streams
                if (provider.error || provider.notFound || !provider.streams || provider.streams.length === 0) {
                    return;
                }
                
                hasAnySources = true;
                
                // Create provider section
                const providerSection = document.createElement('div');
                providerSection.style.marginBottom = '1.5rem';
                
                const providerTitle = document.createElement('h4');
                providerTitle.style.cssText = 'color: #8b5cf6; font-size: 1.1rem; margin-bottom: 0.75rem; text-transform: capitalize; font-weight: 600;';
                providerTitle.innerHTML = `<i class="fas fa-play-circle"></i> ${providerName.replace(/-/g, ' ')}`;
                providerSection.appendChild(providerTitle);
                
                // Display streams
                provider.streams.forEach((stream, streamIndex) => {
                    const streamItem = document.createElement('div');
                    streamItem.className = 'torrent-item';
                    streamItem.style.marginBottom = '0.5rem';
                    
                    const qualityLabel = stream.quality || 'auto';
                    const streamUrl = stream.url;
                    
                    // Get referer - always use animerealms.org for all providers to ensure CDN access
                    let referer = 'https://www.animerealms.org/';
                    
                    // Store subtitles for this provider if available
                    const subsKey = `${providerName}_${streamIndex}`;
                    if (provider.subtitles && provider.subtitles.length > 0) {
                        window[`realmSubtitles_${subsKey}`] = provider.subtitles;
                    }
                    
                    const hasSubtitles = provider.subtitles && provider.subtitles.length > 0;
                    
                    const subsText = hasSubtitles ? `  ${provider.subtitles.length} subs` : '';
                    
                    streamItem.innerHTML = `
                        <div class="torrent-info">
                            <div class="torrent-title">${providerName.replace(/-/g, ' ')} - ${qualityLabel}</div>
                            <div class="torrent-meta">
                                <span class="torrent-size">
                                    <i class="fas fa-server"></i> Proxied${subsText}
                                </span>
                            </div>
                        </div>
                        <div class="torrent-actions">
                            <button class="btn btn-primary" onclick="playRealmStream('${streamUrl.replace(/'/g, "\\'")}', '${referer.replace(/'/g, "\\'")}', '${providerName} - ${qualityLabel}', '${subsKey}')">
                                <i class="fas fa-play"></i> Play
                            </button>
                        </div>
                    `;
                    
                    providerSection.appendChild(streamItem);
                });
                
                animeRealmSourcesList.appendChild(providerSection);
            });
            
            if (!hasAnySources) {
                animeRealmSourcesList.innerHTML = '<p style="text-align: center; color: var(--light); padding: 2rem; opacity: 0.7;">No sources found for this episode</p>';
            }
        }
        
        async function playRealmStream(url, referer, title, subsKey) {
            console.log('[Realm] Playing stream:', { url, referer, title, subsKey });
            
            // Get subtitles if available
            const subtitles = subsKey ? window[`realmSubtitles_${subsKey}`] : null;
            if (subtitles && subtitles.length > 0) {
                console.log('[Realm] Passing subtitles to player:', subtitles);
            }
            
            // Close the anime modal
            const animeDetailsModal = document.getElementById('animeDetailsModal');
            animeDetailsModal.classList.remove('active');
            
            // If there's a referer, use proxy
            let playUrl = url;
            if (referer) {
                playUrl = `http://localhost:6987/api/realm/proxy?url=${encodeURIComponent(url)}&referer=${encodeURIComponent(referer)}`;
                console.log('[Realm] Using proxy URL:', playUrl);
            }
            
            // Get current anime info
            const tmdbId = currentAnime?.id?.toString() || '';
            const episodeSelector = document.getElementById('animeEpisodeSelector');
            const episodeNum = episodeSelector ? episodeSelector.value : null;
            
            // Platform detection
            const platform = window.electronAPI.platform;
            
            try {
                if (platform === 'win32') {
                    // Windows: Use mpv.js player
                    const res = await window.electronAPI.spawnMpvjsPlayer({
                        url: playUrl,
                        tmdbId,
                        seasonNum: null,
                        episodeNum,
                        subtitles: subtitles || null,
                        isDebrid: useDebrid
                    });
                    
                    if (res?.success) {
                        console.log('[Realm] mpv.js player started successfully');
                    } else {
                        console.error('[Realm] mpv.js failed:', res?.message);
                        showNotification(res?.message || 'Failed to start player', 'error');
                    }
                } else if (platform === 'darwin') {
                    // macOS: Use IINA
                    const res = await window.electronAPI.openInIINA({
                        streamUrl: playUrl
                    });
                    
                    if (res?.success) {
                        console.log('[Realm] IINA started successfully');
                    } else {
                        console.error('[Realm] IINA failed:', res?.message);
                        showNotification(res?.message || 'IINA not installed. Please download from https://iina.io', 'error');
                    }
                } else {
                    // Linux: Use MPV
                    const res = await window.electronAPI.openMpvDirect(playUrl);
                    
                    if (res?.success) {
                        console.log('[Realm] MPV started successfully');
                    } else {
                        console.error('[Realm] MPV failed:', res?.message);
                        showNotification(res?.message || 'MPV not installed. Please install mpv: sudo apt install mpv', 'error');
                    }
                }
            } catch (error) {
                console.error('[Realm] Error launching player:', error);
                showNotification('Failed to launch player: ' + error.message, 'error');
            }
        }

        // ---- Manga functionality ----
        let mangaList = [];
        let currentManga = null;

        function toggleReaderFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => {
                    console.error(`Error attempting to enable full-screen mode: ${e.message} (${e.name})`);
                });
                document.body.classList.add('reader-fullscreen-mode');
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                document.body.classList.remove('reader-fullscreen-mode');
            }
        }
        
        // Manga Storage Helpers
        const SAVED_MANGA_KEY = 'pt_saved_manga_v1';
        const MANGA_PROGRESS_KEY = 'pt_manga_reading_progress_v1';
        
        // Reading progress helpers
        function getAllMangaProgress() {
            try { return JSON.parse(localStorage.getItem(MANGA_PROGRESS_KEY) || '{}'); } catch { return {}; }
        }
        function setAllMangaProgress(data) {
            localStorage.setItem(MANGA_PROGRESS_KEY, JSON.stringify(data));
        }
        function saveMangaReadingProgress(source, mangaId, chapterId, pageIndex) {
            const key = `${source}_${mangaId}_${chapterId}`;
            const allProgress = getAllMangaProgress();
            allProgress[key] = { pageIndex, timestamp: Date.now() };
            setAllMangaProgress(allProgress);
        }
        function loadMangaReadingProgress(source, mangaId, chapterId) {
            const key = `${source}_${mangaId}_${chapterId}`;
            const allProgress = getAllMangaProgress();
            return allProgress[key] ? allProgress[key].pageIndex : 0;
        }
        
        function getSavedManga() {
            try { return JSON.parse(localStorage.getItem(SAVED_MANGA_KEY) || '[]'); } catch { return []; }
        }
        function setSavedManga(list) {
            localStorage.setItem(SAVED_MANGA_KEY, JSON.stringify(list));
        }
        function isMangaSaved(uniqueId) {
            return getSavedManga().some(m => String(m.uniqueId) === String(uniqueId));
        }
        function toggleSaveManga(event, manga) {
            event.stopPropagation();
            const list = getSavedManga();
            const idx = list.findIndex(m => String(m.uniqueId) === String(manga.uniqueId));
            const btn = event.currentTarget;
            if (idx >= 0) {
                list.splice(idx, 1);
                btn.classList.remove('in-list');
                btn.innerHTML = '<i class="fas fa-plus"></i>';
                showNotification('Removed from Saved Manga', 'info');
            } else {
                list.unshift(manga);
                btn.classList.add('in-list');
                btn.innerHTML = '<i class="fas fa-check"></i>';
                showNotification('Added to Saved Manga', 'success');
            }
            setSavedManga(list);
        }

        let mangaOffset = 1;
        let mangaIsLoading = false;
        let mangaHasMore = true;
        let mangaIsSearching = false;
        let mangaSearchQuery = '';
        let mangaSource = 'weebcentral'; // 'weebcentral' or 'comix'

        async function initializeManga() {
            const mangaSearchInput = document.getElementById('mangaSearchInput');
            const mangaGrid = document.getElementById('mangaGrid');
            const mangaLoadingIndicator = document.getElementById('mangaLoadingIndicator');
            const mangaDetailsModal = document.getElementById('mangaDetailsModal');
            const mangaDetailsClose = document.getElementById('mangaDetailsClose');
            const mangaReaderPage = document.getElementById('manga-reader-page');
            const mangaReaderBack = document.getElementById('mangaReaderBack');
            const mangaFullscreenBtn = document.getElementById('mangaFullscreenBtn');
            
            // Manga Zoom Controls
            const mangaZoomIn = document.getElementById('mangaZoomIn');
            const mangaZoomOut = document.getElementById('mangaZoomOut');
            const mangaReaderPages = document.getElementById('mangaReaderPages');
            let currentMangaZoom = 1200; // Default max-width

            mangaZoomIn.addEventListener('click', () => {
                currentMangaZoom += 200;
                mangaReaderPages.style.maxWidth = `${currentMangaZoom}px`;
            });
            mangaZoomOut.addEventListener('click', () => {
                if (currentMangaZoom > 400) {
                    currentMangaZoom -= 200;
                    mangaReaderPages.style.maxWidth = `${currentMangaZoom}px`;
                }
            });

            if (mangaFullscreenBtn) {
                mangaFullscreenBtn.addEventListener('click', toggleReaderFullscreen);
            }

            const weebcentralBtn = document.getElementById('weebcentral-btn');
            const comixBtn = document.getElementById('comix-btn');
            const mangaCategoriesContainer = document.getElementById('manga-categories-container');
            const mangaCategoriesDropdown = document.getElementById('manga-categories-dropdown');
            const mangaSourceSubtitle = document.getElementById('manga-source-subtitle');
            const mangaSavedBtn = document.getElementById('manga-saved-btn');
            
            weebcentralBtn.addEventListener('click', () => {
                if (mangaSource === 'weebcentral') return;
                mangaSource = 'weebcentral';
                weebcentralBtn.classList.add('active');
                comixBtn.classList.remove('active');
                if (mangaSavedBtn) mangaSavedBtn.classList.remove('active');
                mangaCategoriesContainer.style.display = 'none';
                mangaSourceSubtitle.textContent = 'Read manga from WeebCentral';
                clearMangaGridAndSearch();
                loadTrendingManga();
            });

            comixBtn.addEventListener('click', () => {
                if (mangaSource === 'comix') return;
                mangaSource = 'comix';
                comixBtn.classList.add('active');
                weebcentralBtn.classList.remove('active');
                if (mangaSavedBtn) mangaSavedBtn.classList.remove('active');
                mangaCategoriesContainer.style.display = 'block';
                mangaSourceSubtitle.textContent = 'Read manga from Comix';
                clearMangaGridAndSearch();
                loadComixGenres();
                loadTrendingManga();
            });

            if (mangaSavedBtn) {
                mangaSavedBtn.addEventListener('click', () => {
                    if (mangaSource === 'saved') return;
                    mangaSource = 'saved';
                    mangaSavedBtn.classList.add('active');
                    weebcentralBtn.classList.remove('active');
                    comixBtn.classList.remove('active');
                    mangaCategoriesContainer.style.display = 'none';
                    mangaSourceSubtitle.textContent = 'Your Saved Manga';
                    clearMangaGridAndSearch();
                    loadSavedMangaView();
                });
            }

            mangaCategoriesDropdown.addEventListener('change', () => {
                clearMangaGridAndSearch();
                loadTrendingManga();
            });

            function clearMangaGridAndSearch() {
                mangaGrid.innerHTML = '';
                mangaSearchInput.value = '';
                mangaOffset = 1;
                mangaHasMore = true;
                mangaIsSearching = false;
                mangaSearchQuery = '';
                mangaList = [];
            }

            async function loadComixGenres() {
                try {
                    const response = await fetch(`http://localhost:6987/api/comix/genres`);
                    const data = await response.json();
                    if (data.status === 'success') {
                        mangaCategoriesDropdown.innerHTML = '<option value="">All Categories</option>';
                        for (const genreId in data.genres) {
                            const option = document.createElement('option');
                            option.value = genreId;
                            option.textContent = data.genres[genreId];
                            mangaCategoriesDropdown.appendChild(option);
                        }
                    }
                } catch (error) {
                    console.error('Error loading comix genres:', error);
                }
            }

            let searchTimeout = null;
            
            // Load trending manga on init
            loadTrendingManga();
            
            // Setup infinite scroll
            setupMangaInfiniteScroll();
            
            // Search functionality
            mangaSearchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = mangaSearchInput.value.trim();
                
                if (!query) {
                    mangaIsSearching = false;
                    mangaSearchQuery = '';
                    mangaOffset = 1;
                    mangaHasMore = true;
                    mangaList = [];
                    loadTrendingManga();
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    searchManga(query);
                }, 500);
            });
            
            mangaSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = mangaSearchInput.value.trim();
                    if (query) {
                        clearTimeout(searchTimeout);
                        searchManga(query);
                    }
                }
            });
            
            // Close details modal
            mangaDetailsClose.addEventListener('click', () => {
                mangaDetailsModal.style.display = 'none';
            });
            
            // Back from reader
            mangaReaderBack.addEventListener('click', () => {
                // Save progress before leaving
                if (window.currentMangaReadingContext) {
                    const ctx = window.currentMangaReadingContext;
                    const pages = document.querySelectorAll('.manga-reader-page');
                    if (pages.length > 0) {
                        // Find current page
                        const viewportCenter = window.innerHeight / 3;
                        let closestPage = 0;
                        let closestDistance = Infinity;
                        pages.forEach((img, index) => {
                            const rect = img.getBoundingClientRect();
                            const imgCenter = rect.top + rect.height / 2;
                            const distance = Math.abs(imgCenter - viewportCenter);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestPage = index;
                            }
                        });
                        saveMangaReadingProgress(ctx.provider, ctx.mangaId, ctx.chapterId, closestPage);
                    }
                    window.currentMangaReadingContext = null;
                }
                // Remove scroll tracker
                if (window.mangaScrollTracker) {
                    window.removeEventListener('scroll', window.mangaScrollTracker);
                    window.mangaScrollTracker = null;
                }
                mangaReaderPage.style.display = 'none';
                document.getElementById('manga-page').style.display = '';
            });
            
            // Add hover effect for back button
            mangaReaderBack.addEventListener('mouseenter', () => {
                mangaReaderBack.style.transform = 'scale(1.05)';
            });
            mangaReaderBack.addEventListener('mouseleave', () => {
                mangaReaderBack.style.transform = 'scale(1)';
            });
            
            function setupMangaInfiniteScroll() {
                const mainElement = document.querySelector('main');
                const mangaPage = document.getElementById('manga-page');
                
                mainElement.addEventListener('scroll', () => {
                    // Only trigger if manga page is visible
                    if (mangaPage.style.display === 'none') return;
                    if (mangaIsLoading || !mangaHasMore) return;
                    
                    const scrollHeight = mainElement.scrollHeight;
                    const scrollTop = mainElement.scrollTop;
                    const clientHeight = mainElement.clientHeight;
                    
                    // Load more when user is 500px from bottom
                    if (scrollHeight - scrollTop - clientHeight < 500) {
                        if (mangaIsSearching) {
                            searchManga(mangaSearchQuery, true); // true = append
                        } else {
                            loadTrendingManga(true); // true = append
                        }
                    }
                });
            }
            
            function loadSavedMangaView() {
                const saved = getSavedManga();
                if (saved.length === 0) {
                    mangaGrid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1; padding: 2rem;">No saved manga yet.</p>';
                    return;
                }
                displayManga(saved, false);
            }

            async function loadTrendingManga(append = false) {
                if (mangaIsLoading) return;
                
                mangaIsLoading = true;
                mangaLoadingIndicator.style.display = 'block';
                
                if (!append) {
                    mangaGrid.innerHTML = '';
                    mangaOffset = 1;
                    mangaHasMore = true;
                    mangaList = [];
                }
                
                try {
                    let url;
                    if (mangaSource === 'comix') {
                        const category = mangaCategoriesDropdown.value;
                        if (category) {
                            url = `http://localhost:6987/api/comix/manga/genre/${category}?page=${mangaOffset}`;
                        } else {
                            url = `http://localhost:6987/api/comix/manga/all?page=${mangaOffset}`;
                        }
                    } else {
                        url = `http://localhost:6987/api/manga/all?page=${mangaOffset}`;
                    }
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    let dataToDisplay = [];
                    if (mangaSource === 'comix' && data.status === 'success') {
                        dataToDisplay = data.data;
                    } else if (mangaSource === 'weebcentral' && data.success) {
                        dataToDisplay = data.data;
                    }

                    if (append) {
                        mangaList = [...mangaList, ...dataToDisplay];
                    } else {
                        mangaList = dataToDisplay;
                    }
                    
                    displayManga(dataToDisplay, append);
                    
                    mangaOffset += 1;
                    mangaHasMore = dataToDisplay.length >= 20;
                } catch (error) {
                    console.error('Error loading trending manga:', error);
                    if (!append) {
                        mangaGrid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1;">Failed to load manga. Please try again.</p>';
                    }
                } finally {
                    mangaLoadingIndicator.style.display = 'none';
                    mangaIsLoading = false;
                }
            }
            
            async function searchManga(query, append = false) {
                if (mangaIsLoading) return;
                
                mangaIsLoading = true;
                mangaLoadingIndicator.style.display = 'block';
                mangaIsSearching = true;
                mangaSearchQuery = query;
                
                if (!append) {
                    mangaGrid.innerHTML = '';
                    mangaOffset = 1;
                    mangaHasMore = true;
                    mangaList = [];
                }
                
                try {
                    let url;
                    if (mangaSource === 'comix') {
                        url = `http://localhost:6987/api/comix/manga/search/${encodeURIComponent(query)}?page=${mangaOffset}`;
                    } else {
                        url = `http://localhost:6987/api/manga/search?q=${encodeURIComponent(query)}`;
                    }
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    let dataToDisplay = [];
                    if (mangaSource === 'comix' && data.status === 'success') {
                        dataToDisplay = data.data;
                    } else if (mangaSource === 'weebcentral' && data.success) {
                        dataToDisplay = data.data;
                    }

                    if (append) {
                        mangaList = [...mangaList, ...dataToDisplay];
                    } else {
                        mangaList = dataToDisplay;
                    }

                    if (!append && mangaList.length === 0) {
                        mangaGrid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1;">No manga found.</p>';
                    } else {
                        displayManga(dataToDisplay, append);
                    }
                    
                    mangaOffset += 1;
                    mangaHasMore = dataToDisplay.length >= 20;
                } catch (error) {
                    console.error('Error searching manga:', error);
                    if (!append) {
                        mangaGrid.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1;">Search failed. Please try again.</p>';
                    }
                } finally {
                    mangaLoadingIndicator.style.display = 'none';
                    mangaIsLoading = false;
                }
            }
            
            function displayManga(mangaArray, append = false) {
                if (!append) {
                    mangaGrid.innerHTML = '';
                }
                
                mangaArray.forEach(manga => {
                    // Ensure provider is set on the object
                    if (!manga.provider) manga.provider = mangaSource;
                    // Ensure uniqueId is set
                    if (!manga.uniqueId) {
                        manga.uniqueId = manga.provider === 'comix' ? (manga.manga_id || manga.hash_id) : (manga.id || manga.seriesId);
                    }

                    const title = manga.name || 'Unknown Title';
                    const coverUrl = manga.poster || '';
                    const isSaved = isMangaSaved(manga.uniqueId);
                    
                    const card = document.createElement('div');
                    card.className = 'movie-card';
                    card.style.cursor = 'pointer';
                    
                    card.innerHTML = `
                        <button class="add-to-list-btn ${isSaved ? 'in-list' : ''}" title="${isSaved ? 'Remove from Saved' : 'Save Manga'}">
                            <i class="fas ${isSaved ? 'fa-check' : 'fa-plus'}"></i>
                        </button>
                        <img src="${coverUrl || 'https://via.placeholder.com/256x384?text=No+Cover'}" alt="${title}" class="movie-poster" style="object-fit: cover;">
                        <div class="movie-info">
                            <h3 class="movie-title">${title}</h3>
                            <p class="movie-year">Manga</p>
                        </div>
                        <div class="movie-rating" style="background: #ec4899;">
                            <i class="fas fa-book"></i> Read
                        </div>
                    `;
                    
                    const saveBtn = card.querySelector('.add-to-list-btn');
                    saveBtn.addEventListener('click', (e) => {
                        toggleSaveManga(e, manga);
                    });

                    card.addEventListener('click', (e) => {
                        if (e.target.closest('.add-to-list-btn')) return;
                        showMangaDetails(manga);
                    });
                    mangaGrid.appendChild(card);
                });
            }
            
            async function showMangaDetails(manga) {
                currentManga = manga;
                const title = manga.name || 'Unknown Title';
                const description = manga.description || 'Tap to read';
                
                // Use provider from manga object if available (for saved items), else global source
                const provider = manga.provider || mangaSource;
                const author = provider === 'comix' ? 'Comix' : 'WeebCentral';
                const coverUrl = manga.poster || '';
                
                document.getElementById('mangaDetailsTitle').textContent = title;
                document.getElementById('mangaDetailsAuthor').textContent = `Source: ${author}`;

                if (provider === 'comix') {
                    document.getElementById('mangaDetailsStatus').textContent = `Manga ID: ${manga.manga_id}`;
                } else {
                    document.getElementById('mangaDetailsStatus').textContent = `Series ID: ${manga.seriesId}`;
                }

                document.getElementById('mangaDetailsDescription').textContent = description;
                document.getElementById('mangaDetailsCover').src = coverUrl || 'https://via.placeholder.com/300x450?text=No+Cover';
                
                // Clear tags
                const tagsContainer = document.getElementById('mangaDetailsTags');
                tagsContainer.innerHTML = '';
                
                // Load chapters
                if (provider === 'comix') {
                    await loadMangaChapters(manga.hash_id, null, 'comix');
                } else {
                    await loadMangaChapters(manga.seriesId || manga.id, manga.latestChapterId, 'weebcentral');
                }

                mangaDetailsModal.style.display = 'block';
            }
            
            async function loadMangaChapters(id, latestChapterId, provider) {
                const chaptersList = document.getElementById('mangaChaptersList');
                chaptersList.innerHTML = '<p style="text-align: center; color: white; grid-column: 1 / -1;">Loading chapters...</p>';
                
                // Default to global if not passed
                if (!provider) provider = mangaSource;
                
                try {
                    let url;
                    if (provider === 'comix') {
                        url = `http://localhost:6987/api/comix/chapters/${id}`;
                    } else {
                        url = `http://localhost:6987/api/manga/chapters?seriesId=${encodeURIComponent(id)}&latestChapterId=${encodeURIComponent(latestChapterId || 'latest')}`;
                    }
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    chaptersList.innerHTML = '';
                    let chapters = [];
                    if (provider === 'comix' && data.status === 'success') {
                        chapters = data.data;
                    } else if (provider === 'weebcentral' && data.success) {
                        chapters = data.data;
                    }

                    if (chapters && chapters.length > 0) {
                        chapters.forEach(chapter => {
                            let chapterTitle, chapterId, seriesId;
                            if (provider === 'comix') {
                                chapterTitle = `Chapter ${chapter.number}` + (chapter.name ? `: ${chapter.name}` : '');
                                chapterId = chapter.chapter_id;
                                seriesId = id;
                            } else {
                                chapterTitle = chapter.name || '?';
                                chapterId = chapter.id;
                                seriesId = id;
                            }

                            const chapterCard = document.createElement('div');
                            chapterCard.style.cssText = 'background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 8px; cursor: pointer; transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); border: 1px solid rgba(236, 72, 153, 0.3);';
                            
                            chapterCard.innerHTML = `
                                <div style="font-weight: 600; color: #ec4899; margin-bottom: 0.25rem;">${chapterTitle}</div>
                                <div style="font-size: 0.85rem; color: #9ca3af;">Click to read</div>
                            `;
                            
                            chapterCard.addEventListener('mouseenter', () => {
                                chapterCard.style.background = 'rgba(236, 72, 153, 0.2)';
                                chapterCard.style.transform = 'translateX(4px)';
                            });
                            
                            chapterCard.addEventListener('mouseleave', () => {
                                chapterCard.style.background = 'rgba(255,255,255,0.1)';
                                chapterCard.style.transform = 'translateX(0)';
                            });
                            
                            chapterCard.addEventListener('click', async () => {
                                readMangaChapter(seriesId, chapterId, chapterTitle, provider);
                            });
                            
                            chaptersList.appendChild(chapterCard);
                        });
                    } else {
                        chaptersList.innerHTML = '<p style="text-align: center; color: white; grid-column: 1 / -1;">No chapters available.</p>';
                    }
                } catch (error) {
                    console.error('Error loading chapters:', error);
                    chaptersList.innerHTML = '<p style="text-align: center; color: white; grid-column: 1 / -1;">Failed to load chapters.</p>';
                }
            }
            
            async function readMangaChapter(id, chapterId, chapterTitle, provider) {
                // Hide details modal and manga page
                mangaDetailsModal.style.display = 'none';
                document.getElementById('manga-page').style.display = 'none';
                
                // Show reader page
                mangaReaderPage.style.display = 'block';
                document.getElementById('mangaReaderTitle').textContent = chapterTitle;
                document.getElementById('mangaReaderPages').innerHTML = '';
                document.getElementById('mangaReaderLoading').style.display = 'block';
                
                if (!provider) provider = mangaSource;

                // Store current reading context for progress tracking
                window.currentMangaReadingContext = { provider, mangaId: id, chapterId };

                try {
                    let url;
                    if (provider === 'comix') {
                        url = `http://localhost:6987/api/comix/manga/chapters/${id}/${chapterId}`;
                    } else {
                        url = `http://localhost:6987/api/chapter/pages?chapterId=${encodeURIComponent(chapterId)}`;
                    }

                    const response = await fetch(url);
                    const data = await response.json();
                    
                    document.getElementById('mangaReaderLoading').style.display = 'none';
                    const pagesContainer = document.getElementById('mangaReaderPages');

                    let pages = [];
                    if (provider === 'comix' && data.status === 'success') {
                        pages = data.pages;
                    } else if (provider === 'weebcentral' && data.success) {
                        pages = data.pages;
                    }

                    if (pages && pages.length > 0) {
                        // Load saved progress
                        const savedPageIndex = loadMangaReadingProgress(provider, id, chapterId);
                        
                        pages.forEach((pageUrl, index) => {
                            const img = document.createElement('img');
                            img.src = pageUrl;
                            img.style.width = '100%';
                            img.style.marginBottom = '0.5rem';
                            img.className = 'manga-reader-page';
                            img.dataset.pageIndex = index;
                            img.loading = index <= savedPageIndex + 3 ? 'eager' : 'lazy';
                            pagesContainer.appendChild(img);
                        });
                        
                        // Scroll to saved page after images load
                        if (savedPageIndex > 0) {
                            const targetImg = pagesContainer.querySelector(`img[data-page-index="${savedPageIndex}"]`);
                            if (targetImg) {
                                const scrollToSaved = () => {
                                    targetImg.scrollIntoView({ behavior: 'instant', block: 'start' });
                                };
                                if (targetImg.complete) {
                                    setTimeout(scrollToSaved, 100);
                                } else {
                                    targetImg.addEventListener('load', scrollToSaved, { once: true });
                                }
                            }
                        }
                        
                        // Setup scroll tracking for progress saving
                        setupMangaReaderProgressTracking(pagesContainer, provider, id, chapterId);
                    } else {
                        pagesContainer.innerHTML = '<p style="color: #ef4444;">Could not load chapter pages.</p>';
                    }
                } catch (error) {
                    console.error('Error reading chapter:', error);
                    document.getElementById('mangaReaderLoading').innerHTML = '<p style="color: #ef4444;">Failed to load chapter. Please try again.</p>';
                }
            }
            
            function setupMangaReaderProgressTracking(container, provider, mangaId, chapterId) {
                let currentPageIndex = 0;
                let saveTimeout = null;
                
                const trackScroll = () => {
                    const pages = container.querySelectorAll('.manga-reader-page');
                    const containerRect = container.getBoundingClientRect();
                    const viewportCenter = window.innerHeight / 3;
                    
                    let closestPage = 0;
                    let closestDistance = Infinity;
                    
                    pages.forEach((img, index) => {
                        const rect = img.getBoundingClientRect();
                        const imgCenter = rect.top + rect.height / 2;
                        const distance = Math.abs(imgCenter - viewportCenter);
                        
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestPage = index;
                        }
                    });
                    
                    if (closestPage !== currentPageIndex) {
                        currentPageIndex = closestPage;
                        if (saveTimeout) clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            saveMangaReadingProgress(provider, mangaId, chapterId, currentPageIndex);
                        }, 500);
                    }
                };
                
                // Remove old listener if exists
                if (window.mangaScrollTracker) {
                    window.removeEventListener('scroll', window.mangaScrollTracker);
                }
                window.mangaScrollTracker = trackScroll;
                window.addEventListener('scroll', trackScroll);
            }
        }

// ==========================
//      COMICS SYSTEM
// ==========================

const API = "http://localhost:6987";

// State
let comicsCurrentPage = 1;
let comicsIsLoading = false;
let comicsHasMore = true;
let comicsIsSearchMode = false;
let comicsPageActive = false;

let comicsCurrentView = "browse";   // "browse" | "issues" | "reader"
let comicsCurrentComic = null;      // { slug, title? }
let comicsMode = "home";            // "home" | "genre" | "search" | "saved"
let comicsCurrentGenre = null;      // numeric genre id

// Comics Storage Helpers
const SAVED_COMICS_KEY = 'pt_saved_comics_v1';
function getSavedComics() {
    try { return JSON.parse(localStorage.getItem(SAVED_COMICS_KEY) || '[]'); } catch { return []; }
}
function setSavedComics(list) {
    localStorage.setItem(SAVED_COMICS_KEY, JSON.stringify(list));
}
function isComicSaved(slug) {
    return getSavedComics().some(c => c.slug === slug);
}
function toggleSaveComic(event, comic) {
    event.stopPropagation();
    const list = getSavedComics();
    const idx = list.findIndex(c => c.slug === comic.slug);
    const btn = event.currentTarget;
    
    if (idx >= 0) {
        list.splice(idx, 1);
        btn.classList.remove('in-list');
        btn.innerHTML = '<i class="fas fa-plus"></i>';
        showNotification('Removed from Saved Comics', 'info');
    } else {
        list.unshift(comic);
        btn.classList.add('in-list');
        btn.innerHTML = '<i class="fas fa-check"></i>';
        showNotification('Added to Saved Comics', 'success');
    }
    setSavedComics(list);
}

// Genre map for dropdown
const COMICS_GENRE_MAP = {
    "One Shots & TPBs": 17,
    "Marvel Comics": 34,
    "Boom Studios": 35,
    "Dynamite": 36,
    "Rebellion": 37,
    "Dark Horse": 38,
    "IDW": 39,
    "Archie": 40,
    "Graphic India": 41,
    "Darby Pop": 42,
    "Oni Press": 43,
    "Icon Comics": 44,
    "United Plankton": 45,
    "Udon": 46,
    "Image Comics": 47,
    "Valiant": 48,
    "Vertigo": 49,
    "Devils Due": 50,
    "Aftershock Comics": 51,
    "Antartic Press": 52,
    "Action Lab": 53,
    "American Mythology": 54,
    "Zenescope": 55,
    "Top Cow": 56,
    "Hermes Press": 57,
    "451": 58,
    "Black Mask": 59,
    "Chapterhouse Comics": 60,
    "Red 5": 61,
    "Heavy Metal": 62,
    "Bongo": 63,
    "Top Shelf": 64,
    "Bubble": 65,
    "Boundless": 66,
    "Avatar Press": 67,
    "Space Goat Productions": 68,
    "BroadSword Comics": 69,
    "AAM-Markosia": 70,
    "Fantagraphics": 71,
    "Aspen": 72,
    "American Gothic Press": 73,
    "Vault": 74,
    "215 Ink": 75,
    "Abstract Studio": 76,
    "Albatross": 77,
    "ARH Comix": 78,
    "Legendary Comics": 79,
    "Monkeybrain": 80,
    "Joe Books": 81,
    "MAD": 82,
    "Comics Experience": 83,
    "Alterna Comics": 84,
    "Lion Forge": 85,
    "Benitez": 86,
    "Storm King": 87,
    "Sucker": 88,
    "Amryl Entertainment": 89,
    "Ahoy Comics": 90,
    "Mad Cave": 91,
    "Coffin Comics": 92,
    "Magnetic Press": 93,
    "Ablaze": 94,
    "Europe Comics": 95,
    "Humanoids": 96,
    "TKO": 97,
    "Soleil": 98,
    "SAF Comics": 99,
    "Scholastic": 100,
    "AWA Studios": 101,
    "Stranger Comics": 102,
    "Inverse": 103,
    "Virus": 104,
    "Black Panel Press": 105,
    "Scout Comics": 106,
    "Source Point Press": 107,
    "First Second": 108,
    "DSTLRY": 109,
    "Yen Press": 110,
    "Alien Books": 111
};

// ==============================
//          VIEW SWITCHING
// ==============================
function showComicsView(view) {
    comicsCurrentView = view;

    const grid      = document.getElementById("comics-container");
    const issues    = document.getElementById("comics-issues-container");
    const reader    = document.getElementById("comics-reader-container");
    const loadMore  = document.getElementById("comics-load-more-container");
    const back      = document.getElementById("comics-back-btn");
    const loading   = document.getElementById("comics-loading");
    const zoomIn    = document.getElementById("comics-zoom-in-btn");
    const zoomOut   = document.getElementById("comics-zoom-out-btn");
    const fullscreenBtn = document.getElementById("comics-fullscreen-btn");

    if (!grid || !issues || !reader || !loadMore || !back || !loading) return;

    grid.style.display     = view === "browse" ? "grid"  : "none";
    issues.style.display   = view === "issues" ? "block" : "none";
    reader.style.display   = view === "reader" ? "block" : "none";
    loadMore.style.display = (view === "browse" && comicsMode !== "saved") ? "block" : "none";
    back.style.display     = view !== "browse" ? "inline-block" : "none";
    loading.style.display  = view === "browse" ? "block" : "none";
    
    // Show zoom buttons only in reader view
    if (zoomIn) zoomIn.style.display = view === "reader" ? "inline-block" : "none";
    if (zoomOut) zoomOut.style.display = view === "reader" ? "inline-block" : "none";
    if (fullscreenBtn) fullscreenBtn.style.display = view === "reader" ? "inline-block" : "none";
}

// ==============================
//      INITIALIZATION
// ==============================

function initializeComics() {
    console.log("[COMICS] initializeComics called");
    comicsPageActive = true;

    const container = document.getElementById("comics-container");
    if (!container) {
        console.log("[COMICS] comics-container not found");
        return;
    }

    // If nothing loaded yet, start from home page 1
    if (container.children.length === 0) {
        comicsCurrentPage   = 1;
        comicsHasMore       = true;
        comicsIsSearchMode  = false;
        comicsMode          = "home";
        comicsCurrentGenre  = null;
        showComicsView("browse");
        loadComicsAll(comicsCurrentPage);
    }
}

// ==============================
//      LOAD ALL / GENRE COMICS
// ==============================

async function loadComicsAll(page) {
    if (comicsIsLoading || !comicsHasMore || comicsIsSearchMode) return;

    const loader = document.getElementById("comics-loading");
    if (!loader) return;

    comicsIsLoading = true;
    loader.style.display = "block";
    loader.textContent = "Loading";

    try {
        let url = "";

        if (comicsMode === "home") {
            url = `${API}/comics/all?page=${page}`;
        } else if (comicsMode === "genre" && comicsCurrentGenre) {
            url = `${API}/comics/genres/${comicsCurrentGenre}?page=${page}`;
        } else {
            comicsIsLoading = false;
            loader.style.display = "none";
            return;
        }

        const res  = await fetch(url);
        const data = await res.json();

        const list = data.results || [];

        if (data.success && list.length > 0) {
            list.forEach(addComicToGrid);
            comicsCurrentPage++;
        } else {
            comicsHasMore = false;
            loader.textContent = "No more comics.";
        }
    } catch (err) {
        console.error("[COMICS] Failed to load comics:", err);
        loader.textContent = "Error loading comics.";
    }

    comicsIsLoading = false;
    loader.style.display = comicsHasMore ? "none" : "block";
}

// ==============================
//      SEARCH COMICS
// ==============================

async function searchComicsNew(query) {
    if (!query.trim()) return;

    const container = document.getElementById("comics-container");
    const loader    = document.getElementById("comics-loading");
    const browseBtn = document.getElementById("comics-browse-btn");

    comicsMode          = "search";
    comicsIsSearchMode  = true;
    comicsHasMore       = false;
    comicsCurrentPage   = 1;

    if (container) container.innerHTML = "";
    if (loader) {
        loader.style.display = "block";
        loader.textContent   = "Searching";
    }
    if (browseBtn) browseBtn.style.display = "inline-block";

    showComicsView("browse");

    try {
        const res  = await fetch(`${API}/comics/search/${encodeURIComponent(query)}`);
        const data = await res.json();

        const list = data.results || [];

        if (data.success && list.length > 0) {
            list.forEach(addComicToGrid);
            loader.textContent = `Found ${list.length} result(s).`;
        } else {
            loader.innerHTML = `<span style="color:#f44">No results found.</span>`;
        }
    } catch (error) {
        console.error("[COMICS] Search error:", error);
        loader.innerHTML = `<span style="color:#f44">Error during search.</span>`;
    }
}

// ==============================
//      ADD COMIC CARD TO GRID
// ==============================

function addComicToGrid(item) {
    const container = document.getElementById("comics-container");
    if (!container) return;

    const slug   = item.url.split("/comic/")[1];
    const poster = `${API}/comics-proxy?url=${encodeURIComponent(item.poster_url)}`;
    const isSaved = isComicSaved(slug);

    const div = document.createElement("div");
    div.className = "movie-card";
    div.style.cssText = `
        background: var(--card-bg);
        border-radius: 12px;
        overflow: hidden;
        transition: all 0.3s ease;
        cursor: pointer;
        border: 1px solid rgba(249, 115, 22, 0.2);
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;

    div.innerHTML = `
        <button class="add-to-list-btn ${isSaved ? 'in-list' : ''}" title="${isSaved ? 'Remove from Saved' : 'Save Comic'}">
            <i class="fas ${isSaved ? 'fa-check' : 'fa-plus'}"></i>
        </button>
        <img src="${poster}" 
             alt="${item.name}"
             style="width:100%;height:300px;object-fit:cover;display:block;"
             onerror="this.style.display='none'">
        <div style="padding: 12px; font-size: 14px; font-weight: 600; text-align: center; color: var(--light); min-height: 48px; display:flex; align-items:center; justify-content:center;">
            ${item.name}
        </div>
    `;

    div.onmouseenter = () => {
        div.style.transform   = "translateY(-6px)";
        div.style.borderColor = "#f97316";
        div.style.boxShadow   = "0 8px 20px rgba(249,115,22,0.5)";
    };
    div.onmouseleave = () => {
        div.style.transform   = "translateY(0)";
        div.style.borderColor = "rgba(249,115,22,0.2)";
        div.style.boxShadow   = "0 4px 12px rgba(0,0,0,0.3)";
    };

    // Save button handler
    const saveBtn = div.querySelector('.add-to-list-btn');
    saveBtn.addEventListener('click', (e) => {
        toggleSaveComic(e, { slug: slug, name: item.name, poster_url: item.poster_url, url: item.url });
    });

    div.addEventListener('click', (e) => {
        if (e.target.closest('.add-to-list-btn')) return;
        loadChapters(slug, item.name);
    });

    container.appendChild(div);
}

// ==============================
//          LOAD CHAPTERS
// ==============================

async function loadChapters(slug, title) {
    comicsCurrentComic = { slug, title };

    showComicsView("issues");

    const box = document.getElementById("comics-issues-container");
    if (!box) return;

    box.innerHTML = `<div style="padding:20px;color:#aaa;text-align:center;">Loading chapters</div>`;

    try {
        const res  = await fetch(`${API}/comics/chapters/${slug}`);
        const data = await res.json();

        box.innerHTML = "";

        if (!data.success || !data.chapters || !data.chapters.length) {
            box.innerHTML = `<div style="color:#f44;text-align:center;">No chapters found.</div>`;
            return;
        }

        if (title) {
            const h2 = document.createElement("h2");
            h2.textContent = title;
            h2.style.cssText = "text-align:center;margin-bottom:15px;color:#fff;";
            box.appendChild(h2);
        }

        data.chapters.forEach(ch => {
            const row = document.createElement("div");
            row.className = "comics-chapter-item";
            row.style.cssText = `
                background: var(--card-bg);
                border-radius: 8px;
                padding: 10px 14px;
                margin-bottom: 8px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border: 1px solid rgba(249,115,22,0.25);
                transition: all 0.2s ease;
            `;

            const left = document.createElement("span");
            left.textContent = ch.name || `Chapter ${ch.chapter}`;
            left.style.color = "var(--light)";
            left.style.fontWeight = "600";
            left.style.fontSize = "14px";

            const right = document.createElement("span");
            right.textContent = ch.date || "";
            right.style.color = "#9ca3af";
            right.style.fontSize = "12px";

            row.appendChild(left);
            row.appendChild(right);

            row.onmouseenter = () => {
                row.style.background  = "rgba(249,115,22,0.15)";
                row.style.borderColor = "#f97316";
                row.style.transform   = "translateX(6px)";
            };
            row.onmouseleave = () => {
                row.style.background  = "var(--card-bg)";
                row.style.borderColor = "rgba(249,115,22,0.25)";
                row.style.transform   = "translateX(0)";
            };

            row.onclick = () => loadPages(slug, ch.chapter, title, ch.name);

            box.appendChild(row);
        });

    } catch (err) {
        console.error("[COMICS] Error loading chapters:", err);
        box.innerHTML = `<div style="color:#f44;text-align:center;">Error loading chapters.</div>`;
    }
}

// ==============================
//          LOAD PAGES
// ==============================

async function loadPages(slug, chapter, comicTitle, chapterTitle) {
    showComicsView("reader");

    const reader = document.getElementById("comics-reader-container");
    if (!reader) return;

    reader.innerHTML = `
        <h2 style="text-align:center;margin-bottom:10px;color:#fff;">
            ${comicTitle || slug}
        </h2>
        <p style="text-align:center;margin-bottom:20px;color:#9ca3af;font-size:14px;">
            ${chapterTitle ? chapterTitle : "Chapter " + chapter}
        </p>
        <div style="text-align:center;padding:20px;color:#888;" id="comics-page-loader">
            Loading pages
        </div>
    `;

    try {
        const res  = await fetch(`${API}/comics/pages/${slug}/${chapter}`);
        const data = await res.json();

        const loader = document.getElementById("comics-page-loader");

        if (!data.success || !data.pages || !data.pages.length) {
            if (loader) loader.textContent = "No pages found.";
            return;
        }

        if (loader) loader.remove();

        data.pages.forEach(p => {
            const img = document.createElement("img");
            img.src   = `${API}/comics-proxy?url=${encodeURIComponent(p.url)}`;
            img.style.cssText = "width:100%;margin-bottom:10px;border-radius:10px;";
            img.loading = "lazy";
            img.onerror = () => { img.style.display = "none"; };
            reader.appendChild(img);
        });
    } catch (err) {
        console.error("[COMICS] Error loading pages:", err);
        const loader = document.getElementById("comics-page-loader");
        if (loader) {
            loader.textContent = "Error loading pages.";
            loader.style.color = "#f44";
        } else {
            reader.innerHTML += `<div style="color:#f44;text-align:center;">Error loading pages.</div>`;
        }
    }
}

// ==============================
//      INFINITE SCROLL
// ==============================

function handleComicsScroll() {
    if (!comicsPageActive) return;
    if (comicsCurrentView !== "browse") return;
    if (comicsIsSearchMode) return;
    if (comicsMode === "saved") return;

    const scrollBottom = window.innerHeight + window.scrollY;
    const docHeight    = document.body.offsetHeight;

    if (scrollBottom >= docHeight - 300) {
        loadComicsAll(comicsCurrentPage);
    }
}

let comicsScrollTimeout;
window.addEventListener("scroll", () => {
    if (comicsScrollTimeout) clearTimeout(comicsScrollTimeout);
    comicsScrollTimeout = setTimeout(handleComicsScroll, 120);
});

// ==============================
//      UI WIRING (search, buttons, genres)
// ==============================

(function wireComicsUI() {
    const searchInput  = document.getElementById("comics-search-input");
    const browseBtn    = document.getElementById("comics-browse-btn");
    const backBtn      = document.getElementById("comics-back-btn");
    const loadMoreBtn  = document.getElementById("comics-load-more-btn");
    const homeBtn      = document.getElementById("comics-home-btn");
    const savedBtn     = document.getElementById("comics-saved-btn");
    const genresSelect = document.getElementById("comics-genres-dropdown");
    const zoomInBtn    = document.getElementById("comics-zoom-in-btn");
    const zoomOutBtn   = document.getElementById("comics-zoom-out-btn");
    const fullscreenBtn = document.getElementById("comics-fullscreen-btn");

    // Populate genres dropdown
    if (genresSelect) {
        genresSelect.innerHTML = `<option value="">Genres</option>`;
        Object.entries(COMICS_GENRE_MAP).forEach(([name, id]) => {
            const opt = document.createElement("option");
            opt.value = String(id);
            opt.textContent = name;
            genresSelect.appendChild(opt);
        });

        genresSelect.addEventListener("change", () => {
            const val = genresSelect.value;
            const container = document.getElementById("comics-container");
            const loader    = document.getElementById("comics-loading");

            if (!val) {
                // Reset to home
                comicsMode          = "home";
                comicsCurrentGenre  = null;
                comicsIsSearchMode  = false;
                comicsHasMore       = true;
                comicsCurrentPage   = 1;
                if (container) container.innerHTML = "";
                if (loader) loader.textContent = "Loading";
                showComicsView("browse");
                loadComicsAll(comicsCurrentPage);
                return;
            }

            comicsMode         = "genre";
            comicsCurrentGenre = Number(val);
            comicsIsSearchMode = false;
            comicsHasMore      = true;
            comicsCurrentPage  = 1;

            if (container) container.innerHTML = "";
            if (loader) loader.textContent = "Loading";

            showComicsView("browse");
            loadComicsAll(comicsCurrentPage);
        });
    }

    // Search input with debounce
    if (searchInput) {
        let debounceId = null;

        searchInput.addEventListener("input", () => {
            if (debounceId) clearTimeout(debounceId);
            const q = searchInput.value.trim();

            if (!q) {
                // Reset back to browsing
                const container = document.getElementById("comics-container");
                const loader    = document.getElementById("comics-loading");
                const browseBtn = document.getElementById("comics-browse-btn");

                comicsMode          = "home";
                comicsIsSearchMode  = false;
                comicsHasMore       = true;
                comicsCurrentPage   = 1;
                comicsCurrentGenre  = null;

                if (container) container.innerHTML = "";
                if (loader) {
                    loader.textContent   = "Loading";
                    loader.style.display = "block";
                }
                if (browseBtn) browseBtn.style.display = "none";

                showComicsView("browse");
                loadComicsAll(comicsCurrentPage);
                return;
            }

            debounceId = setTimeout(() => {
                searchComicsNew(q);
            }, 500);
        });

        searchInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                const q = searchInput.value.trim();
                if (q) searchComicsNew(q);
            }
        });
    }

    // Browse all (after search)
    if (browseBtn) {
        browseBtn.addEventListener("click", () => {
            const container = document.getElementById("comics-container");
            const loader    = document.getElementById("comics-loading");

            comicsMode          = "home";
            comicsIsSearchMode  = false;
            comicsHasMore       = true;
            comicsCurrentPage   = 1;
            comicsCurrentGenre  = null;

            if (container) container.innerHTML = "";
            if (loader) {
                loader.textContent   = "Loading";
                loader.style.display = "block";
            }
            browseBtn.style.display = "none";

            if (searchInput) searchInput.value = "";

            showComicsView("browse");
            loadComicsAll(comicsCurrentPage);
        });
    }

    // Back button (issues/reader  previous)
    if (backBtn) {
        backBtn.addEventListener("click", () => {
            if (comicsCurrentView === "reader" && comicsCurrentComic) {
                // Back to issues
                loadChapters(comicsCurrentComic.slug, comicsCurrentComic.title);
            } else {
                // Back to browse
                showComicsView("browse");
            }
        });
    }

    // Load more button
    if (loadMoreBtn) {
        loadMoreBtn.addEventListener("click", () => {
            loadComicsAll(comicsCurrentPage);
        });
    }

    // Home button: full reset
    if (homeBtn) {
        homeBtn.addEventListener("click", () => {
            const container = document.getElementById("comics-container");
            const loader    = document.getElementById("comics-loading");

            if (searchInput) searchInput.value = "";
            if (genresSelect) genresSelect.value = "";

            comicsMode          = "home";
            comicsCurrentGenre  = null;
            comicsIsSearchMode  = false;
            comicsHasMore       = true;
            comicsCurrentPage   = 1;

            if (container) container.innerHTML = "";
            if (loader) {
                loader.textContent   = "Loading";
                loader.style.display = "block";
            }

            showComicsView("browse");
            loadComicsAll(comicsCurrentPage);
        });
    }
    
    // Zoom controls
    let comicsZoom = 1000;
    const readerContainer = document.getElementById("comics-reader-container");
    
    if (zoomInBtn) {
        zoomInBtn.addEventListener("click", () => {
            comicsZoom += 200;
            if (readerContainer) readerContainer.style.maxWidth = `${comicsZoom}px`;
        });
    }
    if (zoomOutBtn) {
        zoomOutBtn.addEventListener("click", () => {
            if (comicsZoom > 400) comicsZoom -= 200;
            if (readerContainer) readerContainer.style.maxWidth = `${comicsZoom}px`;
        });
    }

    if (fullscreenBtn) {
        fullscreenBtn.addEventListener("click", () => {
            toggleReaderFullscreen();
        });
    }

    // Saved button
    if (savedBtn) {
        savedBtn.addEventListener("click", () => {
            const container = document.getElementById("comics-container");
            const loader    = document.getElementById("comics-loading");
            
            if (searchInput) searchInput.value = "";
            if (genresSelect) genresSelect.value = "";
            
            comicsMode = "saved";
            comicsIsSearchMode = false;
            comicsHasMore = false;
            
            if (container) container.innerHTML = "";
            if (loader) loader.style.display = "none";
            
            showComicsView("browse");
            const saved = getSavedComics();
            if (saved.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--gray); grid-column: 1 / -1; padding: 2rem;">No saved comics yet.</p>';
            } else {
                saved.forEach(addComicToGrid);
            }
        });
    }
})();



        // Initialize the app on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', init);

        // Listen for fullscreen change event to handle ESC key
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                document.body.classList.remove('reader-fullscreen-mode');
                const comicsBtn = document.getElementById('comics-fullscreen-btn');
                const mangaBtn = document.getElementById('mangaFullscreenBtn');
                if (comicsBtn) comicsBtn.innerHTML = '<i class="fas fa-expand"></i>';
                if (mangaBtn) mangaBtn.innerHTML = '<i class="fas fa-expand"></i>';
            } else {
                const comicsBtn = document.getElementById('comics-fullscreen-btn');
                const mangaBtn = document.getElementById('mangaFullscreenBtn');
                if (comicsBtn) comicsBtn.innerHTML = '<i class="fas fa-compress"></i>';
                if (mangaBtn) mangaBtn.innerHTML = '<i class="fas fa-compress"></i>';
            }
        });

        // ---- Resume helpers ----

        // ---- EPUB Reader Logic ----
        let rendition = null;
        let bookInstance = null;
    let chapterToc = null;
    let chapterSpineItems = null;
    let chapterTotal = 0;
        let isReaderFocusMode = false;
        let focusRulerTopPx = 80;
        let focusRulerHeightPx = 0;
        let focusRulerOffset = 0;
        let rulerObserver = null;

        async function openEpubReader(localPath, title) {
            try {
                console.log('[EPUB] Opening:', localPath);
                const overlay = document.getElementById('epubReaderOverlay');
                const titleEl = document.getElementById('readerTitle');
                const container = document.getElementById('readerContainer');
                const prevBtn = document.getElementById('readerPrevBtn');
                const nextBtn = document.getElementById('readerNextBtn');

                titleEl.textContent = title || 'EPUB Reader';
                overlay.classList.add('theme-dark');
                overlay.classList.remove('theme-light', 'theme-night');
                overlay.style.display = 'flex';

                // Clear previous
                container.innerHTML = '';
                rendition = null;
                bookInstance = null;
                prevBtn.disabled = true;
                nextBtn.disabled = false;

                // Load epub.js and JSZip first
                if (!window.ePub || !window.JSZip) {
                    console.log('[EPUB] Loading libraries...');
                    
                    if (!window.JSZip) {
                        const jszipScript = document.createElement('script');
                        jszipScript.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
                        await new Promise((resolve, reject) => {
                            jszipScript.onload = resolve;
                            jszipScript.onerror = reject;
                            document.head.appendChild(jszipScript);
                        });
                        console.log('[EPUB] JSZip loaded');
                    }

                    if (!window.ePub) {
                        const epubScript = document.createElement('script');
                        epubScript.src = 'https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js';
                        await new Promise((resolve, reject) => {
                            epubScript.onload = resolve;
                            epubScript.onerror = reject;
                            document.head.appendChild(epubScript);
                        });
                        console.log('[EPUB] epub.js loaded');
                    }
                }

                // Read the file from main
                console.log('[EPUB] Reading file...');
                const res = await window.electronAPI.readEpubFile(localPath);
                console.log('[EPUB] Read result:', res.success, res.base64 ? `${res.base64.length} bytes` : 'no data');
                if (!res.success || !res.base64) {
                    alert('Failed to open book: ' + (res.message || 'Unable to read file'));
                    overlay.style.display = 'none';
                    return;
                }
                console.log('[EPUB] Converting to ArrayBuffer...');
                const binaryString = atob(res.base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                console.log('[EPUB] ArrayBuffer size:', bytes.length);

                console.log('[EPUB] Creating book instance...');
                bookInstance = window.ePub(bytes.buffer);
                
                console.log('[EPUB] Rendering to container...');
                rendition = bookInstance.renderTo(container, { 
                    width: '100%', 
                    height: '100%',
                    spread: 'none',
                    flow: 'paginated'
                });
                
                // Listen for keydown in the iframe to support Focus Mode navigation
                rendition.on('keydown', (e) => {
                    handleReaderKeydown(e);
                });
                
                // Create a unique key for this book based on its path
                const bookKey = 'epub_position_' + encodeURIComponent(localPath);
                
                // Wire navigation and save position on page change
                rendition.on('relocated', (location) => {
                    console.log('[EPUB] Relocated:', location.atStart, location.atEnd);
                    prevBtn.disabled = location.atStart;
                    nextBtn.disabled = location.atEnd;
                    
                    if (isReaderFocusMode) {
                        focusRulerOffset = 0; // Reset manual offset on page turn
                        [100, 300, 600].forEach(t => setTimeout(alignFocusRulerToText, t));
                    }
                    
                    // Save current position to localStorage
                    if (location && location.start && location.start.cfi) {
                        try {
                            localStorage.setItem(bookKey, location.start.cfi);
                            console.log('[EPUB] Saved position:', location.start.cfi);
                        } catch (e) {
                            console.warn('[EPUB] Could not save position:', e);
                        }
                    }
                });

                // Try to restore last position
                let restored = false;
                try {
                    const savedPosition = localStorage.getItem(bookKey);
                    if (savedPosition) {
                        console.log('[EPUB] Restoring position:', savedPosition);
                        await rendition.display(savedPosition);
                        restored = true;
                        console.log('[EPUB] Position restored successfully');
                    }
                } catch (e) {
                    console.warn('[EPUB] Could not restore position:', e);
                }
                
                // If no saved position or restore failed, display from beginning
                if (!restored) {
                    console.log('[EPUB] Displaying from beginning...');
                    await rendition.display();
                }
                
                console.log('[EPUB] Book opened successfully');

                // Apply initial theme/font/size
                applyReaderPrefs();

                // Initialize chapter controls (count and input range)
                await initChapterControls();
                
                // Reset focus mode on open
                isReaderFocusMode = false;
                updateFocusModeUI();
            } catch (err) {
                console.error('[EPUB] Error:', err);
                alert('Could not open the EPUB: ' + err.message);
                const overlay = document.getElementById('epubReaderOverlay');
                overlay.style.display = 'none';
            }
        }

        function closeEpubReader() {
            const overlay = document.getElementById('epubReaderOverlay');
            const settingsPanel = document.getElementById('readerSettingsPanel');
            overlay.style.display = 'none';
            settingsPanel.classList.add('hidden');
            // Cleanup
            if (rendition) { try { rendition.destroy(); } catch(_){} }
            rendition = null;
            bookInstance = null;
            chapterToc = null;
            chapterSpineItems = null;
            chapterTotal = 0;
            const chapterControls = document.getElementById('readerChapterControls');
            if (chapterControls) chapterControls.style.display = 'none';
            isReaderFocusMode = false;
            updateFocusModeUI();
        }

        // Escape key to close reader
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const overlay = document.getElementById('epubReaderOverlay');
                if (overlay && overlay.style.display === 'flex') {
                    closeEpubReader();
                }
            }
        });

        // Settings handling
        function applyReaderPrefs() {
            const overlay = document.getElementById('epubReaderOverlay');
            const theme = localStorage.getItem('reader.theme') || 'dark';
            const font = localStorage.getItem('reader.font') || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif";
            const size = parseInt(localStorage.getItem('reader.size') || '16', 10);
            const lineHeight = localStorage.getItem('reader.lineHeight') || '1.5';
            const width = parseInt(localStorage.getItem('reader.width') || '80', 10);
            const align = localStorage.getItem('reader.align') || 'left';
            const focusSpeed = parseInt(localStorage.getItem('reader.focusSpeed') || '2', 10);

            overlay.classList.remove('theme-light', 'theme-dark', 'theme-night');
            overlay.classList.add(`theme-${theme}`);
            
            // Update UI controls
            const fontSelect = document.getElementById('readerFont');
            const sizeInput = document.getElementById('readerFontSize');
            const lhInput = document.getElementById('readerLineHeight');
            const widthInput = document.getElementById('readerWidth');
            const speedInput = document.getElementById('focusSpeedInput');
            
            if (fontSelect) fontSelect.value = font;
            if (sizeInput) sizeInput.value = size;
            if (lhInput) lhInput.value = lineHeight;
            if (widthInput) widthInput.value = width;
            if (speedInput) {
                speedInput.value = focusSpeed;
                const valEl = document.getElementById('focusSpeedVal');
                if (valEl) valEl.textContent = focusSpeed;
            }
            
            const sizeVal = document.getElementById('readerFontSizeVal');
            const lhVal = document.getElementById('readerLineHeightVal');
            const widthVal = document.getElementById('readerWidthVal');
            
            if (sizeVal) sizeVal.textContent = `${size}px`;
            if (lhVal) lhVal.textContent = lineHeight;
            if (widthVal) widthVal.textContent = `${width}%`;
            
            document.querySelectorAll('.align-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.align === align);
            });
            
            // Re-align focus ruler if active
            if (isReaderFocusMode) {
                focusRulerHeightPx = 0; // Force recalculation of height
                updateFocusModeUI();
                [200, 400, 800].forEach(t => setTimeout(alignFocusRulerToText, t));
            }

            if (rendition) {
                // Map explicit colors for the iframe
                let fg = '#f2f2f2', bg = '#202225';
                if (theme === 'light') { fg = '#111111'; bg = '#ffffff'; }
                else if (theme === 'night') { fg = '#e5e7eb'; bg = '#000000'; }
                
                // Calculate padding for width simulation
                const padding = Math.max(0, (100 - width) / 2);
                
                // Register and select theme with font
                try { 
                    rendition.themes.register('custom', { 
                        'body': { 
                            'font-family': `${font} !important`, 
                            'color': fg, 
                            'background': bg,
                            'padding-left': `${padding}% !important`,
                            'padding-right': `${padding}% !important`,
                            'text-align': `${align} !important`,
                            'line-height': `${lineHeight} !important`
                        },
                        'p': {
                            'font-family': `${font} !important`,
                            'line-height': `${lineHeight} !important`,
                            'text-align': `${align} !important`
                        },
                        '*': {
                            'font-family': `${font} !important`
                        }
                    }); 
                } catch(e){ console.log('[EPUB] Theme register error:', e); }
                try { rendition.themes.select('custom'); } catch(e){ console.log('[EPUB] Theme select error:', e); }
                try { rendition.themes.fontSize(`${size}px`); } catch(e){ console.log('[EPUB] Font size error:', e); }
                
                // Force font update
                try {
                    rendition.themes.default({
                        'body': { 
                            'font-family': `${font} !important`,
                            'padding-left': `${padding}% !important`,
                            'padding-right': `${padding}% !important`,
                            'text-align': `${align} !important`,
                            'line-height': `${lineHeight} !important`
                        },
                        'p': { 
                            'font-family': `${font} !important`,
                            'line-height': `${lineHeight} !important`,
                            'text-align': `${align} !important`
                        },
                        'div': { 'font-family': `${font} !important` },
                        'span': { 'font-family': `${font} !important` }
                    });
                } catch(e){ }
            }
        }

        function updateFocusModeUI() {
            const ruler = document.getElementById('focusRuler');
            const btn = document.getElementById('focusModeBtn');
            
            if (isReaderFocusMode) {
                // Calculate grid based on settings
                const size = parseInt(localStorage.getItem('reader.size') || '16', 10);
                const lh = parseFloat(localStorage.getItem('reader.lineHeight') || '1.5');
                const calcHeight = size * lh; 
                const heightPx = focusRulerHeightPx > 0 ? focusRulerHeightPx : calcHeight;

                if (ruler) {
                    ruler.style.display = 'block';
                    ruler.style.height = `${heightPx}px`;
                    ruler.style.top = `${focusRulerTopPx}px`;
                }
                if (btn) {
                    btn.classList.add('active');
                    btn.innerHTML = '<i class="fas fa-eye"></i> Focus Active';
                }
            } else {
                if (ruler) ruler.style.display = 'none';
                if (btn) {
                    btn.classList.remove('active');
                    btn.innerHTML = '<i class="fas fa-eye"></i> Enable Focus';
                }
            }
        }

        function alignFocusRulerToText() {
            if (!rendition) return;
            try {
                const contents = rendition.getContents();
                if (!contents || contents.length === 0) return;
                const doc = contents[0].document;
                const iframe = document.querySelector('#readerContainer iframe');
                if (!iframe) return;
                
                // Attach observer if new document or not exists
                if (!rulerObserver || rulerObserver._doc !== doc) {
                    if (rulerObserver) rulerObserver.disconnect();
                    rulerObserver = new MutationObserver(() => {
                        // Debounce slightly or run immediate? 
                        // Immediate is better for "sticking", but risk of thrashing.
                        // We'll use requestAnimationFrame to align in next frame
                        requestAnimationFrame(() => alignFocusRulerToText());
                    });
                    rulerObserver.observe(doc.body, { childList: true, attributes: true, subtree: true, characterData: true });
                    rulerObserver._doc = doc;
                }

                const overlay = document.getElementById('epubReaderOverlay');
                const overlayRect = overlay.getBoundingClientRect();
                const iframeRect = iframe.getBoundingClientRect();
                const borderTop = iframe.clientTop || 0;
                const borderLeft = iframe.clientLeft || 0;

                const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null, false);
                let node;
                
                while (node = walker.nextNode()) {
                    if (!node.textContent.trim()) continue;
                    
                    // Skip if parent is a heading
                    const parentTag = node.parentNode.tagName.toLowerCase();
                    if (/^h[1-6]$/.test(parentTag)) continue;

                    const range = doc.createRange();
                    range.selectNodeContents(node);
                    const rects = range.getClientRects();

                    // Use user settings for exact sizing
                    const userSize = parseInt(localStorage.getItem('reader.size') || '16', 10);
                    const userLh = parseFloat(localStorage.getItem('reader.lineHeight') || '1.5');
                    const targetHeight = userSize * userLh;

                    for (const rect of rects) {
                        // Check if at least partially visible vertically
                        if (rect.bottom > 0 && rect.top < iframe.clientHeight && rect.width > 0) {
                             // Check horizontal visibility roughly
                             if (rect.left < iframe.clientWidth) {
                                focusRulerHeightPx = targetHeight;
                                // Center the ruler over the text rect
                                const center = rect.top + (rect.height / 2);
                                // Calculate position relative to overlay
                                const relativeTop = (iframeRect.top - overlayRect.top) + borderTop + (center - targetHeight / 2);
                                focusRulerTopPx = relativeTop + focusRulerOffset;
                                updateFocusModeUI();
                                return;
                             }
                        }
                    }
                }
            } catch (e) {
                console.error('Error aligning focus ruler:', e);
            }
        }

        function toggleReaderFocusMode() {
            isReaderFocusMode = !isReaderFocusMode;
            if (isReaderFocusMode) {
                localStorage.setItem('reader.theme', 'night');
                focusRulerOffset = 0; // Reset offset on enable
                applyReaderPrefs();
                // Start near top, aligned to grid
                const size = parseInt(localStorage.getItem('reader.size') || '16', 10);
                const lh = parseFloat(localStorage.getItem('reader.lineHeight') || '1.5');
                const step = size * lh;
                focusRulerTopPx = Math.ceil(80 / step) * step;
                [100, 300, 600].forEach(t => setTimeout(alignFocusRulerToText, t));
            }
            updateFocusModeUI();
        }

        // Header buttons
        document.addEventListener('click', (e) => {
            if (e.target.closest('#readerPrevBtn')) {
                if (rendition) {
                    console.log('[EPUB] Going to previous page');
                    rendition.prev();
                }
            }
            if (e.target.closest('#readerNextBtn')) {
                if (rendition) {
                    console.log('[EPUB] Going to next page');
                    rendition.next();
                }
            }
            if (e.target.closest('#readerChapterGo')) {
                const inputEl = document.getElementById('readerChapterInput');
                if (!inputEl) return;
                const val = parseInt(inputEl.value, 10);
                goToChapterIndex(val);
            }
            if (e.target.closest('#readerSettingsBtn')) {
                const panel = document.getElementById('readerSettingsPanel');
                const wasHidden = panel.classList.contains('hidden');
                panel.classList.toggle('hidden');
                
                // Restore current values when opening settings
                if (wasHidden) {
                    applyReaderPrefs(); // Re-sync UI
                }
                
                console.log('[EPUB] Settings panel toggled:', wasHidden ? 'now visible' : 'now hidden');
            }
            if (e.target.closest('#readerBackBtn')) {
                console.log('[EPUB] Back button clicked');
                closeEpubReader();
            }
        });

        // Handle Enter key on the chapter input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target && e.target.id === 'readerChapterInput') {
                const val = parseInt(e.target.value, 10);
                goToChapterIndex(val);
            }
        });

        // Settings controls
        document.addEventListener('click', (e) => {
            const themeBtn = e.target.closest('.theme-btn');
            if (themeBtn) {
                const theme = themeBtn.getAttribute('data-theme');
                localStorage.setItem('reader.theme', theme);
                applyReaderPrefs();
            }
            
            const alignBtn = e.target.closest('.align-btn');
            if (alignBtn) {
                const align = alignBtn.getAttribute('data-align');
                localStorage.setItem('reader.align', align);
                applyReaderPrefs();
            }
            
            if (e.target.closest('#focusModeBtn')) {
                toggleReaderFocusMode();
            }
        });
        document.addEventListener('input', (e) => {
            if (e.target.id === 'readerFont') {
                localStorage.setItem('reader.font', e.target.value);
                applyReaderPrefs();
            } else if (e.target.id === 'readerFontSize') {
                localStorage.setItem('reader.size', e.target.value);
                applyReaderPrefs();
            } else if (e.target.id === 'readerLineHeight') {
                localStorage.setItem('reader.lineHeight', e.target.value);
                applyReaderPrefs();
            } else if (e.target.id === 'readerWidth') {
                localStorage.setItem('reader.width', e.target.value);
                applyReaderPrefs();
            } else if (e.target.id === 'focusSpeedInput') {
                localStorage.setItem('reader.focusSpeed', e.target.value);
                const valEl = document.getElementById('focusSpeedVal');
                if (valEl) valEl.textContent = e.target.value;
            }
        });
        
        function handleReaderKeydown(e) {
            if (!isReaderFocusMode) return;
            const overlay = document.getElementById('epubReaderOverlay');
            if (!overlay || overlay.style.display === 'none') return;
            
            const container = document.getElementById('readerContainer');
            const maxH = container ? container.clientHeight : window.innerHeight;
            const speed = parseInt(localStorage.getItem('reader.focusSpeed') || '2', 10);
            
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                focusRulerOffset -= speed;
                focusRulerTopPx -= speed; // Update immediately visual
                updateFocusModeUI();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                focusRulerOffset += speed;
                focusRulerTopPx += speed; // Update immediately visual
                updateFocusModeUI();
            }
        }

        // Focus Mode Arrow Keys
        document.addEventListener('keydown', handleReaderKeydown);

        // Expose open function if needed elsewhere
        window.openEpubReader = openEpubReader;
        
        // Initialize chapter controls: compute total and prepare UI
        async function initChapterControls() {
            try {
                const controls = document.getElementById('readerChapterControls');
                const countEl = document.getElementById('readerChapterCount');
                const inputEl = document.getElementById('readerChapterInput');
                if (!controls || !countEl || !inputEl) return;

                if (!bookInstance) {
                    controls.style.display = 'none';
                    return;
                }

                chapterToc = null;
                chapterSpineItems = null;
                chapterTotal = 0;

                // Try to load navigation (TOC)
                try {
                    const nav = await bookInstance.loaded?.navigation;
                    if (nav && Array.isArray(nav.toc) && nav.toc.length > 0) {
                        chapterToc = nav.toc;
                        chapterTotal = chapterToc.length;
                    }
                } catch(_) {}

                // Fallback to spine items
                if (!chapterTotal) {
                    try {
                        const spine = await bookInstance.loaded?.spine;
                        if (spine && Array.isArray(spine.spineItems) && spine.spineItems.length > 0) {
                            chapterSpineItems = spine.spineItems;
                            chapterTotal = chapterSpineItems.length;
                        } else if (bookInstance.spine && Array.isArray(bookInstance.spine.spineItems) && bookInstance.spine.spineItems.length > 0) {
                            chapterSpineItems = bookInstance.spine.spineItems;
                            chapterTotal = chapterSpineItems.length;
                        }
                    } catch(_) {}
                }

                if (chapterTotal > 0) {
                    controls.style.display = 'flex';
                    countEl.textContent = String(chapterTotal);
                    inputEl.max = String(chapterTotal);
                    inputEl.placeholder = `1-${chapterTotal}`;
                } else {
                    controls.style.display = 'none';
                }
            } catch (e) {
                console.warn('[EPUB] Could not initialize chapter controls:', e);
            }
        }

        // Jump to a given 1-based chapter index
        async function goToChapterIndex(n) {
            const inputEl = document.getElementById('readerChapterInput');
            if (!bookInstance || !rendition || !Number.isFinite(n)) {
                if (inputEl) flashInvalid(inputEl);
                return;
            }
            const total = chapterTotal || 0;
            if (!total) {
                if (inputEl) flashInvalid(inputEl);
                return;
            }
            let idx = Math.floor(n) - 1;
            if (idx < 0 || idx >= total) {
                if (inputEl) flashInvalid(inputEl);
                return;
            }
            try {
                let targetHref = null;
                if (chapterToc && chapterToc[idx] && chapterToc[idx].href) {
                    targetHref = chapterToc[idx].href;
                } else if (chapterSpineItems && chapterSpineItems[idx] && chapterSpineItems[idx].href) {
                    targetHref = chapterSpineItems[idx].href;
                }
                if (targetHref) {
                    await rendition.display(targetHref);
                } else {
                    // As a last resort, try using the spine index directly if available
                    if (typeof bookInstance.spine?.get === 'function') {
                        const item = bookInstance.spine.get(idx);
                        if (item && item.href) {
                            await rendition.display(item.href);
                            return;
                        }
                    }
                    throw new Error('No valid chapter target');
                }
            } catch (err) {
                console.warn('[EPUB] Failed to jump to chapter', n, err);
                if (inputEl) flashInvalid(inputEl);
            }
        }

        function flashInvalid(inputEl) {
            const orig = inputEl.style.borderColor;
            inputEl.style.borderColor = 'rgba(244,63,94,0.85)';
            setTimeout(() => { inputEl.style.borderColor = orig || 'rgba(255,255,255,0.15)'; }, 450);
        }
        async function fetchResume(key) {
            if (!key) return null;
            try {
                const r = await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(key)}`);
                if (!r.ok) return null;
                const j = await r.json();
                if (j && typeof j.position === 'number' && j.position > 0) return j;
            } catch(_){ }
            return null;
        }
        async function saveResume() {
            if (!resumeKey || !customVideo || !isFinite(customVideo.duration) || !isFinite(customVideo.currentTime)) return;
            const pos = Math.max(0, Math.floor(customVideo.currentTime || 0));
            const dur = Math.max(0, Math.floor(customVideo.duration || 0));
            // Use TMDB title from currentContent, not the filename
            const title = (currentContent?.title || currentContent?.name || currentSelectedVideoName || '');
            if (dur === 0 || pos === 0) return;
            try {
                const payload = { 
                    key: resumeKey, 
                    position: pos, 
                    duration: dur, 
                    title 
                };
                // Add poster and metadata if available from currentContent
                if (currentContent) {
                    if (currentContent.poster_path) payload.poster_path = currentContent.poster_path;
                    if (currentContent.id) payload.tmdb_id = currentContent.id;
                    if (currentMediaType) payload.media_type = currentMediaType;
                    // Add season/episode for TV shows
                    if (currentMediaType === 'tv' && typeof currentSeason !== 'undefined') {
                        payload.season = currentSeason;
                        if (typeof currentEpisode !== 'undefined') payload.episode = currentEpisode;
                    }
                }
                await fetch(`${API_BASE_URL}/resume`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            } catch(_){ }
        }
        function saveResumeThrottled(immediate = false) {
            const now = Date.now();
            if (immediate || now - lastResumeSend > 2500) {
                lastResumeSend = now;
                clearTimeout(resumeTimer);
                resumeTimer = null;
                saveResume();
                return;
            }
            if (!resumeTimer) {
                resumeTimer = setTimeout(() => { lastResumeSend = Date.now(); saveResume(); resumeTimer = null; }, 1500);
            }
        }
        try {
            customVideo.addEventListener('ended', async () => {
                if (resumeKey) {
                    try { await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(resumeKey)}`, { method: 'DELETE' }); } catch(_){ }
                }
            });
        } catch(_){ }

        // Continue Watching functionality
        async function loadContinueWatching() {
            try {
                const response = await fetch(`${API_BASE_URL}/resume/all`);
                if (!response.ok) return;
                
                const items = await response.json();
                if (!Array.isArray(items) || items.length === 0) {
                    // Hide section if no items
                    document.getElementById('continueWatchingSection').style.display = 'none';
                    return;
                }
                
                // Show section
                document.getElementById('continueWatchingSection').style.display = 'block';
                
                // Render items
                const slider = document.getElementById('continueWatchingSlider');
                slider.innerHTML = '';
                
                for (const item of items) {
                    if (!item.title || !item.key) continue;
                    
                    const card = document.createElement('div');
                    card.className = 'movie-card continue-watching-card';
                    card.dataset.resumeKey = item.key;
                    
                    const progress = item.duration > 0 ? ((item.position / item.duration) * 100).toFixed(1) : 0;
                    
                    // For TV shows, show season; for movies, show time left
                    let subtitleText = '';
                    if (item.media_type === 'tv' && item.season) {
                        subtitleText = `Season ${item.season}`;
                    } else {
                        const timeLeft = item.duration > 0 ? formatTime(item.duration - item.position) : '';
                        subtitleText = timeLeft ? `${timeLeft} left` : '';
                    }
                    
                    // Use poster if available, otherwise show placeholder
                    const posterHTML = item.poster_path 
                        ? `<img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${item.title.replace(/'/g, "\\'")}">` 
                        : `<div class="continue-watching-placeholder">
                            <i class="fas fa-play-circle"></i>
                           </div>`;
                    
                    card.innerHTML = `
                        <button class="remove-continue-btn" onclick="removeContinueWatching(event, '${item.key.replace(/'/g, "\\'")}')">
                            <i class="fas fa-times"></i>
                        </button>
                        <div class="movie-poster">
                            ${posterHTML}
                            <div class="continue-watching-progress" style="width: ${progress}%"></div>
                        </div>
                        <div class="movie-info">
                            <h3 class="movie-title">${item.title}</h3>
                            <p class="movie-year">${subtitleText}</p>
                        </div>
                        <div class="movie-rating">
                            <i class="fas fa-clock"></i> ${progress}%
                        </div>
                    `;
                    
                    // Click handler - open details modal directly like trending cards do
                    card.addEventListener('click', (e) => {
                        if (e.target.closest('.remove-continue-btn')) return;
                        
                        if (item.tmdb_id && item.media_type) {
                            // Create a movie object compatible with openDetailsModal
                            const movieObj = {
                                id: item.tmdb_id,
                                title: item.title,
                                name: item.title,
                                poster_path: item.poster_path,
                                media_type: item.media_type
                            };
                            openDetailsModal(movieObj, item.media_type);
                        } else {
                            showNotification('Details not available for this item (missing metadata). Try watching it again to update.', 'info', 4000);
                        }
                    });
                    
                    slider.appendChild(card);
                }
                
            } catch (error) {
                console.error('[Continue Watching] Load error:', error);
                document.getElementById('continueWatchingSection').style.display = 'none';
            }
        }
        
        async function removeContinueWatching(event, key) {
            event.stopPropagation();
            
            try {
                const response = await fetch(`${API_BASE_URL}/resume?key=${encodeURIComponent(key)}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    // Remove card from DOM
                    const card = document.querySelector(`[data-resume-key="${key}"]`);
                    if (card) {
                        card.style.transition = 'opacity 0.3s, transform 0.3s';
                        card.style.opacity = '0';
                        card.style.transform = 'scale(0.8)';
                        setTimeout(() => {
                            card.remove();
                            // Check if any cards left
                            const slider = document.getElementById('continueWatchingSlider');
                            if (slider.children.length === 0) {
                                document.getElementById('continueWatchingSection').style.display = 'none';
                            }
                        }, 300);
                    }
                    showNotification('Removed from Continue Watching', 'success');
                } else {
                    showNotification('Failed to remove item', 'error');
                }
            } catch (error) {
                console.error('[Continue Watching] Remove error:', error);
                showNotification('Failed to remove item', 'error');
            }
        }
        
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return `${h}h ${m}m`;
            if (m > 0) return `${m}m`;
            return `${s}s`;
        }

        // Hook version notice (v1.6.3) from main
        try {
            if (window.electronAPI?.onVersionNotice163) {
                window.electronAPI.onVersionNotice163(() => {
                    showVersion163Modal();
                });
            }
        } catch(_) {}

        // ---- Updater overlay wiring (non-intrusive) ----
        try {
            const overlay = document.getElementById('updateOverlay');
            const icon = document.getElementById('updateStatusIcon');
            const text = document.getElementById('updateStatusText');
            const bar = document.getElementById('updateProgressBar');
            const pct = document.getElementById('updatePercent');
            const restartBtn = document.getElementById('updateRestartBtn');

            function showOverlay() {
                if (overlay) overlay.style.display = 'flex';
                document.body && (document.body.style.overflow = 'hidden');
            }
            function hideOverlay() {
                if (overlay) overlay.style.display = 'none';
                document.body && (document.body.style.overflow = 'auto');
            }

            if (window.electronAPI) {
                // When update check starts, show longer notification
                window.electronAPI.onUpdateChecking?.((_info) => {
                    console.log('[Update] Checking for updates...');
                    showNotification(' Checking for updates...', 'info', 5000); // Show for 5 seconds
                });

                // When no update is available, show longer notification
                window.electronAPI.onUpdateNotAvailable?.((_info) => {
                    console.log('[Update] App is up to date');
                    showNotification(' App is up to date', 'success', 4000); // Show for 4 seconds
                });
                
                // When update becomes available, show persistent overlay and notification
                window.electronAPI.onUpdateAvailable?.((_info) => {
                    console.log('[Update] Update available:', _info);
                    const downloadUrl = _info?.downloadUrl || 'https://github.com/ayman708-UX/PlayTorrio/releases/latest';
                    const version = _info?.version || 'new';

                    // Create manual update modal
                    const modalId = 'manual-update-modal';
                    if (document.getElementById(modalId)) return; // already showing

                    const modal = document.createElement('div');
                    modal.id = modalId;
                    modal.className = 'modal active';
                    modal.style.zIndex = '99999';
                    modal.innerHTML = `
                        <div class="modal-content" style="max-width: 450px; text-align: center; padding: 2rem;">
                            <div style="width: 60px; height: 60px; background: rgba(168, 85, 247, 0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1.5rem auto;">
                                <i class="fas fa-gift" style="font-size: 30px; color: #a855f7;"></i>
                            </div>
                            <h2 style="font-size: 1.8rem; margin-bottom: 0.5rem; color: #fff;">Update Available!</h2>
                            <p style="color: #ccc; margin-bottom: 2rem;">Version <strong>${version}</strong> is ready to download.</p>
                            
                            <div style="display: flex; flex-direction: column; gap: 1rem;">
                                <button id="manual-dl-btn" class="btn btn-primary" style="justify-content: center; padding: 1rem;">
                                    <i class="fas fa-download"></i> Download Now
                                </button>
                                <button id="manual-later-btn" class="btn btn-ghost" style="justify-content: center; padding: 0.8rem;">
                                    Remind Me Later
                                </button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);

                    document.getElementById('manual-dl-btn').onclick = () => {
                        window.electronAPI.openExternal(downloadUrl);
                        modal.remove();
                    };
                    document.getElementById('manual-later-btn').onclick = () => {
                        modal.remove();
                    };
                });
                
                // Progress updates - keep overlay visible throughout download
                window.electronAPI.onUpdateProgress?.((p) => {
                    console.log('[Update] Download progress:', p?.percent + '%');
                    const percent = Math.max(0, Math.min(100, Math.round(p?.percent || 0)));
                    if (bar) bar.style.width = percent + '%';
                    if (pct) pct.textContent = percent + '%';
                    if (text) text.textContent = `Downloading update... ${percent}% complete`;
                    if (icon) { icon.className = 'fas fa-download'; icon.style.animation = 'pulse 1.5s ease-in-out infinite'; }
                    updatePersistentDownloadNotification(percent);
                    
                    // Optional: throttle additional toasts if desired; persistent notif covers it
                });
                
                // Download finished - keep overlay visible and show persistent restart notification
                window.electronAPI.onUpdateDownloaded?.((_info) => {
                    console.log('[Update] Download completed, ready to install');
                    // Switch from download notification to restart-ready notification
                    hideUpdateNotification();
                    if (icon) { icon.className = 'fas fa-check-circle'; icon.style.animation = 'none'; icon.style.color = '#22c55e'; }
                    if (text) text.textContent = 'Update downloaded successfully! Click "Restart Now" to complete the update.';
                    if (bar) bar.style.width = '100%';
                    if (pct) pct.textContent = '100%';
                    if (restartBtn) restartBtn.style.display = 'inline-flex';
                    
                    const warningText = document.getElementById('updateWarningText');
                    if (warningText) warningText.textContent = ' Update ready! You can restart the app anytime to apply the update';
                    
                    const closeBtn = document.getElementById('updateCloseBtn');
                    if (closeBtn) closeBtn.style.display = 'flex';
                    
                    // Show persistent restart notification that stays until user restarts
                    showPersistentUpdateNotification();
                });
                
                // Restart button
                restartBtn?.addEventListener('click', async (ev) => {
                    try {
                        ev.stopPropagation?.();
                        // Visual feedback: disable button and show restarting state
                        restartBtn.disabled = true;
                        const originalHtml = restartBtn.innerHTML;
                        restartBtn.innerHTML = '<i class="fas fa-sync fa-spin"></i> Restarting...';
                        restartBtn.style.opacity = '0.85';

                        // Trigger updater installation (main will relaunch automatically)
                        const res = await window.electronAPI.installUpdateNow?.();
                        // Optionally hide the notification right after invoking install
                        // (App should quit almost immediately.)
                        setTimeout(() => { try { hideUpdateNotification(); } catch(_) {} }, 200);

                        // If for some reason it didn't return success, keep overlay visible
                        if (!res || res.success !== true) {
                            restartBtn.disabled = false;
                            restartBtn.innerHTML = originalHtml;
                            restartBtn.style.opacity = '1';
                            showNotification('Update install failed to start. Please try again.', 'error', 4000);
                        }
                    } catch (e) {
                        // Restore button and keep the overlay so user can retry
                        try {
                            restartBtn.disabled = false;
                            restartBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Restart Now to Complete Update';
                            restartBtn.style.opacity = '1';
                        } catch(_) {}
                        showNotification('Could not trigger restart. Please try again.', 'error', 4000);
                    }
                });
            }
            
            // Offline/Online UX: show a small banner so users know they can access offline music
            try {
                const notifyOffline = () => showNotification('You are offline. Offline Music Library is available.', 'warning', 5000);
                const notifyOnline = () => showNotification('Back online.', 'success', 3000);
                if (typeof navigator !== 'undefined' && navigator && navigator.onLine === false) {
                    notifyOffline();
                }
                window.addEventListener('offline', notifyOffline);
                window.addEventListener('online', notifyOnline);
            } catch(_) {}
        } catch(_){ }

        // ---- My List functionality ----
        let myListCache = [];

        async function loadMyList() {
            try {
                const response = await window.electronAPI.myListRead();
                if (response.success) {
                    const rawData = response.data || [];
                    
                    // Deduplicate: Keep only unique items based on id + media_type combination
                    const seen = new Map();
                    const deduplicated = [];
                    
                    for (const item of rawData) {
                        const key = `${item.id}_${item.media_type}`;
                        if (!seen.has(key)) {
                            seen.set(key, true);
                            deduplicated.push(item);
                        }
                    }
                    
                    myListCache = deduplicated;
                    
                    // If deduplication removed items, save the cleaned list
                    if (deduplicated.length < rawData.length) {
                        console.log(`[MyList] Removed ${rawData.length - deduplicated.length} duplicate(s)`);
                        await saveMyList();
                    }
                    
                    return myListCache;
                } else {
                    console.error('Failed to load my list:', response.message);
                    return [];
                }
            } catch (error) {
                console.error('Error loading my list:', error);
                return [];
            }
        }

        async function saveMyList() {
            try {
                const response = await window.electronAPI.myListWrite(myListCache);
                if (!response.success) {
                    console.error('Failed to save my list:', response.message);
                }
                return response.success;
            } catch (error) {
                console.error('Error saving my list:', error);
                return false;
            }
        }

        async function toggleMyList(event, id, mediaType, title, posterPath, year, rating) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.add-to-list-btn');
            if (!button) return;

            const existingIndex = myListCache.findIndex(item => item.id === id && item.media_type === mediaType);
            
            if (existingIndex >= 0) {
                // Remove from list
                myListCache.splice(existingIndex, 1);
                button.classList.remove('in-list');
                button.innerHTML = '<i class="fas fa-plus"></i>';
                button.title = 'Add to My List';
                
                // Sync removal with Trakt
                await syncWithTraktWatchlist('remove', title, mediaType, year);
            } else {
                // Add to list - double-check for duplicates before adding
                const isDuplicate = myListCache.some(item => item.id === id && item.media_type === mediaType);
                
                if (!isDuplicate) {
                    const listItem = {
                        id: id,
                        media_type: mediaType,
                        title: title,
                        poster_path: posterPath,
                        year: year,
                        vote_average: rating,
                        added_date: new Date().toISOString()
                    };
                    myListCache.unshift(listItem); // Add to beginning
                    button.classList.add('in-list');
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    button.title = 'Remove from My List';
                    
                    // Sync addition with Trakt
                    await syncWithTraktWatchlist('add', title, mediaType, year);
                } else {
                    console.warn('[MyList] Prevented duplicate addition:', id, mediaType);
                    // Already in list, just update button state
                    button.classList.add('in-list');
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    button.title = 'Remove from My List';
                }
            }

            await saveMyList();
            
            // Refresh My List page if it's currently open
            if (document.getElementById('myListPage').style.display !== 'none') {
                displayMyList();
            }
        }

        function updateCardListStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.add-to-list-btn');
            if (!button) return;

            const isInList = myListCache.some(item => item.id === id && item.media_type === mediaType);
            
            if (isInList) {
                button.classList.add('in-list');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Remove from My List';
            } else {
                button.classList.remove('in-list');
                button.innerHTML = '<i class="fas fa-plus"></i>';
                button.title = 'Add to My List';
            }
        }

        function updateCardDoneStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.done-watching-btn');
            if (!button) return;

            // Only mark as done if the exact title (movie or full show) is in doneWatchingCache,
            // never due to episode entries.
            const isDone = doneWatchingCache.some(item =>
                item.id === id && item.media_type === mediaType && (!item.season && !item.episode)
            );

            if (isDone) {
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
            } else {
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
            }
        }

        async function displayMyList() {
            const grid = document.getElementById('myListGrid');
            const loading = document.getElementById('myListLoading');
            const empty = document.getElementById('myListEmpty');
            
            if (!grid) return;

            loading.style.display = 'block';
            empty.style.display = 'none';
            grid.innerHTML = '';

            await loadMyList();

            loading.style.display = 'none';

            if (myListCache.length === 0) {
                empty.style.display = 'block';
                return;
            }

            myListCache.forEach(item => {
                const card = document.createElement('div');
                card.className = 'movie-card';
                card.dataset.rating = item.vote_average || 0;
                card.dataset.date = `${item.year}-01-01`; // Approximate date for consistency
                card.innerHTML = `
                    <button class="add-to-list-btn in-list" onclick="toggleMyList(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                        <i class="fas fa-check"></i>
                    </button>
                    <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${item.title}" class="movie-poster">
                    <div class="movie-info">
                        <h3 class="movie-title">${item.title}</h3>
                        <p class="movie-year">${item.year}</p>
                    </div>
                    <div class="movie-rating">
                        <i class="fas fa-star"></i> ${Number(item.vote_average).toFixed(1)}
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.add-to-list-btn')) {
                        openDetailsModal(item, item.media_type);
                    }
                });
                grid.appendChild(card);
            });
        }

        async function clearMyList() {
            if (confirm('Are you sure you want to clear your entire list? This action cannot be undone.')) {
                myListCache = [];
                await saveMyList();
                
                // Update all visible cards
                document.querySelectorAll('.add-to-list-btn.in-list').forEach(button => {
                    button.classList.remove('in-list');
                    button.innerHTML = '<i class="fas fa-plus"></i>';
                    button.title = 'Add to My List';
                });
                
                // Refresh My List page if open
                if (document.getElementById('myListPage').style.display !== 'none') {
                    displayMyList();
                }
            }
        }

        // ---- Done Watching functionality ----
        let doneWatchingCache = [];

        async function loadDoneWatching() {
            try {
                const response = await window.electronAPI.doneWatchingRead();
                if (response.success) {
                    doneWatchingCache = response.data || [];
                    return doneWatchingCache;
                } else {
                    console.error('Failed to load done watching:', response.message);
                    return [];
                }
            } catch (error) {
                console.error('Error loading done watching:', error);
                return [];
            }
        }

        async function saveDoneWatching() {
            try {
                const response = await window.electronAPI.doneWatchingWrite(doneWatchingCache);
                if (!response.success) {
                    console.error('Failed to save done watching:', response.message);
                }
                return response.success;
            } catch (error) {
                console.error('Error saving done watching:', error);
                return false;
            }
        }

        async function toggleDoneWatching(event, id, mediaType, title, posterPath, year, rating, season, episode) {
            event.preventDefault();
            event.stopPropagation();
            
            const button = event.target.closest('.done-watching-btn');
            if (!button) return;

            const existingIndex = doneWatchingCache.findIndex(item => {
                if (mediaType === 'tv' && season && episode) {
                    // For episodes, match by show ID, season, and episode
                    return item.id === id && item.media_type === mediaType && 
                           item.season === season && item.episode === episode;
                } else {
                    // For movies and whole shows, match by ID and media type
                    return item.id === id && item.media_type === mediaType;
                }
            });
            
            if (existingIndex >= 0) {
                // Remove from done watching
                doneWatchingCache.splice(existingIndex, 1);
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
                
                // Note: We don't remove from Trakt history as that's not typical behavior
                showNotification('Removed from local done watching list', 'info');
            } else {
                // Add to done watching
                const doneItem = {
                    id: id,
                    media_type: mediaType,
                    title: title,
                    poster_path: posterPath,
                    year: year,
                    vote_average: rating,
                    completed_date: new Date().toISOString()
                };
                
                // Add episode info if this is a TV episode
                if (mediaType === 'tv' && season && episode) {
                    doneItem.season = season;
                    doneItem.episode = episode;
                    doneItem.episode_title = title; // Store episode title separately
                }
                
                doneWatchingCache.unshift(doneItem); // Add to beginning
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
                
                // Sync with Trakt
                if (mediaType === 'movie') {
                    // For movies, mark as watched and add to collection
                    await syncWithTraktWatched('movie', title, year);
                    await syncWithTraktCollection('add', title, 'movie', year);
                } else if (mediaType === 'tv') {
                    if (season && episode) {
                        // For specific episodes
                        await syncWithTraktWatchedEpisode(title, year, season, episode);
                    } else {
                        // For whole shows (only add to collection, not mark entire show as watched)
                        await syncWithTraktCollection('add', title, 'show', year);
                        showNotification(`Added "${title}" to your Trakt collection`, 'success');
                    }
                }
            }

            await saveDoneWatching();
            // Update any other Done Watching buttons in the DOM for this item
            try { updateAllDoneButtons(id, mediaType); } catch (_) {}
            
            // Refresh Done Watching page if it's currently open
            if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                displayDoneWatching();
            }
        }

        function updateCardDoneStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.done-watching-btn');
            if (!button) return;

            // Only mark as done if the exact title (movie or full show) is in doneWatchingCache,
            // never due to episode entries.
            const isDone = doneWatchingCache.some(item =>
                item.id === id && item.media_type === mediaType && (!item.season && !item.episode)
            );
            
            if (isDone) {
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
            } else {
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
            }
        }

        async function displayDoneWatching() {
            const grid = document.getElementById('doneWatchingGrid');
            const loading = document.getElementById('doneWatchingLoading');
            const empty = document.getElementById('doneWatchingEmpty');
            
            if (!grid) return;

            loading.style.display = 'block';
            empty.style.display = 'none';
            grid.innerHTML = '';

            await loadDoneWatching();

            loading.style.display = 'none';

            if (doneWatchingCache.length === 0) {
                empty.style.display = 'block';
                return;
            }

            // Group episodes by show and keep movies separate
            const groupedItems = new Map();
            
            doneWatchingCache.forEach(item => {
                if (item.media_type === 'tv' && item.season && item.episode) {
                    // This is an individual episode
                    const showKey = `${item.id}-${item.media_type}`;
                    if (!groupedItems.has(showKey)) {
                        groupedItems.set(showKey, {
                            ...item,
                            episodes: [],
                            isGrouped: true
                        });
                    }
                    groupedItems.get(showKey).episodes.push({
                        season: item.season,
                        episode: item.episode,
                        episode_title: item.episode_title,
                        completed_date: item.completed_date
                    });
                } else {
                    // This is a movie or full show
                    const key = `${item.id}-${item.media_type}-single`;
                    groupedItems.set(key, {
                        ...item,
                        isGrouped: false
                    });
                }
            });

            // Sort and display grouped items
            Array.from(groupedItems.values())
                .sort((a, b) => new Date(b.completed_date) - new Date(a.completed_date))
                .forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'movie-card';
                    card.dataset.rating = item.vote_average || 0;
                    card.dataset.date = `${item.year}-01-01`;
                    
                    let displayTitle = item.title;
                    let episodeInfo = '';
                    let episodeBadge = '';
                    
                    if (item.isGrouped && item.episodes && item.episodes.length > 0) {
                        // Sort episodes by season/episode to get the latest
                        const sortedEpisodes = item.episodes.sort((a, b) => {
                            if (a.season !== b.season) return b.season - a.season;
                            return b.episode - a.episode;
                        });
                        
                        const latestEpisode = sortedEpisodes[0];
                        const episodeCount = item.episodes.length;
                        
                        displayTitle = item.title;
                        episodeInfo = `<p class="episode-subtitle">${episodeCount} episode${episodeCount > 1 ? 's' : ''} watched  Latest: S${latestEpisode.season}E${latestEpisode.episode}</p>`;
                        episodeBadge = `<div class="episode-badge"><i class="fas fa-tv"></i> ${episodeCount} Episodes</div>`;
                    }
                    
                    card.innerHTML = `
                        <button class="add-to-list-btn" onclick="toggleMyList(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                            <i class="fas fa-plus"></i>
                        </button>
                        ${item.media_type === 'movie' ? `
                        <button class="done-watching-btn is-done" onclick="toggleDoneWatching(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                            <i class="fas fa-check-circle"></i>
                        </button>` : ''}
                        ${episodeBadge}
                        <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${displayTitle}" class="movie-poster">
                        <div class="movie-info">
                            <h3 class="movie-title">${displayTitle}</h3>
                            ${episodeInfo}
                            <p class="movie-year">${item.year}</p>
                        </div>
                        <div class="movie-rating">
                            <i class="fas fa-star"></i> ${Number(item.vote_average).toFixed(1)}
                        </div>
                        ${item.isGrouped ? `
                        <button class="episode-details-btn" onclick="showEpisodeDetails(event, ${item.id}, '${item.title.replace(/'/g, "\\'")}')">
                            <i class="fas fa-list"></i> View ${item.episodes.length} Episode${item.episodes.length > 1 ? 's' : ''}
                        </button>
                        ` : ''}
                    `;
                    card.addEventListener('click', (e) => {
                    if (!e.target.closest('.add-to-list-btn') && !e.target.closest('.done-watching-btn')) {
                        openDetailsModal(item, item.media_type);
                    }
                });
                grid.appendChild(card);
            });
        }

        async function clearDoneWatching() {
            if (confirm('Are you sure you want to clear your entire done watching list? This action cannot be undone.')) {
                doneWatchingCache = [];
                await saveDoneWatching();
                
                // Update all visible cards
                document.querySelectorAll('.done-watching-btn.is-done').forEach(button => {
                    button.classList.remove('is-done');
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    button.title = 'Mark as Done Watching';
                });
                
                // Refresh Done Watching page if open
                if (document.getElementById('doneWatchingPage').style.display !== 'none') {
                    displayDoneWatching();
                }
            }
        }

        function updateCardDoneStatus(cardElement, id, mediaType) {
            const button = cardElement.querySelector('.done-watching-btn');
            if (!button) return;

            const isDone = doneWatchingCache.some(item =>
                item.id === id && item.media_type === mediaType && (!item.season && !item.episode)
            );
            
            if (isDone) {
                button.classList.add('is-done');
                button.innerHTML = '<i class="fas fa-check-circle"></i>';
                button.title = 'Remove from Done Watching';
            } else {
                button.classList.remove('is-done');
                button.innerHTML = '<i class="fas fa-check"></i>';
                button.title = 'Mark as Done Watching';
            }
        }

        async function displayDoneWatching() {
            const grid = document.getElementById('doneWatchingGrid');
            const loading = document.getElementById('doneWatchingLoading');
            const empty = document.getElementById('doneWatchingEmpty');
            
            if (!grid) return;

            loading.style.display = 'block';
            empty.style.display = 'none';
            grid.innerHTML = '';

            await loadDoneWatching();

            loading.style.display = 'none';

            if (doneWatchingCache.length === 0) {
                empty.style.display = 'block';
                return;
            }

            const groupedItems = new Map();
            
            doneWatchingCache.forEach(item => {
                if (item.media_type === 'tv' && item.season && item.episode) {
                    const showKey = `${item.id}-${item.media_type}`;
                    if (!groupedItems.has(showKey)) {
                        groupedItems.set(showKey, {
                            ...item,
                            episodes: [],
                            isGrouped: true
                        });
                    }
                    groupedItems.get(showKey).episodes.push({
                        season: item.season,
                        episode: item.episode,
                        episode_title: item.episode_title,
                        completed_date: item.completed_date
                    });
                } else {
                    const key = `${item.id}-${item.media_type}-single`;
                    groupedItems.set(key, {
                        ...item,
                        isGrouped: false
                    });
                }
            });

            Array.from(groupedItems.values())
                .sort((a, b) => new Date(b.completed_date) - new Date(a.completed_date))
                .forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'movie-card';
                    card.dataset.rating = item.vote_average || 0;
                    card.dataset.date = `${item.year}-01-01`;
                    
                    let displayTitle = item.title;
                    let episodeInfo = '';
                    let episodeBadge = '';
                    
                    if (item.isGrouped && item.episodes && item.episodes.length > 0) {
                        const sortedEpisodes = item.episodes.sort((a, b) => {
                            if (a.season !== b.season) return b.season - a.season;
                            return b.episode - a.episode;
                        });
                        
                        const latestEpisode = sortedEpisodes[0];
                        const episodeCount = item.episodes.length;
                        
                        episodeInfo = `<p class="episode-subtitle">${episodeCount} episodes watched  Latest: S${latestEpisode.season}E${latestEpisode.episode}</p>`;
                        episodeBadge = `<div class="episode-badge"><i class="fas fa-tv"></i> ${episodeCount} Episodes</div>`;
                    }
                    
                    card.innerHTML = `
                        <button class="add-to-list-btn" onclick="toggleMyList(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                            <i class="fas fa-plus"></i>
                        </button>
                        ${item.media_type === 'movie' ? `
                        <button class="done-watching-btn is-done" onclick="toggleDoneWatching(event, ${item.id}, '${item.media_type}', '${item.title.replace(/'/g, "\\'")}', '${item.poster_path}', '${item.year}', ${item.vote_average})">
                            <i class="fas fa-check-circle"></i>
                        </button>` : ''}
                        ${episodeBadge}
                        <img loading="lazy" decoding="async" src="https://image.tmdb.org/t/p/w342${item.poster_path}" alt="${displayTitle}" class="movie-poster">
                        <div class="movie-info">
                            <h3 class="movie-title">${displayTitle}</h3>
                            ${episodeInfo}
                            <p class="movie-year">${item.year}</p>
                        </div>
                        <div class="movie-rating">
                            <i class="fas fa-star"></i> ${Number(item.vote_average).toFixed(1)}
                        </div>
                        ${item.isGrouped ? `
                        <button class="episode-details-btn" onclick="showEpisodeDetails(event, ${item.id}, '${item.title.replace(/'/g, "\\'")}')">
                            <i class="fas fa-list"></i> View ${item.episodes.length} Episode${item.episodes.length > 1 ? 's' : ''}
                        </button>
                        ` : ''}
                    `;
                    card.addEventListener('click', (e) => {
                        if (!e.target.closest('.add-to-list-btn') && !e.target.closest('.done-watching-btn')) {
                            openDetailsModal(item, item.media_type);
                        }
                    });
                    grid.appendChild(card);
                });
        }

        // GLOBAL manifest save function
        async function saveManifest() {
            const input = document.getElementById("manifestUrl").value.trim();
            if (!input) return;

            manifestUrl = input;
            await window.electronAPI.manifestWrite(manifestUrl);

            document.getElementById("manifestSavedBox").style.display = "block";
            if (document.getElementById("manifestStatus"))
                document.getElementById("manifestStatus").innerHTML = '<span class="status connected"> Manifest Connected</span>';

            loadContent(currentTab);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            try { await reconcileDownloadedMusicWithDisk(); } catch(_) {}
            try { renderDownloadedMusic(); } catch(_) {}
            await loadMyList();
            await loadDoneWatching();
            await loadContinueWatching();

            // --- Load manifest from disk ---
            try {
                const result = await window.electronAPI.manifestRead();
                if (result.success && result.data) {
                    manifestUrl = result.data;

                    const manifestInput = document.getElementById("manifestUrl");
                    if (manifestInput) manifestInput.value = manifestUrl;

                    const statusEl = document.getElementById("manifestStatus");
                    if (statusEl)
                        statusEl.innerHTML = '<span class="status connected"> Manifest Connected</span>';
                }
            } catch (err) {
                console.error("Failed to load manifest", err);
            }
            // -------------------------------

            const originalDisplayMovies = displayMovies;
            displayMovies = function(movies, append = true) {
                const result = originalDisplayMovies.call(this, movies, append);
                setTimeout(() => {
                    movies.forEach(movie => {
                        const cards = document.querySelectorAll(`[data-rating="${movie.vote_average || 0}"]`);
                        cards.forEach(card => {
                            updateCardListStatus(card, movie.id, movie.media_type || 'movie');
                            updateCardDoneStatus(card, movie.id, movie.media_type || 'movie');
                        });
                    });
                }, 100);
                return result;
            };

            const originalDisplayGenreItems = displayGenreItems;
            displayGenreItems = function(items, mediaType) {
                const result = originalDisplayGenreItems.call(this, items, mediaType);
                setTimeout(() => {
                    items.forEach(item => {
                        const cards = document.querySelectorAll(`.movie-card`);
                        cards.forEach(card => {
                            const cardImg = card.querySelector('img');
                            if (cardImg && cardImg.src.includes(item.poster_path)) {
                                updateCardListStatus(card, item.id, mediaType);
                                updateCardDoneStatus(card, item.id, mediaType);
                            }
                        });
                    });
                }, 100);
                return result;
            };

            document.getElementById('clearMyListBtn')?.addEventListener('click', clearMyList);
            document.getElementById('clearDoneWatchingBtn')?.addEventListener('click', clearDoneWatching);
        });

    </script>

    
    <!-- Updater Overlay (enhanced, user-friendly) -->
    <div id="updateOverlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9999; display:none; align-items:center; justify-content:center; backdrop-filter:blur(10px);">
        <div style="background:linear-gradient(135deg, #2a1847 0%, #1f1235 100%); border:2px solid #a855f7; padding:2.5rem; border-radius:16px; width:min(90%, 480px); text-align:center; color:#f8f9fa; box-shadow:0 20px 40px rgba(0,0,0,0.5); position:relative;">
            <!-- Close button (only shown when download is complete) -->
            <button id="updateCloseBtn" onclick="hideOverlay()" style="position:absolute; top:15px; right:15px; background:rgba(255,255,255,0.1); border:none; color:#c084fc; width:32px; height:32px; border-radius:50%; cursor:pointer; display:none; align-items:center; justify-content:center; transition: all 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                <i class="fas fa-times" style="font-size:14px;"></i>
            </button>
            
            <div id="updateStatusIcon" class="fas fa-download" style="font-size:3rem; margin-bottom:1.5rem; color:#a855f7; animation: spin 1.4s cubic-bezier(0.65, 0, 0.35, 1) infinite;"></div>
            <h2 style="margin:0 0 0.5rem 0; font-size:1.5rem; font-weight:600;">App Update in Progress</h2>
            <p id="updateStatusText" style="margin:0.25rem 0 1.5rem 0; color:#c084fc; font-size:1rem; line-height:1.4;">Update found! Downloading now, please wait...</p>
            <div style="height:12px; background:rgba(255,255,255,0.08); border-radius:12px; overflow:hidden; margin-bottom:12px; box-shadow:inset 0 2px 4px rgba(0,0,0,0.3);">
                <div id="updateProgressBar" style="height:100%; width:0%; background:linear-gradient(90deg, #a855f7, #22c55e); transition: width 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94); border-radius:12px;"></div>
            </div>
            <div id="updatePercent" style="font-weight:700; color:#a855f7; font-size:1.1rem; margin-bottom:1rem;">0%</div>
            <p id="updateWarningText" style="margin:0.5rem 0 1rem 0; color:#8b5cf6; font-size:0.9rem; opacity:0.8;"> Please do not close the application during the update</p>
            <button id="updateRestartBtn" class="btn btn-primary" style="margin-top:1rem; display:none; padding:0.75rem 2rem; font-size:1rem; border-radius:8px;">
                <i class="fas fa-sync-alt"></i> Restart Now to Complete Update
            </button>
        </div>
    </div>

    <!-- Resume Prompt Modal (top-level) -->
    <div class="modal" id="resumeModal">
        <div class="modal-content" style="max-width:480px">
            <button class="modal-close" id="resumeClose"><i class="fas fa-times"></i></button>
            <div class="modal-header">
                <div class="modal-header-content" style="gap:0.75rem; align-items:center;">
                    <div style="display:flex; align-items:center; gap:0.5rem;">
                        <i class="fas fa-history" style="color: var(--vlc-orange);"></i>
                        <h2 class="modal-title" id="resumeTitle" style="margin:0; font-size:1.3rem;">Resume playback?</h2>
                    </div>
                    <div class="modal-info" style="display:flex; gap:0.5rem; align-items:center;">
                        <span id="resumeTime" class="genre-chip">00:00</span>
                    </div>
                </div>
            </div>
            <div class="modal-body" style="padding-top:0.5rem;">
                <p class="modal-overview" id="resumeText" style="margin-bottom:1rem;">You have previous progress for this title. Would you like to continue from where you left off?</p>
                <div style="display:flex; gap:0.75rem; justify-content:flex-end;">
                    <button class="btn btn-outline" id="resumeStartOver"><i class="fas fa-undo"></i> Start Over</button>
                    <button class="btn" id="resumeContinue"><i class="fas fa-play"></i> Continue</button>
                </div>
            </div>
        </div>
    </div>
<script>
    
// Helper function to play a stream in a full-screen iframe viewer
function playStreamInViewer(streamUrl) {
    console.log('[LiveTV] Playing stream:', streamUrl);

    const existingViewer = document.getElementById('livetv-stream-viewer');
    if (existingViewer) {
        existingViewer.remove();
    }

    const viewer = document.createElement('div');
    viewer.id = 'livetv-stream-viewer';
    viewer.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000;
        display: flex; flex-direction: column;
    `;
    
    viewer.innerHTML = `
        <button id="livetv-back-btn" style="
            position: absolute; top: 15px; left: 15px; z-index: 10001;
            background: rgba(0,0,0,0.6); color: #fff; border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%; width: 40px; height: 40px; font-size: 1.2rem; cursor: pointer;
        ">&times;</button>
        <iframe src="${streamUrl}" style="
            width: 100%; height: 100%; border: none; flex-grow: 1;
        " allow="autoplay; encrypted-media; picture-in-picture; fullscreen" allowfullscreen></iframe>
    `;
    
    document.body.appendChild(viewer);

    const closeModal = () => {
        if (viewer) {
            viewer.remove();
            document.removeEventListener('keydown', handleEsc);
        }
    };

    const backBtn = document.getElementById('livetv-back-btn');
    backBtn.addEventListener('click', closeModal);

    const handleEsc = (e) => {
        if (e.key === 'Escape') {
            closeModal();
            console.log('[LiveTV] Stream viewer closed via ESC');
        }
    };
    document.addEventListener('keydown', handleEsc);
}

const liveTvPage = document.getElementById('livetv-page');
    const sourceButtonsContainer = document.getElementById('livetv-source-buttons');
    const categorySelect = document.getElementById('livetv-category-select');
    const livetvGrid = document.getElementById('livetv-grid');
    const livetvEmpty = document.getElementById('livetv-empty');
    const searchInput = document.getElementById('livetv-search-input');

    let allMatches = [];
    let currentSource = 'kobra';

    async function fetchMatches(source) {
        livetvGrid.innerHTML = '<div class="loading"><i class="fas fa-spinner"></i> Loading matches...</div>';
        livetvEmpty.style.display = 'none';
        try {
            let apiUrl = '';
            if (source === 'titan') {
                apiUrl = `https://ntvstream.cx/api/get-matches?server=titan&type=both`;
            } else {
                apiUrl = `https://ntvstream.cx/api/get-matches?server=${source}&type=both`;
            }

            const response = await fetch(apiUrl);
            const data = await response.json();
            if (data.success) {
                allMatches = data.all || [];
                updateCategoryDropdown(data.categories);
                displayMatches(source);
            } else {
                livetvGrid.innerHTML = '';
                livetvEmpty.style.display = 'block';
            }
        } catch (error) {
            console.error('Error fetching matches:', error);
            livetvGrid.innerHTML = '';
            livetvEmpty.style.display = 'block';
            livetvEmpty.querySelector('p').textContent = 'Failed to load matches.';
        }
    }

    function updateCategoryDropdown(categoryList) {
        categorySelect.innerHTML = '<option value="all">All</option>';
        if (categoryList && categoryList.length > 0) {
            categoryList.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categorySelect.appendChild(option);
            });
        }
    }

    function displayMatches(source, category = 'all', searchTerm = '') {
        livetvGrid.innerHTML = '';
        let filteredMatches = allMatches;

        if (category !== 'all') {
            filteredMatches = filteredMatches.filter(match => match.category.toLowerCase() === category.toLowerCase());
        }

        if (searchTerm) {
            filteredMatches = filteredMatches.filter(match => match.title.toLowerCase().includes(searchTerm.toLowerCase()));
        }

        if (filteredMatches.length === 0) {
            livetvEmpty.style.display = 'block';
            return;
        }

        livetvEmpty.style.display = 'none';
        filteredMatches.forEach(match => {
            const card = document.createElement('div');
            card.className = 'livetv-match-card';
            
            const poster = match.poster ? `<img src="https://ntvstream.cx${match.poster}" class="livetv-poster" alt="${match.title}">` : '<div class="livetv-poster-placeholder"><i class="fas fa-futbol"></i></div>';

            card.innerHTML = `
                ${poster}
                <div class="livetv-match-info">
                    <h4 class="livetv-match-title">${match.title}</h4>
                    <span class="livetv-match-category">${match.category}</span>
                    <button class="livetv-watch-btn">Watch Streams</button>
                </div>
            `;
            livetvGrid.appendChild(card);

            card.querySelector('.livetv-watch-btn').addEventListener('click', () => {
                showStreamsModal(match, source);
            });
        });
    }
    
    function getStreamUrl(source, stream) {
        if (source === 'kobra') {
            return `https://embedsports.top/embed/${stream.source}/${stream.id}/1`;
        }
        return stream.url;
    }

    function showStreamsModal(match, source) {
        // TITAN PROVIDER LOGIC
        // TITAN PROVIDER LOGIC
        if (source === 'titan') {
            console.log('[LiveTV] Titan provider detected. Resolving stream for match ID:', match.id);

            const modal = document.getElementById('livetv-streams-modal');
            const titleEl = document.getElementById('livetv-streams-title');
            const listEl = document.getElementById('livetv-streams-list');
            const closeBtn = document.getElementById('livetv-streams-close');
            
            titleEl.textContent = match.title;
            listEl.innerHTML = '<div class="livetv-loading"><i class="fas fa-spinner"></i><p>Resolving Titan Stream...</p></div>';
            modal.style.display = 'flex';

            const closeModal = () => modal.style.display = 'none';
            closeBtn.onclick = closeModal;
            modal.onclick = (e) => {
                if (e.target === modal) closeModal();
            };

            fetch(`/api/titan/stream/${match.id}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Server responded with status ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const streamUrl = data.streamUrl;
                    if (streamUrl) {
                        modal.style.display = 'none'; // Hide loading modal
                        playStreamInViewer(streamUrl); // Use the helper
                    } else {
                        throw new Error("Stream URL not found in backend response.");
                    }
                })
                .catch(error => {
                    console.error('[LiveTV] Error fetching Titan stream:', error);
                    listEl.innerHTML = '<div class="livetv-empty"><p>Failed to resolve Titan stream. Please try again.</p></div>';
                });

            return; // End execution for titan
        }
        // PHOENIX PROVIDER LOGIC
        if (source === 'phoenix') {
            console.log('[LiveTV] Phoenix provider detected. Resolving stream for match ID:', match.id);

            const modal = document.getElementById('livetv-streams-modal');
            const titleEl = document.getElementById('livetv-streams-title');
            const listEl = document.getElementById('livetv-streams-list');
            const closeBtn = document.getElementById('livetv-streams-close');
            
            titleEl.textContent = match.title;
            listEl.innerHTML = '<div class="livetv-loading"><i class="fas fa-spinner"></i><p>Resolving Phoenix Stream...</p></div>';
            modal.style.display = 'flex';

            const closeModal = () => modal.style.display = 'none';
            closeBtn.onclick = closeModal;
            modal.onclick = (e) => {
                if (e.target === modal) closeModal();
            };

            fetch(`/api/phoenix/stream/${match.id}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Server responded with status ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const streamUrl = data.streamUrl;
                    if (streamUrl) {
                        modal.style.display = 'none'; // Hide loading modal
                        playStreamInViewer(streamUrl); // Use the helper
                    } else {
                        throw new Error("Stream URL not found in backend response.");
                    }
                })
                .catch(error => {
                    console.error('[LiveTV] Error fetching Phoenix stream:', error);
                    listEl.innerHTML = '<div class="livetv-empty"><p>Failed to resolve Phoenix stream. Please try again.</p></div>';
                });

            return; // End execution for phoenix
        }

        // DEFAULT LOGIC FOR OTHER PROVIDERS
        const modal = document.getElementById('livetv-streams-modal');
        const titleEl = document.getElementById('livetv-streams-title');
        const listEl = document.getElementById('livetv-streams-list');
        const closeBtn = document.getElementById('livetv-streams-close');

        titleEl.textContent = match.title;
        listEl.innerHTML = '';

        if (match.sources && match.sources.length > 0) {
            match.sources.forEach(stream => {
                const streamItem = document.createElement('div');
                streamItem.className = 'livetv-stream-item';
                const streamUrl = getStreamUrl(source, stream);
                streamItem.innerHTML = `
                    <div class="livetv-stream-info">
                        <span class="livetv-stream-source">${stream.channelName || stream.source}</span>
                    </div>
                    <div class="livetv-stream-actions">
                        <button class="livetv-play-stream-btn" data-url="${streamUrl}"><i class="fas fa-play"></i> Play</button>
                        <button class="livetv-copy-link-btn" data-url="${streamUrl}"><i class="fas fa-copy"></i> Copy Link</button>
                    </div>
                `;
                listEl.appendChild(streamItem);
            });
        } else {
            listEl.innerHTML = '<p>No streams available for this match.</p>';
        }

        modal.style.display = 'flex';

        listEl.querySelectorAll('.livetv-play-stream-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const streamUrl = btn.getAttribute('data-url');
                if (streamUrl) {
                    modal.style.display = 'none';
                    playStreamInViewer(streamUrl); // Use the helper function
                }
            });
        });

        listEl.querySelectorAll('.livetv-copy-link-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const url = btn.getAttribute('data-url');
                navigator.clipboard.writeText(url).then(() => {
                    showNotification('Stream link copied to clipboard!', 'success');
                });
            });
        });

        closeBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }
    
    sourceButtonsContainer.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const source = e.target.getAttribute('data-source');
            if (source && source !== currentSource) {
                currentSource = source;
                // Update active button
                sourceButtonsContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                fetchMatches(source);
            }
        }
    });

    categorySelect.addEventListener('change', () => {
        displayMatches(currentSource, categorySelect.value, searchInput.value);
    });

    searchInput.addEventListener('input', () => {
        displayMatches(currentSource, categorySelect.value, searchInput.value);
    });

    // Initial load
    if (liveTvPage.style.display !== 'none') {
        fetchMatches(currentSource);
    }
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Provider Switching Logic ---
    const provider111477 = document.getElementById('provider111477');
    const providerAcermovies = document.getElementById('providerAcermovies');
    const content111477 = document.getElementById('111477-content');
    const acermoviesContent = document.getElementById('acermovies-content');
    const downloaderTypeToggle = document.querySelector('.downloader-search .downloader-type-toggle');
    const downloaderQueryInput = document.getElementById('downloaderQuery');
    const downloaderResults = document.getElementById('downloaderResults');
    const downloaderEmpty = document.getElementById('downloaderEmpty');

    function setActiveProvider(provider) {
        provider111477.classList.remove('active');
        providerAcermovies.classList.remove('active');
        
        if (provider === 'acermovies') {
            providerAcermovies.classList.add('active');
            if (downloaderTypeToggle) downloaderTypeToggle.style.display = 'none';
            downloaderQueryInput.placeholder = 'Search acermovies...';
        } else { // Default to 111477
            provider111477.classList.add('active');
            if (downloaderTypeToggle) downloaderTypeToggle.style.display = 'flex';
            downloaderQueryInput.placeholder = 'Search movies or shows (e.g., Superman)';
        }
        // Clear results when switching providers
        downloaderResults.innerHTML = '';
        downloaderResults.classList.remove('single');
        downloaderEmpty.style.display = 'none';
    }

    provider111477.addEventListener('click', () => setActiveProvider('111477'));
    providerAcermovies.addEventListener('click', () => setActiveProvider('acermovies'));
    setActiveProvider('111477'); // Set initial state


    // --- Hijack original search function ---
    const originalRunDownloaderSearch = window.runDownloaderSearch;
    window.runDownloaderSearch = function(query) {

        // If the original function is not on window, we might need to find it again.
        // For now, assuming it's accessible or we can redefine the listener.
        if (typeof originalRunDownloaderSearch === 'function') {
             return originalRunDownloaderSearch.apply(this, arguments);
        } else {
            // Fallback: If we couldn't grab the original function, we need to manually trigger the old logic.
            // This is complex, so let's try a simpler hijack: redefine the event listener.
        }
    }
    
    // A more robust way to hijack: replace the event listener.
    const downloaderBtn = document.getElementById('downloaderSearchBtn');
    if (downloaderBtn) {
        // Clone and replace to remove old listeners
        const newBtn = downloaderBtn.cloneNode(true);
        downloaderBtn.parentNode.replaceChild(newBtn, downloaderBtn);

        const newDownloaderQuery = document.getElementById('downloaderQuery');

        function newSearchHandler() {
             const acermoviesProviderActive = providerAcermovies?.classList.contains('active');
             const query = newDownloaderQuery.value;
             if (acermoviesProviderActive) {
                searchAcerMovies(query);
             } else {
                // Because we replaced the button, the original 'runDownloaderSearch' listener is gone.
                // We must call it explicitly. We assume it's globally available or we redefine it.
                // Let's find the function in the existing script tags.
                
                // For now, let's just assume the original function is available on window for simplicity
                if(typeof runDownloaderSearch === 'function') {
                    runDownloaderSearch(query);
                } else {
                    console.error("Could not find original runDownloaderSearch function.");
                }
             }
        }
        
        newBtn.addEventListener('click', newSearchHandler);
        newDownloaderQuery.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') newSearchHandler();
        });
    }
});
</script>

<!-- Ace Bet Promo Popup -->
<div id="acebet-popup" class="fixed inset-0 z-[10000] flex items-center justify-center bg-black/80 backdrop-blur-sm hidden" style="position:fixed;top:0;left:0;right:0;bottom:0;z-index:10000;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);">
    <div class="relative bg-gray-900 rounded-2xl overflow-hidden max-w-lg w-full mx-4 shadow-2xl border border-emerald-500/20 transform" id="acebet-popup-content" style="position:relative;background:#111827;border-radius:1rem;overflow:hidden;max-width:32rem;width:100%;margin:0 1rem;box-shadow:0 25px 50px -12px rgba(0,0,0,0.5);border:1px solid rgba(16,185,129,0.2);transform:scale(0.95);opacity:0;transition:all 0.3s ease;">
        <!-- Close button -->
        <button id="acebet-popup-close" style="position:absolute;top:0.75rem;right:0.75rem;z-index:10;width:2rem;height:2rem;background:rgba(0,0,0,0.6);border:none;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;cursor:pointer;transition:background 0.2s;">
            <svg style="width:1rem;height:1rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
        </button>
        <!-- Banner image -->
        <img src="https://photos-1xq.pages.dev/Casino%20-%201400x500.png" alt="Ace Bet" style="width:100%;height:auto;">
        <!-- Content -->
        <div style="padding:1.5rem;text-align:center;">
            <h3 style="font-size:1.5rem;font-weight:bold;color:white;margin-bottom:0.5rem;">Get Your Free $1 Bonus!</h3>
            <p style="color:#9ca3af;margin-bottom:1rem;">Exclusive offer for PlayTorrio users. Start playing today!</p>
            <a href="casino.html" style="display:inline-flex;align-items:center;gap:0.5rem;background:linear-gradient(to right,#10b981,#059669);color:white;font-weight:bold;padding:0.75rem 1.5rem;border-radius:0.75rem;text-decoration:none;transition:all 0.2s;">
                <span>Learn More</span>
                <svg style="width:1rem;height:1rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"/>
                </svg>
            </a>
            <!-- Never show again button -->
            <button id="acebet-never-show" style="display:block;margin:1rem auto 0;background:transparent;border:1px solid rgba(255,255,255,0.2);color:#9ca3af;padding:0.5rem 1rem;border-radius:0.5rem;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                Never show again
            </button>
        </div>
    </div>
</div>

<script>
// Ace Bet Popup - show only once per session, or never if user opted out
(function() {
    const popup = document.getElementById('acebet-popup');
    const popupContent = document.getElementById('acebet-popup-content');
    const closeBtn = document.getElementById('acebet-popup-close');
    const neverShowBtn = document.getElementById('acebet-never-show');
    
    if (!popup || !popupContent || !closeBtn) return;
    
    // Check if user permanently dismissed the popup
    if (localStorage.getItem('acebet_popup_never_show') === 'true') {
        return; // Never show again
    }
    
    // Check if popup was already shown this session
    if (!sessionStorage.getItem('acebet_popup_shown')) {
        // Show popup after a short delay
        setTimeout(() => {
            popup.style.display = 'flex';
            setTimeout(() => {
                popupContent.style.transform = 'scale(1)';
                popupContent.style.opacity = '1';
            }, 50);
        }, 1000);
        
        // Mark as shown for this session
        sessionStorage.setItem('acebet_popup_shown', 'true');
    }
    
    // Close popup
    function closePopup() {
        popupContent.style.transform = 'scale(0.95)';
        popupContent.style.opacity = '0';
        setTimeout(() => {
            popup.style.display = 'none';
        }, 300);
    }
    
    closeBtn.addEventListener('click', closePopup);
    closeBtn.addEventListener('mouseover', function() { this.style.background = '#ef4444'; });
    closeBtn.addEventListener('mouseout', function() { this.style.background = 'rgba(0,0,0,0.6)'; });
    popup.addEventListener('click', (e) => {
        if (e.target === popup) closePopup();
    });
    
    // Never show again button
    if (neverShowBtn) {
        neverShowBtn.addEventListener('click', function() {
            localStorage.setItem('acebet_popup_never_show', 'true');
            closePopup();
        });
        neverShowBtn.addEventListener('mouseover', function() { 
            this.style.background = 'rgba(239,68,68,0.2)'; 
            this.style.borderColor = '#ef4444';
            this.style.color = '#ef4444';
        });
        neverShowBtn.addEventListener('mouseout', function() { 
            this.style.background = 'transparent'; 
            this.style.borderColor = 'rgba(255,255,255,0.2)';
            this.style.color = '#9ca3af';
        });
    }
})();
</script>

</body>
<script>
// Add platform class to body for platform-specific styling
(function() {
    if (window.electronAPI && window.electronAPI.platform) {
        document.body.classList.add('platform-' + window.electronAPI.platform);
    }
})();
</script>
<script>
(function() {
    // --- Addon Manager State ---
    let installedAddons = [];
    
    // --- Monkey Patch fetchTorrents ---
    if (!window.originalFetchTorrents) {
        window.originalFetchTorrents = window.fetchTorrents;
    }

    window.fetchTorrents = async function(season, episode) {
        if (selectedProvider && selectedProvider.startsWith('addon:')) {
            const addonId = selectedProvider.replace('addon:', '');
            console.log('[Provider] Routing to Addon:', addonId);
            return fetchAddonStreams(addonId, season, episode);
        }
        if (window.originalFetchTorrents) {
            return window.originalFetchTorrents(season, episode);
        }
    };

    // --- Init ---
    window.loadAddons = async function() {
        try {
            const res = await window.electronAPI.addonList();
            if (res.success) {
                installedAddons = res.addons;
                refreshProviderButtons();
                updateSettingsList();
            }
        } catch (e) { console.error('Failed to load addons', e); }
    };

    document.addEventListener('DOMContentLoaded', async () => {
        await window.loadAddons();
        setupSettingsUI();
    });

    // --- UI: Provider Buttons ---
    function refreshProviderButtons() {
        const containers = document.querySelectorAll('.provider-buttons');
        
        containers.forEach(container => {
            container.querySelectorAll('.addon-provider-btn').forEach(b => b.remove());

            installedAddons.forEach(addon => {
                // Check if addon provides 'stream' resources - metadata-only addons should NOT appear
                const resources = addon.manifest?.resources || [];
                const hasStream = resources.some(r => {
                    if (typeof r === 'string') return r === 'stream';
                    if (typeof r === 'object' && r !== null) return r.name === 'stream';
                    return false;
                }) || resources.includes('stream');
                
                if (hasStream) {
                    const btn = document.createElement('button');
                    btn.className = 'provider-btn addon-provider-btn';
                    btn.dataset.provider = `addon:${addon.manifest.id}`;
                    btn.textContent = addon.manifest.name;
                    btn.style.border = "1px solid var(--vlc-orange)";
                    
                    btn.addEventListener('click', () => {
                         document.querySelectorAll('.provider-btn').forEach(b => b.classList.remove('active'));
                         document.querySelectorAll(`.provider-btn[data-provider="addon:${addon.manifest.id}"]`).forEach(b => b.classList.add('active'));
                         
                         selectedProvider = btn.dataset.provider;
                         console.log('[Provider] Switched to:', selectedProvider);
                         
                         const tl = document.getElementById('torrentsList');
                         if(tl) tl.innerHTML = `<div class="loading"><i class="fas fa-spinner"></i> Searching ${addon.manifest.name}...</div>`;
                         
                         torrentsLoaded = false;
                         window.fetchTorrents(lastSearchedSeason, lastSearchedEpisode);
                    });
                    
                    container.appendChild(btn);
                }
            });
        });
    }

    // --- UI: Settings ---
    function setupSettingsUI() {
        const installBtn = document.getElementById('installAddonBtn');
        const input = document.getElementById('addonManifestUrl');
        
        if (installBtn && input) {
            const newBtn = installBtn.cloneNode(true);
            if (installBtn.parentNode) installBtn.parentNode.replaceChild(newBtn, installBtn);
            
            newBtn.addEventListener('click', async () => {
                const url = input.value.trim();
                if (!url) return;
                
                newBtn.disabled = true;
                newBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                
                try {
                    const res = await window.electronAPI.addonInstall(url);
                    if (res.success) {
                        input.value = '';
                        await window.loadAddons();
                        showNotification('Addon installed successfully!', 'success');
                    } else {
                        showNotification('Failed to install addon: ' + res.message, 'error');
                    }
                } catch (e) {
                     showNotification('Error: ' + e.message, 'error');
                } finally {
                    newBtn.disabled = false;
                    newBtn.innerHTML = '<i class="fas fa-plus"></i> Install';
                }
            });
        }
    }

    function updateSettingsList() {
        const list = document.getElementById('installedAddonsList');
        if (!list) return;
        
        if (installedAddons.length === 0) {
            list.innerHTML = '<div style="text-align: center; color: var(--gray); padding: 1rem;">No addons installed</div>';
            return;
        }
        
        list.innerHTML = '';
        installedAddons.forEach(addon => {
            const item = document.createElement('div');
            item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;';
            item.innerHTML = `
                <div style="overflow:hidden;">
                    <div style="font-weight: 600;">${addon.manifest.name} <span style="font-size: 0.8em; opacity: 0.7;">v${addon.manifest.version}</span></div>
                    <div style="font-size: 0.85em; opacity: 0.7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${addon.url}</div>
                </div>
                <button class="api-btn api-btn-secondary" style="padding: 0.4rem 0.6rem; font-size: 0.85rem; background: #dc3545; min-width: 32px;">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            
            item.querySelector('button').addEventListener('click', async () => {
                if (confirm(`Uninstall ${addon.manifest.name}?`)) {
                    await window.electronAPI.addonRemove(addon.manifest.id);
                    await window.loadAddons();
                }
            });
            
            list.appendChild(item);
        });
    }

    // --- Logic: Fetch Streams ---
    async function fetchAddonStreams(addonId, season, episode) {
        const addon = installedAddons.find(a => a.manifest.id === addonId);
        if (!addon) return;
        
        try {
            const type = (currentMediaType === 'movie') ? 'movie' : 'series';
            let imdbId = '';
            
            if (currentContent.external_ids && currentContent.external_ids.imdb_id) {
                imdbId = currentContent.external_ids.imdb_id;
            } else {
                 const mediaType = currentMediaType === 'movie' ? 'movie' : 'tv';
                 const res = await fetch(`https://api.themoviedb.org/3/${mediaType}/${currentContent.id}/external_ids?api_key=${TMDB_API_KEY}`);
                 const data = await res.json();
                 imdbId = data.imdb_id;
            }
            
            if (!imdbId) throw new Error('No IMDB ID found');
            
            let resourceId = imdbId;
            if (type === 'series') {
                if (!season || !episode) throw new Error('Season and Episode required');
                resourceId = `${imdbId}:${season}:${episode}`;
            }
            
            let url = addon.url.replace('/manifest.json', '');
            if (url.endsWith('/')) url = url.slice(0, -1);
            
            const streamUrl = `${url}/stream/${type}/${resourceId}.json`;
            console.log('[Addon] Fetching streams:', streamUrl);
            
            const res = await fetch(streamUrl);
            const data = await res.json();
            
            if (!data.streams || data.streams.length === 0) {
                 const tl = document.getElementById('torrentsList');
                 if(tl) tl.innerHTML = '<p>No streams found from this addon.</p>';
                 return;
            }
            
            const torrents = data.streams.map(s => {
                let title = s.title || s.name || (s.behaviorHints ? s.behaviorHints.filename : 'Stream');
                title = title.split('\n')[0];
                return {
                    title: title,
                    streamUrl: s.url, 
                    magnet: s.url && s.url.startsWith('magnet:') ? s.url : (s.infoHash ? `magnet:?xt=urn:btih:${s.infoHash}` : null),
                    seeders: 0, 
                    size: 0 
                };
            });
            
            displayTorrents(torrents, season, episode);
            
        } catch (e) {
            console.error('[Addon] Error:', e);
            const tl = document.getElementById('torrentsList');
            if(tl) tl.innerHTML = `<div class="error-message">Addon Error: ${e.message}</div>`;
        }
    }
})();
</script>
<script>
(function() {
    let installedAddons = [];

    const originalLoadAddons = window.loadAddons;
    window.loadAddons = async function() {
        const res = await window.electronAPI.addonList();
        if (res.success) installedAddons = res.addons;
        
        if (originalLoadAddons) await originalLoadAddons();
        refreshSearchSources();
        renderAddonCatalogs();
    };

    function refreshSearchSources() {
        const select = document.getElementById('searchSourceSelect');
        if (!select) return;
        
        const defaultOpts = Array.from(select.options).filter(o => !o.value.startsWith('addon:'));
        select.innerHTML = '';
        defaultOpts.forEach(o => select.appendChild(o));
        
        installedAddons.forEach(addon => {
            // Check if addon has catalogs that could support search
            // Addons with movie/series catalogs can potentially support search
            let hasSearchableCatalogs = false;
            
            if (addon.manifest.catalogs && addon.manifest.catalogs.length > 0) {
                hasSearchableCatalogs = addon.manifest.catalogs.some(c => {
                    // Explicit search support
                    const hasExplicitSearch = c.extra && c.extra.some(e => e.name === 'search');
                    // Or it's a movie/series catalog (most support search even without declaring it)
                    const isSearchableType = c.type === 'movie' || c.type === 'series';
                    return hasExplicitSearch || isSearchableType;
                });
            }
            
            if (hasSearchableCatalogs) {
                const opt = document.createElement('option');
                opt.value = `addon:${addon.manifest.id}`;
                opt.textContent = addon.manifest.name;
                select.appendChild(opt);
            }
        });
    }

    const originalSearchMovies = window.searchMovies;
    window.searchMovies = async function(query) {
        const source = document.getElementById('searchSourceSelect')?.value;
        if (source && source.startsWith('addon:')) {
            const addonId = source.replace('addon:', '');
            return searchAddonCatalog(addonId, query);
        }
        if (originalSearchMovies) return originalSearchMovies(query);
    };

    async function searchAddonCatalog(addonId, query) {
        const addon = installedAddons.find(a => a.manifest.id === addonId);
        if (!addon) return;
        
        // Find searchable catalogs - prioritize explicit search support, then fall back to movie/series catalogs
        let searchCatalogs = [];
        if (addon.manifest.catalogs) {
            const explicitSearchCatalogs = addon.manifest.catalogs.filter(c => 
                c.extra && c.extra.some(e => e.name === 'search') && (c.type === 'movie' || c.type === 'series' || c.type === 'channel')
            );
            
            if (explicitSearchCatalogs.length > 0) {
                searchCatalogs = explicitSearchCatalogs;
            } else {
                // Fall back to any movie/series catalogs
                searchCatalogs = addon.manifest.catalogs.filter(c => c.type === 'movie' || c.type === 'series');
            }
        }
        
        if (searchCatalogs.length === 0) {
            showNotification('This addon does not support search', 'error');
            return;
        }

        const grid = document.getElementById('moviesGrid');
        const loading = document.getElementById('loadingIndicator');
        const sliders = document.getElementById('slidersContainer');
        const hero = document.getElementById('heroSection');
        const backBtn = document.getElementById('backToHomeBtn');
        const catalogsContainer = document.getElementById('addonCatalogsContainer');

        if (grid) grid.innerHTML = '';
        if (grid) grid.style.display = 'grid';
        if (loading) loading.style.display = 'block';
        if (sliders) sliders.style.display = 'none';
        if (hero) hero.style.display = 'none';
        if (catalogsContainer) catalogsContainer.style.display = 'none';
        if (backBtn) backBtn.style.display = 'block';
        
        isSearchMode = true;
        lastSearchQuery = query;

        try {
            let url = addon.url.replace('/manifest.json', '');
            if (url.endsWith('/')) url = url.slice(0, -1);
            
            // Try each catalog until we get results
            let allResults = [];
            for (const catalog of searchCatalogs) {
                try {
                    const searchUrl = `${url}/catalog/${catalog.type}/${catalog.id}/search=${encodeURIComponent(query)}.json`;
                    console.log('[AddonSearch] Trying:', searchUrl);
                    
                    const res = await fetch(searchUrl);
                    if (!res.ok) continue;
                    const data = await res.json();
                    
                    if (data.metas && data.metas.length > 0) {
                        allResults = [...allResults, ...data.metas];
                    }
                } catch (e) {
                    console.warn(`[AddonSearch] Failed for catalog ${catalog.id}:`, e);
                }
            }
            
            if (loading) loading.style.display = 'none';
            
            if (allResults.length === 0) {
                 if (grid) grid.innerHTML = '<div style="text-align:center; width:100%; grid-column:1/-1;">No results found</div>';
                 return;
            }
            
            lastSearchResults = allResults;
            renderStremioItems(allResults, grid);
            
        } catch (e) {
            console.error('[AddonSearch] Error:', e);
            if (loading) loading.style.display = 'none';
            showNotification('Search failed: ' + e.message, 'error');
        }
    }

    async function renderAddonCatalogs() {
        const container = document.getElementById('addonCatalogsContainer');
        if (!container) return;
        
        container.innerHTML = '';
        container.style.display = 'block';
        
        for (const addon of installedAddons) {
             if (!addon.manifest.catalogs) continue;
             
             const catalogs = addon.manifest.catalogs.filter(c => !c.extraRequired && (c.type === 'movie' || c.type === 'series')).slice(0, 2);
             
             for (const cat of catalogs) {
                 await renderCatalogSlider(addon, cat, container);
             }
        }
    }

    async function renderCatalogSlider(addon, catalog, container) {
        const section = document.createElement('div');
        section.className = 'slider-section';
        section.innerHTML = `
            <div class="slider-header">
                <h2 class="slider-title">
                    <i class="fas fa-puzzle-piece" style="color: var(--vlc-orange)"></i>
                    ${addon.manifest.name} - ${catalog.name || catalog.type}
                </h2>
            </div>
            <div class="slider-container">
                <div class="slider-track" style="display:flex; gap:1rem; overflow-x:auto; padding:1rem 0;">
                    <div class="loading"><i class="fas fa-spinner"></i></div>
                </div>
            </div>
        `;
        container.appendChild(section);
        
        const track = section.querySelector('.slider-track');
        
        try {
            let url = addon.url.replace('/manifest.json', '');
            if (url.endsWith('/')) url = url.slice(0, -1);
            
            const catUrl = `${url}/catalog/${catalog.type}/${catalog.id}.json`;
            const res = await fetch(catUrl);
            const data = await res.json();
            
            if (!data.metas || data.metas.length === 0) {
                section.remove();
                return;
            }
            
            track.innerHTML = '';
            renderStremioItems(data.metas.slice(0, 20), track, true);
            
        } catch (e) {
            console.error('[AddonHome] Error loading catalog:', e);
            section.remove();
        }
    }

    function renderStremioItems(metas, container, isSlider = false) {
        metas.forEach(meta => {
            const card = document.createElement('div');
            card.className = 'movie-card';
            if (isSlider) card.style.minWidth = '200px';
            
            card.innerHTML = `
                <img loading="lazy" src="${meta.poster}" class="movie-poster" onerror="this.src='img/no-poster.png'">
                <div class="movie-info">
                    <h3 class="movie-title">${meta.name}</h3>
                    <p class="movie-year">${meta.year || meta.type}</p>
                </div>
            `;
            
            card.addEventListener('click', () => {
                openStremioDetails(meta);
            });
            
            container.appendChild(card);
        });
    }
    
    async function openStremioDetails(previewMeta) {
        showNotification('Loading details...', 'info');
        
        let fullMeta = null;
        
        for (const addon of installedAddons) {
            if (addon.manifest.resources.some(r => r.name === 'meta' || r === 'meta') &&
                addon.manifest.types.includes(previewMeta.type)) {
                    
                if (addon.manifest.idPrefixes) {
                    if (!addon.manifest.idPrefixes.some(p => previewMeta.id.startsWith(p))) continue;
                }
                
                try {
                    let url = addon.url.replace('/manifest.json', '');
                    if (url.endsWith('/')) url = url.slice(0, -1);
                    
                    const metaUrl = `${url}/meta/${previewMeta.type}/${previewMeta.id}.json`;
                    const res = await fetch(metaUrl);
                    const data = await res.json();
                    if (data.meta) {
                        fullMeta = data.meta;
                        break;
                    }
                } catch(e) {}
            }
        }
        
        if (!fullMeta) fullMeta = previewMeta;
        
        // Check if addon meta includes moviedb_id (TMDB ID) - use it for richer metadata
        const tmdbId = fullMeta.moviedb_id || fullMeta.tmdb_id;
        if (tmdbId) {
            console.log('[Addon] Found TMDB ID in meta:', tmdbId);
            try {
                // Fetch TMDB data for richer metadata and episodes
                const tmdbType = fullMeta.type === 'series' ? 'tv' : fullMeta.type;
                const tmdbRes = await fetch(`https://api.themoviedb.org/3/${tmdbType}/${tmdbId}?api_key=b3556f3b206e16f82df4d1f6fd4545e6&append_to_response=credits,external_ids`);
                if (tmdbRes.ok) {
                    const tmdbData = await tmdbRes.json();
                    
                    // Create a proper item with TMDB data
                    const fakeItem = {
                        id: tmdbId, // Use TMDB ID
                        title: tmdbData.title || tmdbData.name,
                        original_title: tmdbData.original_title || tmdbData.original_name,
                        poster_path: tmdbData.poster_path,
                        backdrop_path: tmdbData.backdrop_path,
                        overview: tmdbData.overview,
                        vote_average: tmdbData.vote_average || 0,
                        release_date: tmdbData.release_date || tmdbData.first_air_date || '',
                        media_type: tmdbType,
                        seasons: tmdbData.seasons || [],
                        credits: tmdbData.credits,
                        external_ids: tmdbData.external_ids,
                        _addonMeta: fullMeta // Keep original addon meta for reference
                    };
                    
                    if (typeof openDetailsModal === 'function') {
                        openDetailsModal(fakeItem);
                    }
                    return;
                }
            } catch (e) {
                console.warn('[Addon] Failed to fetch TMDB data:', e);
            }
        }
        
        // Fallback to addon meta only
        const fakeItem = {
            id: fullMeta.id,
            title: fullMeta.name,
            original_title: fullMeta.name,
            poster_path: fullMeta.poster, 
            backdrop_path: fullMeta.background,
            overview: fullMeta.description,
            vote_average: fullMeta.imdbRating || 0,
            release_date: fullMeta.releaseInfo || (fullMeta.year ? `${fullMeta.year}-01-01` : ''),
            media_type: fullMeta.type,
            seasons: [] 
        };
        
        if (typeof openDetailsModal === 'function') {
             openDetailsModal(fakeItem);
        }
    }
})();
</script>
<script>
(function() {
    let installedAddons = [];

    // --- Monkey Patch fetchTorrents ---
    if (!window.originalFetchTorrents) {
        window.originalFetchTorrents = window.fetchTorrents;
    }

    // Initialize: Load installed addons
    window.loadAddons = async function() {
        try {
            const res = await window.electronAPI.addonList();
            if (res.success) {
                installedAddons = res.addons;
                refreshProviderButtons();
                updateSettingsList(); // Keep settings management

                // Update Search Source Select
                const select = document.getElementById('searchSourceSelect');
                if (select) {
                    const currentVal = select.value;
                    select.innerHTML = '<option value="tmdb">TMDB</option>';
                    installedAddons.forEach(addon => {
                        const hasCatalog = addon.manifest.resources && (addon.manifest.resources.includes('catalog') || addon.manifest.resources.some(r => r.name === 'catalog'));
                        if (hasCatalog) {
                            const option = document.createElement('option');
                            option.value = `addon:${addon.manifest.id}`;
                            option.textContent = addon.manifest.name;
                            select.appendChild(option);
                        }
                    });
                    if (currentVal && select.querySelector(`option[value="${currentVal}"]`)) {
                        select.value = currentVal;
                    }
                }

                if (typeof renderAddonCatalogs === 'function') {
                    renderAddonCatalogs();
                }
            }
        } catch (e) { console.error('Failed to load addons', e); }
    };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', async () => {
        await window.loadAddons();
        setupSettingsUI();
    });

    // --- Provider Logic (Keep this) ---
    window.fetchTorrents = async function(season, episode) {
        if (selectedProvider && selectedProvider.startsWith('addon:')) {
            const addonId = selectedProvider.replace('addon:', '');
            console.log('[Provider] Routing to Addon:', addonId);
            return fetchAddonStreams(addonId, season, episode);
        }
        if (window.originalFetchTorrents) {
            return window.originalFetchTorrents(season, episode);
        }
    };

    function refreshProviderButtons() {
        const containers = document.querySelectorAll('.provider-buttons');
        
        containers.forEach(container => {
            container.querySelectorAll('.addon-provider-btn').forEach(b => b.remove());

            installedAddons.forEach(addon => {
                // Check if addon provides 'stream' resources - metadata-only addons should NOT appear
                const resources = addon.manifest?.resources || [];
                const hasStream = resources.some(r => {
                    if (typeof r === 'string') return r === 'stream';
                    if (typeof r === 'object' && r !== null) return r.name === 'stream';
                    return false;
                }) || resources.includes('stream');
                
                if (hasStream) {
                    const btn = document.createElement('button');
                    btn.className = 'provider-btn addon-provider-btn';
                    btn.dataset.provider = `addon:${addon.manifest.id}`;
                    btn.textContent = addon.manifest.name;
                    btn.style.border = "1px solid var(--vlc-orange)";
                    
                    btn.addEventListener('click', () => {
                         document.querySelectorAll('.provider-btn').forEach(b => b.classList.remove('active'));
                         document.querySelectorAll(`.provider-btn[data-provider="addon:${addon.manifest.id}"]`).forEach(b => b.classList.add('active'));
                         
                         selectedProvider = btn.dataset.provider;
                         console.log('[Provider] Switched to:', selectedProvider);
                         
                         const tl = document.getElementById('torrentsList');
                         if(tl) tl.innerHTML = `<div class="loading"><i class="fas fa-spinner"></i> Searching ${addon.manifest.name}...</div>`;
                         
                         torrentsLoaded = false;
                         window.fetchTorrents(lastSearchedSeason, lastSearchedEpisode);
                    });
                    
                    container.appendChild(btn);
                }
            });
        });
    }

    // --- Settings UI (Keep this) ---
    function setupSettingsUI() {
        const installBtn = document.getElementById('installAddonBtn');
        const input = document.getElementById('addonManifestUrl');
        
        if (installBtn && input) {
            const newBtn = installBtn.cloneNode(true);
            if (installBtn.parentNode) installBtn.parentNode.replaceChild(newBtn, installBtn);
            
            newBtn.addEventListener('click', async () => {
                const url = input.value.trim();
                if (!url) return;
                
                newBtn.disabled = true;
                newBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                
                try {
                    const res = await window.electronAPI.addonInstall(url);
                    if (res.success) {
                        input.value = '';
                        await window.loadAddons();
                        showNotification('Addon installed successfully!', 'success');
                    } else {
                        showNotification('Failed to install addon: ' + res.message, 'error');
                    }
                } catch (e) {
                     showNotification('Error: ' + e.message, 'error');
                } finally {
                    newBtn.disabled = false;
                    newBtn.innerHTML = '<i class="fas fa-plus"></i> Install';
                }
            });
        }
    }

    function updateSettingsList() {
        const list = document.getElementById('installedAddonsList');
        if (!list) return;
        
        if (installedAddons.length === 0) {
            list.innerHTML = '<div style="text-align: center; color: var(--gray); padding: 1rem;">No addons installed</div>';
            return;
        }
        
        list.innerHTML = '';
        installedAddons.forEach(addon => {
            const item = document.createElement('div');
            item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px;';
            item.innerHTML = `
                <div style="overflow:hidden;">
                    <div style="font-weight: 600;">${addon.manifest.name} <span style="font-size: 0.8em; opacity: 0.7;">v${addon.manifest.version}</span></div>
                    <div style="font-size: 0.85em; opacity: 0.7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${addon.url}</div>
                </div>
                <button class="api-btn api-btn-secondary" style="padding: 0.4rem 0.6rem; font-size: 0.85rem; background: #dc3545; min-width: 32px;">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            
            item.querySelector('button').addEventListener('click', async () => {
                if (confirm(`Uninstall ${addon.manifest.name}?`)) {
                    await window.electronAPI.addonRemove(addon.manifest.id);
                    await window.loadAddons();
                }
            });
            
            list.appendChild(item);
        });
    }

    // --- Stream Fetching Logic (Updated with ID fix from previous step) ---
    async function fetchAddonStreams(addonId, season, episode) {
        const addon = installedAddons.find(a => a.manifest.id === addonId);
        if (!addon) return;
        
        try {
            const type = (currentMediaType === 'movie') ? 'movie' : 'series';
            let imdbId = '';
            
            // Try to get IMDB ID from currentContent (populated by TMDB usually)
            if (currentContent.external_ids && currentContent.external_ids.imdb_id) {
                imdbId = currentContent.external_ids.imdb_id;
            } else {
                 // Fetch if missing
                 const mediaType = currentMediaType === 'movie' ? 'movie' : 'tv';
                 const res = await fetch(`https://api.themoviedb.org/3/${mediaType}/${currentContent.id}/external_ids?api_key=${TMDB_API_KEY}`);
                 const data = await res.json();
                 imdbId = data.imdb_id;
            }
            
            if (!imdbId) throw new Error('No IMDB ID found');
            
            let resourceId = imdbId;
            if (type === 'series') {
                if (!season || !episode) throw new Error('Season and Episode required');
                resourceId = `${imdbId}:${season}:${episode}`;
            }
            
            let url = addon.url.replace('/manifest.json', '');
            if (url.endsWith('/')) url = url.slice(0, -1);
            
            const streamUrl = `${url}/stream/${type}/${resourceId}.json`;
            console.log('[Addon] Fetching streams:', streamUrl);
            
            const res = await fetch(streamUrl);
            const data = await res.json();
            
            if (!data.streams || data.streams.length === 0) {
                 const tl = document.getElementById('torrentsList');
                 if(tl) tl.innerHTML = '<p>No streams found from this addon.</p>';
                 return;
            }
            
            const torrents = data.streams.map(s => {
                let title = s.title || s.name || (s.behaviorHints ? s.behaviorHints.filename : 'Stream');
                title = title.split('\n')[0];
                return {
                    title: title,
                    streamUrl: s.url, 
                    magnet: s.url && s.url.startsWith('magnet:') ? s.url : (s.infoHash ? `magnet:?xt=urn:btih:${s.infoHash}` : null),
                    seeders: 0, 
                    size: 0 
                };
            });
            
            displayTorrents(torrents, season, episode);
            
        } catch (e) {
            console.error('[Addon] Error:', e);
            const tl = document.getElementById('torrentsList');
            if(tl) tl.innerHTML = `<div class="error-message">Addon Error: ${e.message}</div>`;
        }
    }
})();
</script>
</html>