<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlayTorrio Player</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            --primary-purple: #9d4edd;
            --dark-purple: #5a189a;
            --accent-purple: #c77dff;
            --bg-dark: #0a001a;
            --control-bg: rgba(10, 0, 20, 0.95);
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: #000; overflow: hidden;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            user-select: none; color: white;
        }
        body.hide-mouse { cursor: none; }
        
        #player-container {
            position: relative; width: 100%; height: 100%;
            background: #000; display: flex; align-items: center; justify-content: center;
        }
        video { width: 100%; height: 100%; object-fit: contain; }
        
        /* Draggable Area */
        .top-bar {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 25px 35px; display: flex; align-items: center; gap: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            z-index: 100; -webkit-app-region: drag;
            opacity: 0; transition: opacity 0.4s ease;
        }
        #player-container.show-controls .top-bar { opacity: 1; }
        .top-bar button, .top-bar span { -webkit-app-region: no-drag; }

        #video-title {
            font-size: 18px; font-weight: 600; color: var(--accent-purple);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            max-width: 70%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        /* Subtitles Overlay */
        #subtitle-overlay {
            position: absolute; bottom: 130px; left: 0; width: 100%;
            text-align: center; pointer-events: none; z-index: 50;
            text-shadow: 0 0 10px rgba(0,0,0,1), 0 0 5px black;
            color: #fff; font-weight: 600; font-size: 32px;
            padding: 0 12%; box-sizing: border-box; line-height: 1.4;
        }
        
        /* Controls Overlay */
        #controls-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: flex-end;
            opacity: 0; transition: opacity 0.4s ease; z-index: 90;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.4) 100%);
        }
        #player-container.show-controls #controls-overlay { opacity: 1; }

        .bottom-bar {
            padding: 20px 40px 45px 40px;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
        }

        /* Progress Bar */
        .progress-wrapper { padding: 15px 0; cursor: pointer; position: relative; }
        .progress-container {
            width: 100%; height: 6px; background: rgba(255,255,255,0.15);
            border-radius: 3px; position: relative; transition: height 0.1s;
        }
        .progress-wrapper:hover .progress-container { height: 10px; }
        
        .progress-bar {
            height: 100%; background: var(--primary-purple); width: 0%;
            border-radius: 3px; position: absolute; top: 0; left: 0; z-index: 3;
            box-shadow: 0 0 15px var(--primary-purple);
        }
        .progress-buffer {
            position: absolute; top: 0; left: 0; height: 100%;
            background: rgba(157, 78, 221, 0.4);
            width: 0%; border-radius: 3px; z-index: 2;
            transition: width 0.3s ease;
        }
        
        /* Hover Time Tooltip */
        #seek-tooltip {
            position: absolute; bottom: 35px; left: 0;
            transform: translateX(-50%); background: var(--primary-purple);
            color: white; padding: 4px 10px; border-radius: 6px;
            font-size: 13px; font-weight: 700; pointer-events: none;
            display: none; z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .controls-row { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .left-controls, .right-controls { display: flex; align-items: center; gap: 25px; }

        .icon-btn {
            background: none; border: none; color: white; cursor: pointer;
            padding: 10px; border-radius: 50%; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .icon-btn:hover { background: rgba(157, 78, 221, 0.25); color: var(--accent-purple); transform: scale(1.1); }
        .material-icons { font-size: 38px; }

        .volume-group {
            display: flex; align-items: center; gap: 12px;
            background: rgba(255,255,255,0.08); padding: 6px 18px;
            border-radius: 30px; border: 1px solid rgba(157, 78, 221, 0.2);
            width: fit-content;
        }
        #volume-slider {
            width: 100px; height: 4px; -webkit-appearance: none;
            background: rgba(255,255,255,0.2); border-radius: 2px; outline: none;
        }
        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: white; border-radius: 50%; box-shadow: 0 0 8px var(--primary-purple);
        }

        #time-display {
            font-size: 16px; font-weight: 600; color: #ddd;
            font-variant-numeric: tabular-nums; flex-shrink: 0;
        }

        /* Spinner */
        .spinner {
            width: 90px; height: 90px;
            border: 7px solid rgba(157, 78, 221, 0.1);
            border-top: 7px solid var(--primary-purple);
            border-radius: 50%; animation: spin 1s linear infinite;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); z-index: 110; display: none;
            filter: drop-shadow(0 0 15px var(--primary-purple));
        }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }

        /* Menus */
        .menu-popup {
            position: absolute; bottom: 120px; right: 40px;
            background: var(--control-bg); border: 1px solid rgba(157, 78, 221, 0.4);
            border-radius: 24px; width: 360px; max-height: 650px;
            display: flex; flex-direction: column; z-index: 120;
            box-shadow: 0 20px 60px rgba(0,0,0,0.9);
            backdrop-filter: blur(25px); opacity: 0; pointer-events: none;
            transform: translateY(30px); transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .menu-popup.visible { opacity: 1; pointer-events: auto; transform: translateY(0); }
        .menu-header {
            padding: 25px 30px; border-bottom: 1px solid rgba(255,255,255,0.1);
            font-weight: 700; font-size: 22px; color: var(--accent-purple);
            display: flex; justify-content: space-between; align-items: center;
        }
        .scrollable-list { flex: 1; overflow-y: auto; max-height: 350px; padding: 10px 15px; }
        .scrollable-list::-webkit-scrollbar { width: 5px; }
        .scrollable-list::-webkit-scrollbar-thumb { background: var(--primary-purple); border-radius: 10px; }

        .list-item {
            padding: 16px 22px; cursor: pointer; border-radius: 14px;
            font-size: 17px; display: flex; align-items: center; gap: 18px;
            transition: all 0.2s; margin-bottom: 6px;
        }
        .list-item:hover { background: rgba(157, 78, 221, 0.2); }
        .list-item.active { background: var(--primary-purple); color: white; font-weight: 600; }
        .sub-flag { width: 30px; height: 20px; border-radius: 5px; object-fit: cover; }

        .menu-footer {
            padding: 30px; border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3); border-radius: 0 0 24px 24px;
            display: flex; flex-direction: column; gap: 22px;
        }
        .menu-option { display: flex; justify-content: space-between; align-items: center; font-size: 15px; font-weight: 500; color: #ccc; }
        .menu-option input[type="range"] { flex: 1; margin-left: 25px; accent-color: var(--primary-purple); }
        .menu-option input[type="number"] { 
            background: rgba(0,0,0,0.5); border: 1px solid var(--primary-purple); 
            color: white; border-radius: 10px; padding: 8px 14px; width: 70px; text-align: center;
        }

        #transcode-badge {
            background: var(--primary-purple); color: white; font-size: 11px; padding: 3px 8px;
            border-radius: 5px; font-weight: 900; margin-left: 12px;
            vertical-align: middle; display: none; box-shadow: 0 0 10px var(--primary-purple);
        }

        /* Next Episode Button */
        #next-episode-btn {
            position: absolute;
            bottom: 180px;
            right: 40px;
            background: linear-gradient(135deg, var(--primary-purple), var(--dark-purple));
            color: white;
            border: none;
            padding: 16px 28px;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 115;
            box-shadow: 0 8px 32px rgba(157, 78, 221, 0.5);
            transition: all 0.3s ease;
            animation: nextEpPulse 2s ease-in-out infinite;
        }
        #next-episode-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 40px rgba(157, 78, 221, 0.7);
        }
        #next-episode-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            animation: none;
        }
        #next-episode-btn .material-icons {
            font-size: 24px;
        }
        #next-episode-btn .next-ep-text {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        #next-episode-btn .next-ep-label {
            font-size: 11px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #next-episode-btn .next-ep-title {
            font-size: 15px;
        }
        @keyframes nextEpPulse {
            0%, 100% { box-shadow: 0 8px 32px rgba(157, 78, 221, 0.5); }
            50% { box-shadow: 0 8px 40px rgba(157, 78, 221, 0.8); }
        }
        #next-episode-btn.loading .material-icons {
            animation: spin 1s linear infinite;
        }
        
        /* Debug Overlay */
        #debug-overlay {
            position: absolute;
            top: 80px;
            left: 20px;
            right: 20px;
            max-height: 60%;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            z-index: 200;
            display: none;
            white-space: pre-wrap;
            word-break: break-all;
        }
        #debug-overlay.visible {
            display: block;
        }
        #debug-overlay .error {
            color: #f55;
        }
        #debug-overlay .warn {
            color: #fa0;
        }
        #debug-overlay .info {
            color: #0af;
        }
    </style>
</head>
<body>
    <div id="player-container">
        <div class="top-bar">
            <button class="icon-btn" id="back-btn" title="Exit Player"><i class="material-icons">arrow_back</i></button>
            <div id="video-title">Initializing...</div>
            <span id="transcode-badge">TRANSCODING</span>
        </div>

        <video id="video-player" crossorigin="anonymous"></video>
        
        <div id="subtitle-overlay"></div>
        <div id="loading-spinner" class="spinner"></div>
        
        <!-- Debug Overlay (Press D to toggle) -->
        <div id="debug-overlay"></div>

        <!-- Next Episode Button (Basic Mode TV Shows Only) -->
        <button id="next-episode-btn" title="Play Next Episode">
            <i class="material-icons">skip_next</i>
            <div class="next-ep-text">
                <span class="next-ep-label">Up Next</span>
                <span class="next-ep-title">Next Episode</span>
            </div>
        </button>

        <div id="controls-overlay">
            <div class="bottom-bar">
                <div class="progress-wrapper" id="progress-wrapper">
                    <div id="seek-tooltip">00:00</div>
                    <div class="progress-container">
                        <div class="progress-buffer" id="progress-buffer"></div>
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                </div>

                <div class="controls-row">
                    <div class="left-controls">
                        <button class="icon-btn" id="play-pause-btn"><i class="material-icons">play_arrow</i></button>
                        <div class="volume-group">
                            <button class="icon-btn" id="mute-btn" style="padding:0;"><i class="material-icons" style="font-size:30px;">volume_up</i></button>
                            <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="1">
                        </div>
                        <span id="time-display">00:00 / 00:00</span>
                    </div>

                    <div class="right-controls">
                        <button class="icon-btn" id="external-player-btn" title="External Player" style="display:none;"><i class="material-icons">link</i></button>
                        <button class="icon-btn" id="audio-btn" title="Audio Tracks"><i class="material-icons">audiotrack</i></button>
                        <button class="icon-btn" id="settings-btn" title="Quality Settings"><i class="material-icons">settings</i></button>
                        <button class="icon-btn" id="subs-btn" title="Subtitles"><i class="material-icons">subtitles</i></button>
                        <button class="icon-btn" id="fullscreen-btn" title="Fullscreen"><i class="material-icons">fullscreen</i></button>
                    </div>
                </div>
            </div>
        </div>

        <!-- External Player Menu -->
        <div id="external-menu" class="menu-popup">
            <div class="menu-header">
                <span>EXTERNAL PLAYER</span>
                <button class="icon-btn" id="close-external" style="padding:4px;"><i class="material-icons">close</i></button>
            </div>
            <div class="p-8 text-center" style="padding: 30px;">
                <p class="text-sm text-gray-300 mb-6" style="margin-bottom: 20px; font-size: 14px; line-height: 1.5;">
                    Copy the URL below to open this video in your preferred external player (VLC, MPV, etc.).
                    <br><br>
                    <span style="color: var(--primary-purple); font-weight: bold;">‚ö†Ô∏è IMPORTANT:</span> Please keep this player active for the stream to stay live.
                </p>
                <button id="copy-stream-url" class="list-item active" style="width: 100%; justify-content: center; border: none; outline: none;">
                    <i class="material-icons" style="font-size: 20px;">content_copy</i>
                    <span>Copy Stream URL</span>
                </button>
            </div>
        </div>

        <!-- Audio Menu -->
        <div id="audio-menu" class="menu-popup">
            <div class="menu-header">
                <span>AUDIO TRACKS</span>
                <button class="icon-btn" id="close-audio" style="padding:4px;"><i class="material-icons">close</i></button>
            </div>
            <div id="audio-list" class="scrollable-list">
                <div style="padding:30px; text-align:center; color:#666;">Loading tracks...</div>
            </div>
        </div>

        <!-- Settings Menu -->
        <div id="settings-menu" class="menu-popup">
            <div class="menu-header">
                <span>QUALITY</span>
                <button class="icon-btn" id="close-settings" style="padding:4px;"><i class="material-icons">close</i></button>
            </div>
            <div id="settings-list" class="scrollable-list">
                <div class="list-item" data-quality="native" onclick="changeQuality('native', this)">üé¨ Native - Original Quality (No Scaling)</div>
                <div class="list-item" data-quality="high" onclick="changeQuality('high', this)">üî• 1080p - Full HD (Best Quality)</div>
                <div class="list-item active" data-quality="mid" onclick="changeQuality('mid', this)">‚ö° 720p - HD (Balanced)</div>
                <div class="list-item" data-quality="low" onclick="changeQuality('low', this)">üí® 480p - SD (Fastest)</div>
            </div>
        </div>

        <!-- Subtitle Menu -->
        <div id="subs-menu" class="menu-popup">
            <div class="menu-header">
                <span>SUBTITLES</span>
                <button class="icon-btn" id="close-subs" style="padding:4px;"><i class="material-icons">close</i></button>
            </div>
            <div id="subs-list" class="scrollable-list">
                <div style="padding:30px; text-align:center; color:#666;">Searching...</div>
            </div>
            <div class="menu-footer">
                <div class="menu-option">
                    <label>Delay (s)</label>
                    <input type="number" id="sub-delay" value="0" step="0.1">
                </div>
                <div class="menu-option">
                    <label>Text Size</label>
                    <input type="range" id="sub-size" min="16" max="80" value="32">
                </div>
                 <div class="menu-option">
                    <label>Position</label>
                    <input type="range" id="sub-pos" min="40" max="500" value="130">
                </div>
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        const video = document.getElementById('video-player');
        const overlay = document.getElementById('subtitle-overlay');
        const container = document.getElementById('player-container');
        const params = new URLSearchParams(window.location.search);
        
        // Debug overlay functionality
        const debugOverlay = document.getElementById('debug-overlay');
        let debugLogs = [];
        let debugVisible = false;
        
        function debugLog(msg, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${msg}`;
            debugLogs.push({ text: entry, type });
            if (debugLogs.length > 100) debugLogs.shift(); // Keep last 100 entries
            updateDebugOverlay();
            // Also log to console
            if (type === 'error') console.error(msg);
            else if (type === 'warn') console.warn(msg);
            else console.log(msg);
        }
        
        function updateDebugOverlay() {
            if (!debugVisible) return;
            debugOverlay.innerHTML = debugLogs.map(l => 
                `<div class="${l.type}">${l.text}</div>`
            ).join('');
            debugOverlay.scrollTop = debugOverlay.scrollHeight;
        }
        
        function toggleDebug() {
            debugVisible = !debugVisible;
            debugOverlay.classList.toggle('visible', debugVisible);
            if (debugVisible) updateDebugOverlay();
        }
        
        // Press 'D' to toggle debug overlay
        window.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                if (!e.ctrlKey && !e.altKey && !e.metaKey) {
                    toggleDebug();
                }
            }
        });
        
        // These need to be let so we can update them when switching episodes
        let videoUrl = params.get('url');
        const initialTime = parseFloat(params.get('t') || 0);
        const tmdbId = params.get('tmdbId');
        const imdbId = params.get('imdbId');
        const season = params.get('season');
        const episode = params.get('episode');
        const type = params.get('type');
        const isDebrid = params.get('isDebrid') === '1';
        const isBasicMode = params.get('isBasicMode') === '1';
        const showName = params.get('showName') || '';
        const provider = params.get('provider') || '';  // 'jackett' or addon ID
        const providerUrl = params.get('providerUrl') || '';  // addon base URL
        const quality = params.get('quality') || '1080p';

        const titleEl = document.getElementById('video-title');
        // Display show name with episode info, or just episode info
        if (season && episode) {
            titleEl.textContent = showName ? `${showName} - S${season}:E${episode}` : `S${season}:E${episode}`;
        } else {
            titleEl.textContent = showName || (type === 'movie' ? 'Movie' : 'Video');
        }

        // State
        let isTranscoding = false; 
        function updateTranscodeUI() {
            const badge = document.getElementById('transcode-badge');
            const settingsBtn = document.getElementById('settings-btn');
            const externalBtn = document.getElementById('external-player-btn');
            
            settingsBtn.style.display = 'flex';
            if (isBasicMode) {
                externalBtn.style.display = 'flex';
            } else {
                externalBtn.style.display = 'none';
            }

            if (isTranscoding) {
                badge.style.display = 'inline-block';
            } else {
                badge.style.display = 'none';
            }
        }
        updateTranscodeUI();
        let videoDuration = 0;
        let subtitles = [];
        let activeSub = null;
        let subDelay = 0;
        let subSize = 32;
        let subPos = 130;
        let activityTimeout;
        let currentAudioTrack = 0;
        let audioTracks = [];
        let currentQuality = 'mid';
        let retryCount = 0;
        const MAX_RETRIES = 10;
        const SOFTWARE_FALLBACK_THRESHOLD = 3; // Switch to software after 3 hardware failures
        let useSoftwareFallback = false;
        let lastAbsoluteTime = 0;
        let playbackStableTimer = null;
        let encoderInfo = null;
        let useRemux = false; // True if source has web-compatible codecs
        let sourceMetadata = null; // Cached metadata for current source

        // --- Initialization ---
        if (videoUrl) {
            initPlayer(videoUrl, initialTime);
        }
        
        if (tmdbId || imdbId) {
            initSubtitles(tmdbId, imdbId, season, episode, type);
        }
        
        // Fetch encoder status for display
        fetch('/api/transcode/status')
            .then(r => r.json())
            .then(data => {
                encoderInfo = data;
                console.log(`[Player] Encoder: ${data.encoderType} (${data.encoder}) on ${data.platform}`);
                // Update transcode badge with encoder info
                const badge = document.getElementById('transcode-badge');
                if (badge && data.isHardwareAccelerated) {
                    badge.textContent = data.encoderType.includes('NVIDIA') ? 'NVENC' : 
                                       data.encoderType.includes('Intel') ? 'QSV' :
                                       data.encoderType.includes('AMD') ? 'AMF' : 
                                       data.encoderType.includes('Apple') ? 'VT' :
                                       data.encoderType.includes('VAAPI') ? 'VAAPI' : 'HW';
                    badge.title = `Hardware Accelerated: ${data.encoderType}`;
                }
            })
            .catch(() => {});

        async function initPlayer(url, start) {
            document.getElementById('loading-spinner').style.display = 'block';
            lastAbsoluteTime = start || 0; 
            
            console.log('Player: Checking source codec compatibility...');
            
            // First, fetch metadata to check codec compatibility
            try {
                const metaRes = await fetch(`http://127.0.0.1:6987/api/transcode/metadata?url=${encodeURIComponent(url)}`);
                if (metaRes.ok) {
                    sourceMetadata = await metaRes.json();
                    if (sourceMetadata.duration) videoDuration = sourceMetadata.duration;
                    if (sourceMetadata.audioTracks) {
                        audioTracks = sourceMetadata.audioTracks;
                        renderAudioTracks();
                    }
                    
                    // Check if we can use fast remux (web-compatible codecs)
                    if (sourceMetadata.canRemux) {
                        console.log(`Player: ‚úÖ Web-compatible codecs detected (${sourceMetadata.videoCodec}) - using fast REMUX`);
                        useRemux = true;
                        
                        // Update badge to show REMUX mode
                        const badge = document.getElementById('transcode-badge');
                        if (badge) {
                            badge.textContent = 'REMUX';
                            badge.title = `Fast Remux: ${sourceMetadata.videoCodec.toUpperCase()} (no transcoding)`;
                            badge.style.background = 'linear-gradient(135deg, #10b981, #059669)'; // Green for remux
                        }
                    } else {
                        console.log(`Player: ‚ö†Ô∏è Incompatible codec (${sourceMetadata.videoCodec}) - using transcoding`);
                        useRemux = false;
                    }
                }
            } catch (e) {
                console.warn('Metadata fetch failed, defaulting to transcode:', e.message);
                useRemux = false;
            }
            
            // Start streaming
            isTranscoding = true;
            updateTranscodeUI();
            loadSmartStream(url, start);
        }

        function fallbackToTranscoder(url, start) {
            if (isTranscoding) return;
            isTranscoding = true;
            updateTranscodeUI();
            loadSmartStream(url, start);
        }
        
        // Smart stream loader - uses remux for compatible codecs, transcode for others
        function loadSmartStream(url, start) {
            if (useRemux) {
                loadRemuxStream(url, start);
            } else {
                loadTranscodedStream(url, start);
            }
        }
        
        // Fast remux - just repackages into MP4 container, no transcoding
        function loadRemuxStream(url, start) {
            console.log('Player: Loading REMUX Stream from', start, '(fast copy, no transcoding)');
            const targetUrl = url || videoUrl;
            const startTime = typeof start === 'number' ? start : lastAbsoluteTime;
            
            // For remux, use web-compatible audio track if current one isn't compatible
            let audioTrackToUse = currentAudioTrack;
            if (sourceMetadata?.audioTracks?.[currentAudioTrack] && !sourceMetadata.audioTracks[currentAudioTrack].webCompatible) {
                // Current audio track isn't web-compatible, use the first compatible one
                audioTrackToUse = sourceMetadata.webCompatibleAudioIndex || 0;
                console.log(`Player: Audio track ${currentAudioTrack} not web-compatible, using track ${audioTrackToUse}`);
            }
            
            const streamUrl = `http://127.0.0.1:6987/api/transcode/remux?url=${encodeURIComponent(targetUrl)}&start=${startTime}&audioTrack=${audioTrackToUse}`;
            
            document.getElementById('loading-spinner').style.display = 'block';
            isTranscoding = true;
            updateTranscodeUI();
            
            video.pause();
            video.removeAttribute('src');
            video.load();
            video.preload = 'auto';
            video.playsInline = true;
            video.src = streamUrl;
            video.load();
            
            const attemptPlay = async (attempts = 3) => {
                for (let i = 0; i < attempts; i++) {
                    try {
                        await video.play();
                        return;
                    } catch (e) {
                        if (i < attempts - 1) {
                            await new Promise(r => setTimeout(r, 500));
                        } else {
                            console.warn('Remux play() failed, falling back to transcode:', e);
                            // If remux fails, fall back to transcoding
                            useRemux = false;
                            loadTranscodedStream(url, start);
                        }
                    }
                }
            };
            attemptPlay();
        }

        function loadTranscodedStream(url, start) {
            console.log('Player: Loading Transcoded Stream from', start, 'Quality:', currentQuality, useSoftwareFallback ? '(SOFTWARE MODE)' : '');
            // Ensure we use the global videoUrl variable if url is just a placeholder
            const targetUrl = url || videoUrl;
            // Ensure start is a valid number
            const startTime = typeof start === 'number' ? start : lastAbsoluteTime;
            
            // Add forceSoftware parameter if we've hit the fallback threshold
            const softwareParam = useSoftwareFallback ? '&forceSoftware=true' : '';
            const streamUrl = `http://127.0.0.1:6987/api/transcode/stream?url=${encodeURIComponent(targetUrl)}&start=${startTime}&audioTrack=${currentAudioTrack}&quality=${currentQuality}${softwareParam}`;
            
            document.getElementById('loading-spinner').style.display = 'block';
            isTranscoding = true;
            updateTranscodeUI();
            
            // Abort any existing load
            video.pause();
            video.removeAttribute('src');
            video.load();
            
            // Set optimized video element properties for streaming
            video.preload = 'auto';
            video.playsInline = true;
            
            // Set new source and play
            video.src = streamUrl;
            video.load();
            
            // Use play with retry logic
            const attemptPlay = async (attempts = 3) => {
                for (let i = 0; i < attempts; i++) {
                    try {
                        await video.play();
                        return;
                    } catch (e) {
                        if (i < attempts - 1) {
                            await new Promise(r => setTimeout(r, 500));
                        } else {
                            console.warn('Transcoder play() failed after retries:', e);
                        }
                    }
                }
            };
            attemptPlay();
        }

        // --- Audio Tracks ---
        function renderAudioTracks() {
            const list = document.getElementById('audio-list');
            list.innerHTML = '';
            
            audioTracks.forEach(track => {
                const el = document.createElement('div');
                el.className = 'list-item' + (currentAudioTrack === track.id ? ' active' : '');
                el.innerHTML = `<span>${track.title} (${track.language.toUpperCase()})</span>`;
                el.onclick = () => {
                    if (currentAudioTrack === track.id && isTranscoding) return;
                    
                    currentAudioTrack = track.id;
                    document.querySelectorAll('#audio-list .list-item').forEach(x => x.classList.remove('active'));
                    el.classList.add('active');
                    
                    // If switching to non-web-compatible audio, force transcoding
                    if (useRemux && sourceMetadata?.audioTracks?.[track.id] && !sourceMetadata.audioTracks[track.id].webCompatible) {
                        console.log('[Player] Selected audio track not web-compatible, switching to transcode mode');
                        useRemux = false;
                    }
                    
                    const currentTime = lastAbsoluteTime; // Use reliable tracked time
                    isTranscoding = true;
                    loadSmartStream(videoUrl, currentTime);
                    document.getElementById('audio-menu').classList.remove('visible');
                };
                list.appendChild(el);
            });
        }

        const audioBtn = document.getElementById('audio-btn');
        const audioMenu = document.getElementById('audio-menu');
        const closeAudio = document.getElementById('close-audio');
        
        // --- External Player Logic ---
        const externalBtn = document.getElementById('external-player-btn');
        const externalMenu = document.getElementById('external-menu');
        const closeExternal = document.getElementById('close-external');
        const copyUrlBtn = document.getElementById('copy-stream-url');

        externalBtn.onclick = (e) => {
            e.stopPropagation();
            audioMenu.classList.remove('visible');
            subsMenu.classList.remove('visible');
            settingsMenu.classList.remove('visible');
            externalMenu.classList.toggle('visible');
        };
        closeExternal.onclick = () => externalMenu.classList.remove('visible');

        copyUrlBtn.onclick = () => {
            const currentUrl = videoUrl;
            if (currentUrl) {
                navigator.clipboard.writeText(currentUrl).then(() => {
                    const originalText = copyUrlBtn.querySelector('span').textContent;
                    const originalIcon = copyUrlBtn.querySelector('i').textContent;
                    
                    copyUrlBtn.querySelector('span').textContent = 'Copied!';
                    copyUrlBtn.querySelector('i').textContent = 'check';
                    
                    setTimeout(() => {
                        copyUrlBtn.querySelector('span').textContent = originalText;
                        copyUrlBtn.querySelector('i').textContent = originalIcon;
                    }, 2000);
                });
            }
        };

        audioBtn.onclick = (e) => {
            e.stopPropagation();
            subsMenu.classList.remove('visible');
            settingsMenu.classList.remove('visible');
            externalMenu.classList.remove('visible');
            audioMenu.classList.toggle('visible');
        };
        closeAudio.onclick = () => audioMenu.classList.remove('visible');

        // --- Settings Menu ---
        const settingsBtn = document.getElementById('settings-btn');
        const settingsMenu = document.getElementById('settings-menu');
        const closeSettings = document.getElementById('close-settings');
        
        settingsBtn.onclick = (e) => {
            e.stopPropagation();
            audioMenu.classList.remove('visible');
            subsMenu.classList.remove('visible');
            settingsMenu.classList.toggle('visible');
        };
        closeSettings.onclick = () => settingsMenu.classList.remove('visible');

        window.changeQuality = (q, el) => {
            if (currentQuality === q && isTranscoding) return;
            currentQuality = q;
            
            document.querySelectorAll('#settings-list .list-item').forEach(x => x.classList.remove('active'));
            if (el) el.classList.add('active');
            
            settingsMenu.classList.remove('visible');
            
            // Quality change requires transcoding (remux doesn't support quality change)
            if (useRemux && q !== 'native') {
                console.log('[Player] Quality change requested, switching to transcode mode');
                useRemux = false;
            }
            
            const currentTime = lastAbsoluteTime; // Use reliable tracked time
            // Force transcoding switch
            isTranscoding = true;
            loadSmartStream(videoUrl, currentTime);
        };

        // --- Controls ---
        const playBtn = document.getElementById('play-pause-btn');
        const playIcon = playBtn.querySelector('i');
        
        function togglePlay() {
            if (video.paused) video.play();
            else video.pause();
        }
        playBtn.onclick = togglePlay;
        video.onclick = (e) => { if (e.target.id === 'video-player') togglePlay(); };

        video.onplay = () => { playIcon.textContent = 'pause'; document.getElementById('loading-spinner').style.display = 'none'; };
        video.onpause = () => { playIcon.textContent = 'play_arrow'; };
        video.onwaiting = () => { document.getElementById('loading-spinner').style.display = 'block'; };
        
        // Stall detection - if waiting for more than 15 seconds, retry
        let stallTimer = null;
        let lastBufferCheck = 0;
        
        video.onwaiting = () => { 
            document.getElementById('loading-spinner').style.display = 'block';
            
            // Start stall detection
            if (stallTimer) clearTimeout(stallTimer);
            lastBufferCheck = video.currentTime;
            
            stallTimer = setTimeout(() => {
                // Check if we're still stalled at the same position
                if (Math.abs(video.currentTime - lastBufferCheck) < 0.5 && !video.paused) {
                    console.warn('Player: Stall detected, attempting recovery...');
                    handlePlaybackError({ code: 'STALL', message: 'Playback stalled' });
                }
            }, 15000); // 15 second stall threshold
        };
        
        video.onplaying = () => { 
            document.getElementById('loading-spinner').style.display = 'none';
            
            // Clear stall timer
            if (stallTimer) {
                clearTimeout(stallTimer);
                stallTimer = null;
            }
            
            // Only reset retry count if playback is stable for 10 seconds
            if (playbackStableTimer) clearTimeout(playbackStableTimer);
            playbackStableTimer = setTimeout(() => {
                retryCount = 0;
                // If we were in software fallback and playback is now stable, keep using software
                // (don't reset useSoftwareFallback - it worked!)
                console.log('Player: Playback stable, retry count reset');
            }, 10000);
        };
        
        video.oncanplaythrough = () => {
            // Clear stall timer when we have enough buffer
            if (stallTimer) {
                clearTimeout(stallTimer);
                stallTimer = null;
            }
        };

        // Handle stream ending (normal or premature)
        video.onended = () => {
            const duration = (isTranscoding && videoDuration > 0) ? videoDuration : video.duration;
            // If ended but we are far from the end (e.g., > 10 seconds remaining), treat as error/crash
            if (duration && lastAbsoluteTime < (duration - 10)) {
                console.warn(`Video ended prematurely at ${lastAbsoluteTime}s (duration: ${duration}s). Retrying...`);
                handlePlaybackError({ code: 'PREMATURE_END', message: 'Stream ended early' });
            } else {
                console.log('Video ended normally.');
            }
        };

        video.onerror = () => {
            const err = video.error;
            console.warn('Video error:', err);
            handlePlaybackError(err);
        };

        function handlePlaybackError(err) {
            if (!isTranscoding) {
                console.warn('Video error occurred, falling back to transcoder');
                fallbackToTranscoder(videoUrl, lastAbsoluteTime);
            } else {
                // Check if we were using remux and it failed - fall back to transcoding
                if (useRemux) {
                    console.warn('[Player] Remux failed, falling back to transcoding...');
                    useRemux = false;
                    retryCount = 0;
                    
                    // Update badge with correct encoder type
                    const badge = document.getElementById('transcode-badge');
                    if (badge) {
                        badge.textContent = encoderInfo?.isHardwareAccelerated ? 
                            (encoderInfo.encoderType.includes('NVIDIA') ? 'NVENC' : 
                             encoderInfo.encoderType.includes('Intel') ? 'QSV' :
                             encoderInfo.encoderType.includes('AMD') ? 'AMF' :
                             encoderInfo.encoderType.includes('Apple') ? 'VT' :
                             encoderInfo.encoderType.includes('VAAPI') ? 'VAAPI' : 'HW') : 'CPU';
                        badge.title = encoderInfo?.isHardwareAccelerated ? 
                            `Hardware Accelerated: ${encoderInfo.encoderType}` : 'Software Encoding';
                        badge.style.background = ''; // Reset to default
                    }
                    
                    setTimeout(() => {
                        loadTranscodedStream(videoUrl, lastAbsoluteTime);
                    }, 500);
                    return;
                }
                
                // Transcoder stream failed - Retry Logic
                if (retryCount < MAX_RETRIES) {
                    retryCount++;
                    const resumeTime = lastAbsoluteTime;
                    
                    // Check if we should switch to software encoding
                    // This helps users whose hardware encoder detection passes but actual encoding fails
                    if (!useSoftwareFallback && retryCount >= SOFTWARE_FALLBACK_THRESHOLD && encoderInfo?.isHardwareAccelerated) {
                        console.warn(`[Player] Hardware encoding failed ${SOFTWARE_FALLBACK_THRESHOLD} times, switching to software fallback...`);
                        useSoftwareFallback = true;
                        retryCount = 0; // Reset retry count for software attempts
                        
                        // Update UI to show software mode
                        const badge = document.getElementById('transcode-badge');
                        if (badge) {
                            badge.textContent = 'CPU';
                            badge.title = 'Software Encoding (Fallback)';
                            badge.style.background = ''; // Reset to default
                        }
                    }
                    
                    console.log(`Transcoder error (code ${err?.code}). Retrying (${retryCount}/${MAX_RETRIES}) from ${resumeTime}s...${useSoftwareFallback ? ' [SOFTWARE MODE]' : ''}`);
                    
                    // Show spinner
                    document.getElementById('loading-spinner').style.display = 'block';
                    
                    // Small delay to prevent tight loop and allow server cleanup
                    setTimeout(() => {
                        loadTranscodedStream(videoUrl, resumeTime);
                    }, 1000);
                } else {
                    console.error('Max retries reached for transcoder.');
                    document.getElementById('loading-spinner').style.display = 'none';
                    // Optional: show UI message
                }
            }
        }

        // Progress & Seeking
        const progressWrapper = document.getElementById('progress-wrapper');
        const progressBar = document.getElementById('progress-bar');
        const progressBuffer = document.getElementById('progress-buffer');
        const timeDisplay = document.getElementById('time-display');
        const seekTooltip = document.getElementById('seek-tooltip');

        function getCurrentRealTime() {
            if (!isTranscoding) return video.currentTime;
            try {
                const urlObj = new URL(video.src);
                const offset = parseFloat(urlObj.searchParams.get('start') || 0);
                return offset + video.currentTime;
            } catch(e) { 
                // Fallback for cases where src might be temporarily invalid during switch
                return video.currentTime; 
            }
        }

        video.ontimeupdate = () => {
            const currentDuration = (isTranscoding && videoDuration > 0) ? videoDuration : video.duration;
            const currentTime = getCurrentRealTime();
            
            // Track absolute time reliably for resume/recovery
            if (currentTime > 0) lastAbsoluteTime = currentTime;
            
            const pct = (currentTime / currentDuration) * 100;
            progressBar.style.width = `${pct || 0}%`;
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(currentDuration)}`;
            updateSubtitles(currentTime);
            
            // Check for next episode button (Basic Mode TV shows only)
            if (typeof checkShowNextEpisodeButton === 'function') {
                checkShowNextEpisodeButton();
            }
        };
        
        video.onprogress = () => {
            const currentDuration = (isTranscoding && videoDuration > 0) ? videoDuration : video.duration;
            if (video.buffered.length && currentDuration > 0) {
                const end = video.buffered.end(video.buffered.length - 1);
                const offset = isTranscoding ? parseFloat(new URL(video.src).searchParams.get('start') || 0) : 0;
                const pct = ((end + offset) / currentDuration) * 100;
                progressBuffer.style.width = `${Math.min(100, pct)}%`;
            }
        };

        progressWrapper.onmousemove = (e) => {
            const rect = progressWrapper.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            const currentDuration = (isTranscoding && videoDuration > 0) ? videoDuration : video.duration;
            if (isFinite(currentDuration)) {
                const hoverTime = pos * currentDuration;
                seekTooltip.textContent = formatTime(hoverTime);
                seekTooltip.style.left = `${e.clientX - rect.left}px`;
                seekTooltip.style.display = 'block';
            }
        };
        progressWrapper.onmouseleave = () => { seekTooltip.style.display = 'none'; };

        progressWrapper.onclick = (e) => {
            const rect = progressWrapper.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            const currentDuration = (isTranscoding && videoDuration > 0) ? videoDuration : video.duration;
            if (isFinite(currentDuration)) {
                const newTime = pos * currentDuration;
                if (isTranscoding) loadSmartStream(videoUrl, newTime);
                else video.currentTime = newTime;
            }
        };

        // Volume
        const muteBtn = document.getElementById('mute-btn');
        const volSlider = document.getElementById('volume-slider');
        muteBtn.onclick = () => { video.muted = !video.muted; updateVolIcon(); };
        volSlider.oninput = (e) => { video.volume = e.target.value; video.muted = false; updateVolIcon(); };
        function updateVolIcon() {
            const i = muteBtn.querySelector('i');
            if (video.muted || video.volume === 0) i.textContent = 'volume_off';
            else if (video.volume < 0.5) i.textContent = 'volume_down';
            else i.textContent = 'volume_up';
        }

        // Fullscreen
        const fsBtn = document.getElementById('fullscreen-btn');
        fsBtn.onclick = () => {
            if (!document.fullscreenElement) { container.requestFullscreen(); fsBtn.querySelector('i').textContent = 'fullscreen_exit'; } 
            else { document.exitFullscreen(); fsBtn.querySelector('i').textContent = 'fullscreen'; }
        };

        // Back Button
        document.getElementById('back-btn').onclick = () => { window.close(); };

        // Mouse Hiding
        function showControls() {
            container.classList.add('show-controls');
            document.body.classList.remove('hide-mouse');
            clearTimeout(activityTimeout);
            activityTimeout = setTimeout(() => {
                if (!video.paused && !subsMenu.classList.contains('visible') && !audioMenu.classList.contains('visible') && !settingsMenu.classList.contains('visible')) {
                    container.classList.remove('show-controls');
                    document.body.classList.add('hide-mouse');
                }
            }, 3000);
        }
        container.onmousemove = showControls;
        container.onclick = showControls;

        // --- Subtitles ---
        const subsBtn = document.getElementById('subs-btn');
        const subsMenu = document.getElementById('subs-menu');
        const closeSubs = document.getElementById('close-subs');
        
        subsBtn.onclick = (e) => {
            e.stopPropagation();
            audioMenu.classList.remove('visible');
            settingsMenu.classList.remove('visible');
            subsMenu.classList.toggle('visible');
        };
        closeSubs.onclick = () => subsMenu.classList.remove('visible');

        document.getElementById('sub-delay').oninput = (e) => subDelay = parseFloat(e.target.value) || 0;
        document.getElementById('sub-size').oninput = (e) => {
            subSize = e.target.value; overlay.style.fontSize = subSize + 'px';
        };
        document.getElementById('sub-pos').oninput = (e) => {
            subPos = e.target.value; overlay.style.bottom = subPos + 'px';
        };

        function parseSRT(text) {
            const arr = [];
            const blocks = text.trim().replace(/\r\n/g, '\n').split('\n\n');
            blocks.forEach(block => {
                const lines = block.split('\n');
                if (lines.length >= 2) {
                    let timeIdx = lines[0].includes('-->') ? 0 : 1;
                    if (lines.length > timeIdx) {
                        const match = lines[timeIdx].match(/(\d+):(\d+):(\d+)[,.](\d+)\s*-->\s*(\d+):(\d+):(\d+)[,.](\d+)/);
                        if (match) {
                            const start = parseInt(match[1])*3600 + parseInt(match[2])*60 + parseInt(match[3]) + parseInt(match[4])/1000;
                            const end = parseInt(match[5])*3600 + parseInt(match[6])*60 + parseInt(match[7]) + parseInt(match[8])/1000;
                            const textLines = lines.slice(timeIdx + 1).join('\n');
                            arr.push({ start, end, text: textLines });
                        }
                    }
                }
            });
            return arr;
        }

        function updateSubtitles(time) {
            const t = time + subDelay;
            const sub = subtitles.find(s => t >= s.start && t <= s.end);
            if (sub) {
                if (activeSub !== sub) {
                    overlay.innerHTML = sub.text.replace(/\n/g, '<br>');
                    activeSub = sub;
                }
            } else if (activeSub) {
                overlay.innerHTML = '';
                activeSub = null;
            }
        }

        async function initSubtitles(tmdbId, imdbId, season, episode, type) {
            const list = document.getElementById('subs-list');
            list.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">Searching subtitles...</div>';
            
            // Standard "None" option
            const noneItem = document.createElement('div');
            noneItem.className = 'list-item';
            noneItem.innerHTML = '<span>None</span>';
            noneItem.onclick = () => {
                subtitles = []; overlay.innerHTML = '';
                document.querySelectorAll('#subs-list .list-item').forEach(el => el.classList.remove('active'));
                noneItem.classList.add('active'); subsMenu.classList.remove('visible');
            };

            const allItems = [noneItem];

            // 1. Fetch Wyzie (requires TMDB ID)
            if (tmdbId) {
                try {
                    let wyzieUrl = `https://sub.wyzie.ru/search?id=${tmdbId}`;
                    if (season && episode) wyzieUrl += `&season=${season}&episode=${episode}`;
                    
                    const res = await fetch(wyzieUrl);
                    const wyzieData = await res.json();
                    
                    if (wyzieData && wyzieData.length > 0) {
                        const sep = document.createElement('div');
                        sep.style.padding = '10px 15px';
                        sep.style.fontSize = '12px';
                        sep.style.color = 'var(--accent-purple)';
                        sep.style.fontWeight = 'bold';
                        sep.style.textTransform = 'uppercase';
                        sep.style.letterSpacing = '1px';
                        sep.innerText = 'Wyzie Subtitles';
                        allItems.push(sep);

                        wyzieData.forEach(sub => {
                            const el = document.createElement('div');
                            el.className = 'list-item';
                        el.innerHTML = `<img src="${sub.flagUrl || ''}" class="sub-flag" onerror="this.style.display='none'"><span>${sub.display}</span>`;
                        el.onclick = async () => {
                            document.querySelectorAll('#subs-list .list-item').forEach(x => x.classList.remove('active'));
                            el.classList.add('active');
                            try {
                                const txtRes = await fetch(sub.url);
                                const txt = await txtRes.text();
                                subtitles = parseSRT(txt); subsMenu.classList.remove('visible');
                            } catch(err) {}
                        };
                        allItems.push(el);
                    });
                }
            } catch (e) { console.error('Wyzie fetch error', e); }
            } // End of if (tmdbId) for Wyzie

            // 2. Fetch from Stremio Addons
            try {
                // Get addons from main process (reads addons.json)
                const addons = await ipcRenderer.invoke('get-installed-addons');
                
                if (addons && Array.isArray(addons)) {
                    for (const addon of addons) {
                        // Check if it supports subtitles? The user just said "when a user places a subtitles addon"
                        // We will try to fetch subtitles from it.
                        if (!imdbId) continue; // Stremio addons need IMDB ID (mostly) or Kitsu/etc. We have IMDB.

                        // addon.url contains the manifest URL based on user provided structure
                        const manifestUrl = addon.url || addon.manifestUrl; 
                        if (!manifestUrl) continue;

                        const addonSubs = await fetchAddonSubtitles(manifestUrl, imdbId, season, episode, type);
                        if (addonSubs && addonSubs.length > 0) {
                            const sep = document.createElement('div');
                            sep.style.padding = '10px 15px';
                            sep.style.fontSize = '12px';
                            sep.style.color = 'var(--accent-purple)';
                            sep.style.fontWeight = 'bold';
                            sep.style.textTransform = 'uppercase';
                            sep.style.letterSpacing = '1px';
                            // Use manifest name if available
                            const addonName = (addon.manifest && addon.manifest.name) ? addon.manifest.name : 'Addon Subtitles';
                            sep.innerText = addonName;
                            allItems.push(sep);

                            addonSubs.forEach(sub => {
                                const el = document.createElement('div');
                                el.className = 'list-item';
                                // User request: "display the ar en not the title, just the lang or lang code"
                                // Prefer short code if available (e.g. "ar"), else lang (e.g. "ara")
                                const langLabel = (sub.lang_code || sub.lang || 'Unknown').toUpperCase();
                                
                                el.innerHTML = `<span>${langLabel}</span>`;
                                
                                // Add title/id as tooltip so user can still distinguish if needed (hover)
                                if (sub.title || sub.id) {
                                    el.title = sub.title || sub.id;
                                }

                                el.onclick = async () => {
                                    document.querySelectorAll('#subs-list .list-item').forEach(x => x.classList.remove('active'));
                                    el.classList.add('active');
                                    try {
                                        // Stremio subs can be url or externalUrl
                                        const targetUrl = sub.url || sub.externalUrl;
                                        if (targetUrl) {
                                            const txtRes = await fetch(targetUrl);
                                            const txt = await txtRes.text();
                                            subtitles = parseSRT(txt); 
                                            subsMenu.classList.remove('visible');
                                        }
                                    } catch(err) { console.error(err); }
                                };
                                allItems.push(el);
                            });
                        }
                    }
                }
            } catch (e) { console.error('Addon fetch error', e); }

            // Render
            list.innerHTML = '';
            if (allItems.length <= 1) {
                list.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">No subtitles found</div>';
            } else {
                allItems.forEach(item => list.appendChild(item));
            }
        }

        async function fetchAddonSubtitles(manifestUrl, imdbId, season, episode, type) {
            try {
                // 1. Get Manifest to resolve ID prefix (usually not needed if we just assume standard /subtitles/resource/id.json)
                // But properly we should read manifest resources. For now, assuming standard Stremio protocol.
                // Protocol: [base]/subtitles/[type]/[id].json
                // id for movies: tt1234567
                // id for series: tt1234567:1:1
                
                // Clean manifest URL (remove manifest.json if present to get base)
                let baseUrl = manifestUrl.replace('/manifest.json', '');
                
                // Construct ID
                let resourceId = imdbId;
                if (type !== 'movie' && season && episode) {
                    resourceId = `${imdbId}:${season}:${episode}`;
                }

                const endpoint = `${baseUrl}/subtitles/${type}/${encodeURIComponent(resourceId)}.json`;
                
                const res = await fetch(endpoint);
                if (!res.ok) return [];
                const data = await res.json();
                
                return data.subtitles || [];
            } catch (e) {
                console.warn('Failed to fetch from addon:', manifestUrl, e);
                return [];
            }
        }

        function formatTime(s) {
            if (!s || isNaN(s) || !isFinite(s)) return "00:00";
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            const h = Math.floor(m / 60);
            const mm = m % 60;
            if (h > 0) return `${h}:${mm.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
            return `${mm.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
        }

        window.addEventListener('keydown', (e) => {
            showControls();
            if (e.key === ' ' || e.key === 'k') togglePlay();
            if (e.key === 'f') fsBtn.click();
            if (e.key === 'ArrowRight') {
                const currentDuration = (isTranscoding && videoDuration > 0) ? videoDuration : video.duration;
                const currentTime = getCurrentRealTime();
                const newTime = Math.min(currentDuration, currentTime + 10);
                if (isTranscoding) loadSmartStream(videoUrl, newTime);
                else video.currentTime = newTime;
            }
            if (e.key === 'ArrowLeft') {
                const currentTime = getCurrentRealTime();
                const newTime = Math.max(0, currentTime - 10);
                if (isTranscoding) loadSmartStream(videoUrl, newTime);
                else video.currentTime = newTime;
            }
            if (e.key === 'Escape') {
                if (document.fullscreenElement) document.exitFullscreen();
                else window.close();
            }
        });

        // ============================================================================
        // NEXT EPISODE AUTO-PLAY (Basic Mode TV Shows Only)
        // ============================================================================
        
        const nextEpBtn = document.getElementById('next-episode-btn');
        let nextEpisodeData = null;
        let nextEpisodeShown = false;
        let currentTorrentHash = null;
        let currentTorrentFiles = null;
        let currentProviderType = null; // 'jackett' or addon ID
        let currentStreamQuality = null;
        
        // Extract torrent hash from WebTorrent stream URL
        function extractTorrentHash(url) {
            if (!url) return null;
            try {
                const urlObj = new URL(url);
                return urlObj.searchParams.get('hash');
            } catch (e) {
                return null;
            }
        }
        
        // Check if we're streaming via WebTorrent (local stream)
        function isWebTorrentStream(url) {
            return url && url.includes('/api/stream-file');
        }
        
        // Initialize next episode detection for Basic Mode TV shows
        async function initNextEpisode() {
            // Only for Basic Mode TV shows
            if (!isBasicMode || type !== 'tv' || !season || !episode) {
                debugLog('[NextEp] Not applicable: isBasicMode=' + isBasicMode + ', type=' + type);
                return;
            }
            
            debugLog('[NextEp] Initializing for S' + season + 'E' + episode);
            
            // Extract current torrent hash if WebTorrent stream
            currentTorrentHash = extractTorrentHash(videoUrl);
            if (currentTorrentHash) {
                debugLog('[NextEp] Current torrent hash: ' + currentTorrentHash);
                // Fetch torrent files for same-torrent detection
                try {
                    const res = await fetch(`/api/torrent-info?hash=${currentTorrentHash}`);
                    if (res.ok) {
                        const data = await res.json();
                        currentTorrentFiles = data.files || [];
                        debugLog('[NextEp] Loaded ' + currentTorrentFiles.length + ' files from current torrent');
                    }
                } catch (e) {
                    debugLog('[NextEp] Could not fetch torrent files: ' + e.message, 'warn');
                }
            }
            
            // Get provider info from URL params (primary) or localStorage (fallback)
            let savedShowName = showName || '';
            currentProviderType = provider || null;
            currentStreamQuality = quality || '1080p';
            
            // Fallback to localStorage if URL params are missing
            if (!currentProviderType) {
                try {
                    const providerInfo = localStorage.getItem('basicmode_last_provider');
                    if (providerInfo) {
                        const info = JSON.parse(providerInfo);
                        currentProviderType = info.provider;
                        if (!currentStreamQuality || currentStreamQuality === '1080p') {
                            currentStreamQuality = info.quality || '1080p';
                        }
                        if (!savedShowName) savedShowName = info.showName || '';
                        debugLog('[NextEp] Got provider from localStorage: ' + currentProviderType);
                    }
                } catch (e) {
                    debugLog('[NextEp] Error reading localStorage: ' + e.message, 'warn');
                }
            }
            
            debugLog('[NextEp] Provider: ' + currentProviderType);
            debugLog('[NextEp] Provider URL: ' + providerUrl);
            debugLog('[NextEp] Quality: ' + currentStreamQuality);
            debugLog('[NextEp] Show name: ' + savedShowName);
            
            // Calculate next episode
            const nextEp = parseInt(episode) + 1;
            nextEpisodeData = {
                season: parseInt(season),
                episode: nextEp,
                tmdbId: tmdbId,
                imdbId: imdbId,
                showName: savedShowName
            };
            
            debugLog('[NextEp] Next episode will be S' + season + 'E' + nextEp);
            debugLog('[NextEp] IMDB ID: ' + imdbId + ', TMDB ID: ' + tmdbId);
        }
        
        // Check if next episode exists in current torrent
        function findNextEpisodeInTorrent(files, targetSeason, targetEpisode) {
            if (!files || !files.length) return null;
            
            const s = parseInt(targetSeason);
            const e = parseInt(targetEpisode);
            
            debugLog('[NextEp] Searching for S' + s + 'E' + e + ' in ' + files.length + ' files');
            
            for (const file of files) {
                // Handle different file structures (WebTorrent vs Debrid)
                const fullPath = (file.path || file.filename || file.name || '').toLowerCase();
                const fileName = fullPath.split('/').pop(); // Get just the filename
                
                // Skip non-video files
                if (!fileName.match(/\.(mp4|mkv|avi|mov|wmv|flv|webm|m4v)$/i)) continue;
                if (fileName.includes('sample') || fileName.includes('trailer')) continue;
                
                // Check for episode patterns
                const patterns = [
                    new RegExp(`s0*${s}e0*${e}\\b`, 'i'),
                    new RegExp(`\\b${s}x0*${e}\\b`, 'i'),
                    new RegExp(`season\\s*${s}\\s*episode\\s*${e}\\b`, 'i'),
                    new RegExp(`s0*${s}\\.e0*${e}\\b`, 'i')
                ];
                
                for (const pattern of patterns) {
                    if (pattern.test(fileName)) {
                        debugLog('[NextEp] Found next episode in torrent: ' + fileName);
                        return file;
                    }
                }
            }
            
            debugLog('[NextEp] Episode not found in torrent files');
            return null;
        }
        
        // Show next episode button when in last 5 minutes
        function checkShowNextEpisodeButton() {
            if (!isBasicMode || type !== 'tv' || !nextEpisodeData || nextEpisodeShown) return;
            
            const currentDuration = (isTranscoding && videoDuration > 0) ? videoDuration : video.duration;
            const currentTime = getCurrentRealTime();
            const remainingTime = currentDuration - currentTime;
            
            // Show button when 5 minutes (300 seconds) or less remaining
            if (remainingTime <= 300 && remainingTime > 0 && currentDuration > 0) {
                showNextEpisodeButton();
            }
        }
        
        function showNextEpisodeButton() {
            if (nextEpisodeShown) return;
            nextEpisodeShown = true;
            
            const titleSpan = nextEpBtn.querySelector('.next-ep-title');
            titleSpan.textContent = `S${nextEpisodeData.season}E${nextEpisodeData.episode}`;
            
            nextEpBtn.style.display = 'flex';
            debugLog('[NextEp] Button shown for S' + nextEpisodeData.season + 'E' + nextEpisodeData.episode);
        }
        
        // Handle next episode button click
        nextEpBtn.onclick = async () => {
            if (nextEpBtn.disabled) return;
            
            nextEpBtn.disabled = true;
            nextEpBtn.classList.add('loading');
            nextEpBtn.querySelector('.next-ep-title').textContent = 'Loading...';
            
            // Auto-show debug overlay when clicking next episode
            if (!debugVisible) toggleDebug();
            
            try {
                await playNextEpisode();
            } catch (err) {
                debugLog('[NextEp] ========== ERROR ==========', 'error');
                debugLog('[NextEp] Error: ' + err.message, 'error');
                nextEpBtn.querySelector('.next-ep-title').textContent = 'Error';
                nextEpBtn.classList.remove('loading');
                setTimeout(() => {
                    nextEpBtn.disabled = false;
                    nextEpBtn.querySelector('.next-ep-title').textContent = `S${nextEpisodeData.season}E${nextEpisodeData.episode}`;
                }, 3000);
            }
        };
        
        async function playNextEpisode() {
            const { season: nextSeason, episode: nextEp, tmdbId: tid, imdbId: iid } = nextEpisodeData;
            
            debugLog('[NextEp] ========== PLAY NEXT EPISODE ==========', 'info');
            debugLog('[NextEp] Target: S' + nextSeason + 'E' + nextEp);
            debugLog('[NextEp] TMDB ID: ' + tid);
            debugLog('[NextEp] IMDB ID: ' + iid);
            debugLog('[NextEp] Is Debrid: ' + isDebrid);
            debugLog('[NextEp] Current torrent hash: ' + currentTorrentHash);
            debugLog('[NextEp] Current torrent files: ' + (currentTorrentFiles?.length || 0));
            
            // Step 1: Check if next episode is in current torrent (Same Torrent Fast-Path)
            if (currentTorrentFiles && currentTorrentFiles.length > 0) {
                debugLog('[NextEp] Checking same-torrent fast path...');
                const nextFile = findNextEpisodeInTorrent(currentTorrentFiles, nextSeason, nextEp);
                if (nextFile) {
                    debugLog('[NextEp] FAST PATH: Next episode found in same torrent');
                    await playFromSameTorrent(nextFile, nextSeason, nextEp);
                    return;
                }
                debugLog('[NextEp] Episode not in current torrent, will search...');
            } else {
                debugLog('[NextEp] No current torrent files, will search...');
            }
            
            // Step 2: Smart Background Search
            debugLog('[NextEp] Starting background search...');
            const result = await searchNextEpisode(nextSeason, nextEp, tid, iid);
            
            if (!result) {
                throw new Error('No sources found for next episode');
            }
            
            debugLog('[NextEp] Found source: ' + result.title);
            debugLog('[NextEp] Magnet/URL: ' + (result.magnet?.substring(0, 80) || 'N/A') + '...');
            
            // Step 3: Cleanup current torrent if WebTorrent (non-debrid)
            if (!isDebrid && currentTorrentHash) {
                debugLog('[NextEp] Cleaning up current WebTorrent session...');
                try {
                    await fetch(`/api/stop-stream?hash=${currentTorrentHash}`);
                    if (window.electronAPI?.clearWebtorrentTemp) {
                        await window.electronAPI.clearWebtorrentTemp();
                    }
                } catch (e) {
                    debugLog('[NextEp] Cleanup warning: ' + e.message, 'warn');
                }
            }
            
            // Step 4: Play the next episode
            await playNewSource(result, nextSeason, nextEp, tid, iid);
        }
        
        async function playFromSameTorrent(file, nextSeason, nextEp) {
            const fileIndex = file.index !== undefined ? file.index : currentTorrentFiles.indexOf(file);
            const newStreamUrl = `http://127.0.0.1:6987/api/stream-file?hash=${currentTorrentHash}&file=${fileIndex}`;
            
            // Prepare the file for streaming
            fetch(`/api/prepare-file?hash=${currentTorrentHash}&file=${fileIndex}`);
            
            debugLog('[NextEp] Same torrent fast-path: loading new episode');
            debugLog('[NextEp] New stream URL: ' + newStreamUrl);
            
            // CRITICAL: Update the global videoUrl so transcoder uses the new file
            videoUrl = newStreamUrl;
            
            // Reset player state
            nextEpisodeShown = false;
            nextEpBtn.style.display = 'none';
            nextEpBtn.disabled = false;
            nextEpBtn.classList.remove('loading');
            subtitles = [];
            activeSub = null;
            overlay.innerHTML = '';
            retryCount = 0;
            useSoftwareFallback = false; // Reset software fallback for new content
            useRemux = false; // Will be re-evaluated after metadata fetch
            sourceMetadata = null;
            lastAbsoluteTime = 0;
            videoDuration = 0; // Reset duration, will be fetched from new file
            
            // Update title (include show name if available)
            const currentShowName = nextEpisodeData.showName || showName;
            titleEl.textContent = currentShowName ? `${currentShowName} - S${nextSeason}:E${nextEp}` : `S${nextSeason}:E${nextEp}`;
            
            // Update next episode data for the next transition
            nextEpisodeData = {
                season: nextSeason,
                episode: nextEp + 1,
                tmdbId: tmdbId,
                imdbId: imdbId,
                showName: nextEpisodeData.showName
            };
            
            // Show loading spinner
            document.getElementById('loading-spinner').style.display = 'block';
            
            // Fetch new metadata (duration, audio tracks) for the new file
            try {
                debugLog('[NextEp] Fetching metadata for new episode...');
                const metaRes = await fetch(`http://127.0.0.1:6987/api/transcode/metadata?url=${encodeURIComponent(newStreamUrl)}`);
                if (metaRes.ok) {
                    sourceMetadata = await metaRes.json();
                    if (sourceMetadata.duration) {
                        videoDuration = sourceMetadata.duration;
                        debugLog('[NextEp] New episode duration: ' + videoDuration);
                    }
                    if (sourceMetadata.audioTracks) {
                        audioTracks = sourceMetadata.audioTracks;
                        currentAudioTrack = 0; // Reset to first audio track
                        renderAudioTracks();
                    }
                    // Check if we can use remux for the new episode
                    if (sourceMetadata.canRemux) {
                        debugLog('[NextEp] Web-compatible codecs - using REMUX');
                        useRemux = true;
                    } else {
                        debugLog('[NextEp] Incompatible codecs - using transcode');
                        useRemux = false;
                    }
                }
            } catch (e) {
                debugLog('[NextEp] Failed to fetch metadata: ' + e.message, 'error');
                useRemux = false;
            }
            
            // Load the new stream using smart loader
            loadSmartStream(newStreamUrl, 0);
            
            // Fetch new subtitles
            if (tmdbId || imdbId) {
                initSubtitles(tmdbId, imdbId, nextSeason, nextEp, type);
            }
            
            debugLog('[NextEp] Now playing S' + nextSeason + 'E' + nextEp);
        }
        
        async function searchNextEpisode(nextSeason, nextEp, tid, iid) {
            const s = String(nextSeason).padStart(2, '0');
            const e = String(nextEp).padStart(2, '0');
            
            debugLog('[NextEp] ========== SEARCH START ==========', 'info');
            debugLog('[NextEp] Target: S' + s + 'E' + e);
            debugLog('[NextEp] Provider type: ' + currentProviderType);
            debugLog('[NextEp] Stream quality: ' + currentStreamQuality);
            debugLog('[NextEp] IMDB ID: ' + iid);
            debugLog('[NextEp] TMDB ID: ' + tid);
            
            // Use saved show name or fetch from TMDB
            let showName = nextEpisodeData.showName || '';
            debugLog('[NextEp] Saved show name: ' + showName);
            
            if (!showName && tid) {
                try {
                    debugLog('[NextEp] Fetching show name from TMDB...');
                    // Use the server's TMDB proxy instead of direct API call
                    const tmdbRes = await fetch(`/tmdb/tv/${tid}`);
                    if (tmdbRes.ok) {
                        const tmdbData = await tmdbRes.json();
                        showName = tmdbData.name || '';
                        debugLog('[NextEp] Got show name from TMDB: ' + showName);
                    }
                } catch (err) {
                    debugLog('[NextEp] TMDB fetch error: ' + err.message, 'error');
                }
            }
            
            debugLog('[NextEp] Final show name: ' + showName);
            
            let sources = [];
            
            // Use same provider as original search
            if (currentProviderType && currentProviderType !== 'jackett') {
                // Stremio addon search (user selected a specific addon)
                debugLog('[NextEp] Using Stremio addon: ' + currentProviderType);
                if (!iid) {
                    debugLog('[NextEp] No IMDB ID available for addon search!', 'warn');
                }
                sources = await searchAddonForEpisode(currentProviderType, iid, nextSeason, nextEp);
            } else if (showName) {
                // Jackett search (primary - we have show name)
                debugLog('[NextEp] Using Jackett search (primary)');
                sources = await searchJackettForEpisode(showName, nextSeason, nextEp);
                
                // If Jackett fails and we have IMDB ID, try Torrentio as fallback
                if ((!sources || sources.length === 0) && iid) {
                    debugLog('[NextEp] Jackett found nothing, trying Torrentio fallback...');
                    sources = await searchTorrentioForEpisode(iid, nextSeason, nextEp);
                }
            } else if (iid) {
                // No show name but have IMDB ID - use Torrentio
                debugLog('[NextEp] No show name, using Torrentio with IMDB ID');
                sources = await searchTorrentioForEpisode(iid, nextSeason, nextEp);
            } else {
                debugLog('[NextEp] No show name and no IMDB ID - cannot search!', 'error');
                return null;
            }
            
            debugLog('[NextEp] Search returned ' + (sources?.length || 0) + ' sources');
            
            if (!sources || sources.length === 0) {
                debugLog('[NextEp] No sources found!', 'warn');
                return null;
            }
            
            // Filter and sort: Quality match first, then highest seeders
            const targetQuality = currentStreamQuality || '1080p';
            debugLog('[NextEp] Target quality: ' + targetQuality);
            
            sources.sort((a, b) => {
                // Prioritize cached sources (‚ö°)
                const aCached = (a.title || '').includes('‚ö°') || (a.indexer || '').includes('‚ö°');
                const bCached = (b.title || '').includes('‚ö°') || (b.indexer || '').includes('‚ö°');
                if (aCached && !bCached) return -1;
                if (!aCached && bCached) return 1;
                
                // Prioritize matching quality
                const aMatch = a.quality === targetQuality ? 1 : 0;
                const bMatch = b.quality === targetQuality ? 1 : 0;
                if (aMatch !== bMatch) return bMatch - aMatch;
                
                // Then by seeders
                return (b.seeders || 0) - (a.seeders || 0);
            });
            
            debugLog('[NextEp] ========== SEARCH RESULTS ==========', 'info');
            debugLog('[NextEp] Total sources found: ' + sources.length);
            if (sources.length > 0) {
                debugLog('[NextEp] Top 3 results:');
                sources.slice(0, 3).forEach((s, i) => {
                    debugLog(`[NextEp]   ${i+1}. ${s.title?.substring(0, 50)}... | Q: ${s.quality} | S: ${s.seeders}`);
                });
                debugLog('[NextEp] Best match: ' + sources[0]?.title);
            } else {
                debugLog('[NextEp] No sources found!', 'warn');
            }
            
            return sources[0];
        }
        
        async function searchJackettForEpisode(showName, season, episode) {
            const s = String(season).padStart(2, '0');
            const e = String(episode).padStart(2, '0');
            
            // Try multiple query patterns like the details page does
            const queries = [
                `${showName} S${s}E${e}`,
                `${showName} S${s}`  // Also search for season packs
            ];
            
            debugLog('[NextEp] ========== JACKETT SEARCH ==========', 'info');
            debugLog('[NextEp] Show name: ' + showName);
            debugLog('[NextEp] Target: S' + s + 'E' + e);
            debugLog('[NextEp] Queries: ' + queries.join(', '));
            
            const allResults = [];
            
            for (const query of queries) {
                try {
                    debugLog('[NextEp] Searching Jackett for: ' + query);
                    // Note: apikey is empty, server will use internal key
                    const url = `/api/jackett?apikey=&t=search&q=${encodeURIComponent(query)}`;
                    
                    const res = await fetch(url);
                    
                    if (!res.ok) {
                        debugLog('[NextEp] Jackett request failed: ' + res.status + ' ' + res.statusText, 'warn');
                        continue;
                    }
                    
                    const xmlText = await res.text();
                    debugLog('[NextEp] Jackett response length: ' + xmlText.length);
                    
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    
                    // Check for errors
                    const error = xmlDoc.querySelector('error');
                    if (error) {
                        debugLog('[NextEp] Jackett error: ' + error.getAttribute('description'), 'warn');
                        continue;
                    }
                    
                    const items = Array.from(xmlDoc.querySelectorAll('item'));
                    debugLog('[NextEp] Jackett returned ' + items.length + ' items for: ' + query);
                    
                    items.forEach(item => {
                        const title = item.querySelector('title')?.textContent || '';
                        const link = item.querySelector('link')?.textContent || '';
                        const size = item.querySelector('size')?.textContent || item.querySelector('enclosure')?.getAttribute('length') || '0';
                        
                        // Get torznab attributes
                        const attrs = {};
                        const torznabAttrs = item.getElementsByTagName('torznab:attr');
                        for (let i = 0; i < torznabAttrs.length; i++) {
                            const name = torznabAttrs[i].getAttribute('name');
                            const value = torznabAttrs[i].getAttribute('value');
                            if (name) attrs[name] = value;
                        }
                        // Fallback for non-namespaced attrs
                        if (Object.keys(attrs).length === 0) {
                            item.querySelectorAll('attr').forEach(attr => {
                                attrs[attr.getAttribute('name')] = attr.getAttribute('value');
                            });
                        }
                        
                        const magnet = attrs['magneturl'] || (link && link.startsWith('magnet:') ? link : null);
                        const seeders = parseInt(attrs['seeders']) || 0;
                        const tracker = item.querySelector('jackettindexer')?.textContent || 
                                       item.querySelector('prowlarrindexer')?.textContent || 'Unknown';
                        
                        // Skip if no magnet/link or no seeders
                        if (!magnet && !link) return;
                        if (seeders === 0) return;
                        
                        // Filter: must contain the episode pattern or be a season pack
                        const titleLower = title.toLowerCase();
                        const hasEpisode = titleLower.includes(`s${s}e${e}`) || 
                                          titleLower.includes(`${season}x${e}`) ||
                                          titleLower.includes(`s${s.replace(/^0/, '')}e${e}`);
                        const isSeasonPack = (titleLower.includes(`s${s}`) || titleLower.includes(`season ${season}`)) && 
                                            !titleLower.match(/s\d+e\d+/i);
                        
                        if (!hasEpisode && !isSeasonPack) return;
                        
                        // Detect quality
                        let quality = 'Unknown';
                        if (titleLower.includes('2160p') || titleLower.includes('4k')) quality = '4K';
                        else if (titleLower.includes('1080p')) quality = '1080p';
                        else if (titleLower.includes('720p')) quality = '720p';
                        else if (titleLower.includes('480p')) quality = '480p';
                        
                        // Detect codec
                        let codec = 'h264';
                        if (titleLower.includes('x265') || titleLower.includes('hevc')) codec = 'HEVC';
                        else if (titleLower.includes('x264')) codec = 'x264';
                        
                        allResults.push({
                            title,
                            magnet: magnet || link,
                            link,
                            seeders,
                            size: parseInt(size),
                            quality,
                            codec,
                            provider: 'jackett',
                            indexer: tracker,
                            isSeasonPack
                        });
                    });
                } catch (err) {
                    debugLog('[NextEp] Jackett search error: ' + err.message, 'error');
                }
            }
            
            // Deduplicate by magnet/link
            const seen = new Set();
            const unique = allResults.filter(r => {
                const key = r.magnet || r.link;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
            
            debugLog('[NextEp] Jackett total unique results: ' + unique.length);
            return unique;
        }
        
        // Direct Torrentio search (fallback when no provider is saved)
        async function searchTorrentioForEpisode(imdbId, season, episode) {
            debugLog('[NextEp] ========== TORRENTIO SEARCH ==========', 'info');
            debugLog('[NextEp] IMDB ID: ' + imdbId);
            debugLog('[NextEp] Target: S' + season + 'E' + episode);
            
            if (!imdbId) {
                debugLog('[NextEp] No IMDB ID for Torrentio search', 'warn');
                return [];
            }
            
            try {
                const stremioId = `${imdbId}:${season}:${episode}`;
                // Use Torrentio with quality filter (no cam/screener)
                const url = `https://torrentio.strem.fun/qualityfilter=scr,cam/stream/series/${stremioId}.json`;
                
                debugLog('[NextEp] Torrentio URL: ' + url);
                
                const res = await fetch(url);
                debugLog('[NextEp] Torrentio response: ' + res.status);
                
                if (!res.ok) {
                    debugLog('[NextEp] Torrentio request failed: ' + res.status, 'warn');
                    return [];
                }
                
                const data = await res.json();
                const streams = data.streams || [];
                
                debugLog('[NextEp] Torrentio returned ' + streams.length + ' streams');
                
                return streams.map(stream => {
                    const fullText = ((stream.name || '') + ' ' + (stream.title || '')).toLowerCase();
                    
                    // Extract seeders from emoji format: üë§ 100 or üë• 1
                    const seederMatch = (stream.title || '').match(/[üë§üë•]\s*(\d+)/);
                    const seeders = seederMatch ? parseInt(seederMatch[1]) : 0;
                    
                    // Extract size
                    let size = 0;
                    const sizeMatch = (stream.title || '').match(/[üíæüì¶]\s*([\d.]+)\s*([GM]B)/i);
                    if (sizeMatch) {
                        const val = parseFloat(sizeMatch[1]);
                        const unit = sizeMatch[2].toUpperCase();
                        size = val * (unit === 'GB' ? 1024 * 1024 * 1024 : 1024 * 1024);
                    } else if (stream.behaviorHints?.videoSize) {
                        size = stream.behaviorHints.videoSize;
                    }
                    
                    // Build magnet
                    let magnet = stream.url;
                    if (!magnet && stream.infoHash) {
                        const trackers = (stream.sources || [])
                            .filter(s => s.startsWith('tracker:'))
                            .map(s => `&tr=${encodeURIComponent(s.replace('tracker:', ''))}`)
                            .join('');
                        magnet = `magnet:?xt=urn:btih:${stream.infoHash}&dn=${encodeURIComponent(stream.behaviorHints?.filename || 'stream')}${trackers}`;
                    }
                    
                    // Detect quality
                    let quality = 'Unknown';
                    if (fullText.includes('2160p') || fullText.includes('4k')) quality = '4K';
                    else if (fullText.includes('1080p')) quality = '1080p';
                    else if (fullText.includes('720p')) quality = '720p';
                    else if (fullText.includes('480p')) quality = '480p';
                    
                    // Check for cached indicator
                    const isCached = (stream.name || '').includes('‚ö°');
                    
                    return {
                        title: stream.title || stream.name || '',
                        magnet,
                        seeders,
                        size,
                        quality,
                        provider: 'torrentio',
                        indexer: (isCached ? '‚ö° ' : '') + 'Torrentio',
                        infoHash: stream.infoHash
                    };
                }).filter(s => s.magnet);
            } catch (err) {
                debugLog('[NextEp] Torrentio search error: ' + err.message, 'error');
                return [];
            }
        }
        
        async function searchAddonForEpisode(addonId, imdbId, season, episode) {
            debugLog('[NextEp] ========== ADDON SEARCH ==========', 'info');
            debugLog('[NextEp] Addon ID: ' + addonId);
            debugLog('[NextEp] Provider URL (from params): ' + providerUrl);
            debugLog('[NextEp] IMDB ID: ' + imdbId);
            debugLog('[NextEp] Target: S' + season + 'E' + episode);
            
            if (!imdbId) {
                debugLog('[NextEp] No IMDB ID for addon search', 'warn');
                return [];
            }
            
            let baseUrl = '';
            let addonName = addonId;
            
            // Use providerUrl directly if available (passed from details.js)
            if (providerUrl) {
                baseUrl = providerUrl;
                debugLog('[NextEp] Using providerUrl from URL params: ' + baseUrl);
            } else {
                // Fallback: Look up addon from installed list
                debugLog('[NextEp] No providerUrl, falling back to addon lookup...');
                try {
                    let addons = [];
                    if (window.electronAPI?.addonList) {
                        const res = await window.electronAPI.addonList();
                        addons = res.success ? res.addons : [];
                        debugLog('[NextEp] electronAPI.addonList: ' + (res.success ? 'success' : 'failed'));
                    } else {
                        debugLog('[NextEp] electronAPI.addonList not available!', 'warn');
                    }
                    debugLog('[NextEp] Found ' + (addons?.length || 0) + ' installed addons');
                    
                    const addon = addons?.find(a => (a.manifest?.id || a.id) === addonId);
                    
                    if (!addon) {
                        debugLog('[NextEp] Addon not found: ' + addonId, 'warn');
                        return [];
                    }
                    
                    addonName = addon.manifest?.name || addon.name || addonId;
                    debugLog('[NextEp] Found addon: ' + addonName);
                    
                    // Get base URL - try multiple sources
                    baseUrl = addon.baseUrl || addon.transportUrl || addon.manifest?.transportUrl;
                    
                    if (!baseUrl && addon.url) {
                        baseUrl = addon.url.replace('/manifest.json', '');
                    }
                    if (!baseUrl && addon.manifestUrl) {
                        baseUrl = addon.manifestUrl.replace('/manifest.json', '');
                    }
                } catch (err) {
                    debugLog('[NextEp] Addon lookup error: ' + err.message, 'error');
                    return [];
                }
            }
            
            if (!baseUrl) {
                debugLog('[NextEp] No base URL for addon!', 'error');
                return [];
            }
            if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
            
            try {
                const stremioId = `${imdbId}:${season}:${episode}`;
                const url = `${baseUrl}/stream/series/${stremioId}.json`;
                
                debugLog('[NextEp] Base URL: ' + baseUrl);
                debugLog('[NextEp] Stremio ID: ' + stremioId);
                debugLog('[NextEp] Request URL: ' + url);
                
                const res = await fetch(url);
                debugLog('[NextEp] Addon response: ' + res.status);
                
                if (!res.ok) {
                    debugLog('[NextEp] Addon request failed: ' + res.status + ' ' + res.statusText, 'warn');
                    return [];
                }
                
                const data = await res.json();
                const streams = data.streams || [];
                
                debugLog('[NextEp] Addon returned ' + streams.length + ' streams');
                
                return streams.map(stream => {
                    const fullText = ((stream.name || '') + ' ' + (stream.title || '')).toLowerCase();
                    
                    // Extract seeders from emoji format: üë§ 100 or ÔøΩ 1
                    const seederMatch = (stream.title || '').match(/[üë§üë•]\s*(\d+)/);
                    const seeders = seederMatch ? parseInt(seederMatch[1]) : 0;
                    
                    // Extract size from emoji format: üíæ 6.91 GB
                    let size = 0;
                    const sizeMatch = (stream.title || '').match(/[üíæüì¶]\s*([\d.]+)\s*([GM]B)/i);
                    if (sizeMatch) {
                        const val = parseFloat(sizeMatch[1]);
                        const unit = sizeMatch[2].toUpperCase();
                        size = val * (unit === 'GB' ? 1024 * 1024 * 1024 : 1024 * 1024);
                    } else if (stream.behaviorHints?.videoSize) {
                        size = stream.behaviorHints.videoSize;
                    }
                    
                    // Build URL/magnet - prioritize direct URL, then infoHash
                    let playUrl = stream.url || '';
                    const isDirectUrl = playUrl && playUrl.startsWith('http') && !playUrl.includes('.torrent');
                    
                    if (!playUrl && stream.infoHash) {
                        // Build magnet from infoHash with trackers
                        const defaultTrackers = [
                            'udp://tracker.opentrackr.org:1337/announce',
                            'udp://open.tracker.cl:1337/announce',
                            'udp://tracker.openbittorrent.com:6969/announce'
                        ];
                        const trackers = (stream.sources || [])
                            .filter(s => s.startsWith('tracker:'))
                            .map(s => s.replace('tracker:', ''));
                        const allTrackers = trackers.length > 0 ? trackers : defaultTrackers;
                        const trackerParams = allTrackers.map(t => `&tr=${encodeURIComponent(t)}`).join('');
                        playUrl = `magnet:?xt=urn:btih:${stream.infoHash}&dn=${encodeURIComponent(stream.behaviorHints?.filename || 'stream')}${trackerParams}`;
                    }
                    
                    // Detect quality
                    let quality = 'Unknown';
                    if (fullText.includes('2160p') || fullText.includes('4k')) quality = '4K';
                    else if (fullText.includes('1080p')) quality = '1080p';
                    else if (fullText.includes('720p')) quality = '720p';
                    else if (fullText.includes('480p')) quality = '480p';
                    
                    // Check for cached indicator
                    const isCached = (stream.name || '').includes('‚ö°');
                    
                    return {
                        title: stream.title || stream.name || '',
                        magnet: playUrl,
                        seeders,
                        size,
                        quality,
                        provider: addonId,
                        indexer: (isCached ? '‚ö° ' : '') + addonName,
                        infoHash: stream.infoHash,
                        isDirectUrl: isDirectUrl
                    };
                }).filter(s => s.magnet);
            } catch (err) {
                debugLog('[NextEp] Addon search error: ' + err.message, 'error');
                return [];
            }
        }
        
        async function playNewSource(source, nextSeason, nextEp, tid, iid) {
            const magnet = source.magnet;
            
            debugLog('[NextEp] ========== PLAY NEW SOURCE ==========', 'info');
            debugLog('[NextEp] Source: ' + source.title);
            debugLog('[NextEp] URL/Magnet: ' + (magnet?.substring(0, 80) || 'N/A') + '...');
            
            // Check if this is a direct streaming URL (not a magnet or torrent)
            const isDirectUrl = magnet && magnet.startsWith('http') && !magnet.includes('.torrent') && !magnet.startsWith('magnet:');
            
            if (isDirectUrl) {
                // Direct URL - play through transcoder immediately
                debugLog('[NextEp] Direct URL detected, playing through transcoder');
                await loadNewEpisodeInPlayer(magnet, nextSeason, nextEp, tid, iid, null);
                return;
            }
            
            // Check if debrid
            const settingsRes = await fetch('/api/settings');
            const settings = await settingsRes.json();
            const useDebrid = settings.useDebrid && settings.debridAuth;
            
            debugLog('[NextEp] Use Debrid: ' + useDebrid);
            debugLog('[NextEp] Debrid Provider: ' + settings.debridProvider);
            
            if (useDebrid) {
                // Debrid path
                debugLog('[NextEp] Using Debrid for next episode');
                const prepRes = await fetch('/api/debrid/prepare', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ magnet })
                });
                const prepData = await prepRes.json();
                
                debugLog('[NextEp] Debrid prepare: ' + (prepData ? 'success' : 'failed'));
                
                if (prepData && prepData.info) {
                    const files = prepData.info.files || [];
                    debugLog('[NextEp] Debrid returned ' + files.length + ' files');
                    
                    const targetFile = findNextEpisodeInTorrent(files, nextSeason, nextEp);
                    
                    if (targetFile) {
                        debugLog('[NextEp] Found target: ' + (targetFile.path || targetFile.filename || targetFile.name));
                        let fileLink = targetFile.links?.[0];
                        
                        // Real-Debrid fallback
                        if (!fileLink && settings.debridProvider === 'realdebrid' && prepData.info.links) {
                            const selectedFiles = files.filter(f => f.selected === 1);
                            const linkIndex = selectedFiles.indexOf(targetFile);
                            if (linkIndex !== -1) fileLink = prepData.info.links[linkIndex];
                        }
                        
                        if (fileLink) {
                            debugLog('[NextEp] Unrestricting file link...');
                            const unresRes = await fetch('/api/debrid/link', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ link: fileLink })
                            });
                            const unresData = await unresRes.json();
                            
                            if (unresData.url) {
                                debugLog('[NextEp] Got stream URL, loading...');
                                // Load in current player instead of opening new window
                                await loadNewEpisodeInPlayer(unresData.url, nextSeason, nextEp, tid, iid, null);
                                return;
                            }
                        }
                    } else {
                        debugLog('[NextEp] Target file not found in Debrid files!', 'error');
                    }
                }
                throw new Error('Debrid resolution failed');
            } else {
                // WebTorrent path - need to stop old torrent first
                debugLog('[NextEp] Using WebTorrent for next episode');
                
                // Stop the old torrent before starting new one
                if (currentTorrentHash) {
                    debugLog('[NextEp] Stopping old torrent: ' + currentTorrentHash);
                    try {
                        await fetch(`/api/stop-stream?hash=${currentTorrentHash}`);
                    } catch (e) {
                        debugLog('[NextEp] Failed to stop old torrent: ' + e.message, 'warn');
                    }
                }
                
                const torrentRes = await fetch(`/api/torrent-files?magnet=${encodeURIComponent(magnet)}`);
                const torrentData = await torrentRes.json();
                
                if (torrentData && torrentData.videoFiles) {
                    const allFiles = [...torrentData.videoFiles, ...(torrentData.subtitleFiles || [])];
                    const targetFile = findNextEpisodeInTorrent(allFiles, nextSeason, nextEp);
                    
                    if (targetFile) {
                        const newStreamUrl = `http://127.0.0.1:6987/api/stream-file?hash=${torrentData.infoHash}&file=${targetFile.index}`;
                        fetch(`/api/prepare-file?hash=${torrentData.infoHash}&file=${targetFile.index}`);
                        
                        // Update current torrent tracking
                        currentTorrentHash = torrentData.infoHash;
                        currentTorrentFiles = allFiles;
                        
                        // Load in current player
                        await loadNewEpisodeInPlayer(newStreamUrl, nextSeason, nextEp, tid, iid, torrentData.infoHash);
                        return;
                    }
                }
                throw new Error('Could not find episode in torrent');
            }
        }
        
        // Helper function to load a new episode in the current player
        async function loadNewEpisodeInPlayer(newStreamUrl, nextSeason, nextEp, tid, iid, newTorrentHash) {
            debugLog('[NextEp] Loading new episode in current player');
            debugLog('[NextEp] New stream URL: ' + newStreamUrl);
            
            // CRITICAL: Update the global videoUrl so transcoder uses the new file
            videoUrl = newStreamUrl;
            
            // Reset player state
            nextEpisodeShown = false;
            nextEpBtn.style.display = 'none';
            nextEpBtn.disabled = false;
            nextEpBtn.classList.remove('loading');
            subtitles = [];
            activeSub = null;
            overlay.innerHTML = '';
            retryCount = 0;
            useSoftwareFallback = false; // Reset software fallback for new content
            useRemux = false; // Will be re-evaluated after metadata fetch
            sourceMetadata = null;
            lastAbsoluteTime = 0;
            videoDuration = 0; // Reset duration
            
            // Update torrent tracking if provided
            if (newTorrentHash) {
                currentTorrentHash = newTorrentHash;
            }
            
            // Update title (include show name if available)
            const currentShowName2 = nextEpisodeData.showName || showName;
            titleEl.textContent = currentShowName2 ? `${currentShowName2} - S${nextSeason}:E${nextEp}` : `S${nextSeason}:E${nextEp}`;
            
            // Update next episode data for the next transition
            nextEpisodeData = {
                season: nextSeason,
                episode: nextEp + 1,
                tmdbId: tid,
                imdbId: iid,
                showName: nextEpisodeData.showName
            };
            
            // Show loading spinner
            document.getElementById('loading-spinner').style.display = 'block';
            
            // Hide debug overlay when successfully loading new episode
            if (debugVisible) toggleDebug();
            
            // Fetch new metadata (duration, audio tracks) for the new file
            try {
                debugLog('[NextEp] Fetching metadata...');
                const metaRes = await fetch(`http://127.0.0.1:6987/api/transcode/metadata?url=${encodeURIComponent(newStreamUrl)}`);
                if (metaRes.ok) {
                    sourceMetadata = await metaRes.json();
                    if (sourceMetadata.duration) {
                        videoDuration = sourceMetadata.duration;
                        debugLog('[NextEp] Duration: ' + videoDuration);
                    }
                    if (sourceMetadata.audioTracks) {
                        audioTracks = sourceMetadata.audioTracks;
                        currentAudioTrack = 0;
                        renderAudioTracks();
                    }
                    // Check if we can use remux for the new episode
                    if (sourceMetadata.canRemux) {
                        debugLog('[NextEp] Web-compatible codecs - using REMUX');
                        useRemux = true;
                    } else {
                        debugLog('[NextEp] Incompatible codecs - using transcode');
                        useRemux = false;
                    }
                }
            } catch (e) {
                debugLog('[NextEp] Failed to fetch metadata: ' + e.message, 'error');
                useRemux = false;
            }
            
            // Load the new stream using smart loader
            loadSmartStream(newStreamUrl, 0);
            
            // Fetch new subtitles
            if (tid || iid) {
                initSubtitles(tid, iid, nextSeason, nextEp, type);
            }
            
            debugLog('[NextEp] Now playing S' + nextSeason + 'E' + nextEp);
        }
        
        // Initialize next episode detection
        initNextEpisode();
    </script>
</body>
</html>